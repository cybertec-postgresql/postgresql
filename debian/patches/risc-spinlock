commit c32fcac56a212b4e6bb5ba63596f60a25a18109a
Author: Tom Lane <tgl@sss.pgh.pa.us>
Date:   Fri Aug 13 13:58:47 2021 -0400

    Add RISC-V spinlock support in s_lock.h.
    
    Like the ARM case, just use gcc's __sync_lock_test_and_set();
    that will compile into AMOSWAP.W.AQ which does what we need.
    
    At some point it might be worth doing some work on atomic ops
    for RISC-V, but this should be enough for a creditable port.
    
    Back-patch to all supported branches, just in case somebody
    wants to try them on RISC-V.
    
    Marek Szuba
    
    Discussion: https://postgr.es/m/dea97b6d-f55f-1f6d-9109-504aa7dfa421@gentoo.org

diff --git a/src/include/storage/s_lock.h b/src/include/storage/s_lock.h
index 254c40d477..dccbd299ce 100644
--- a/src/include/storage/s_lock.h
+++ b/src/include/storage/s_lock.h
@@ -314,6 +314,7 @@ tas(volatile slock_t *lock)
 #endif /* __INTEL_COMPILER */
 #endif	 /* __ia64__ || __ia64 */
 
+
 /*
  * On ARM and ARM64, we use __sync_lock_test_and_set(int *, int) if available.
  *
@@ -340,6 +341,29 @@ tas(volatile slock_t *lock)
 #endif	 /* __arm__ || __arm || __aarch64__ || __aarch64 */
 
 
+/*
+ * RISC-V likewise uses __sync_lock_test_and_set(int *, int) if available.
+ */
+#if defined(__riscv)
+#ifdef HAVE_GCC__SYNC_INT32_TAS
+#define HAS_TEST_AND_SET
+
+#define TAS(lock) tas(lock)
+
+typedef int slock_t;
+
+static __inline__ int
+tas(volatile slock_t *lock)
+{
+	return __sync_lock_test_and_set(lock, 1);
+}
+
+#define S_UNLOCK(lock) __sync_lock_release(lock)
+
+#endif	 /* HAVE_GCC__SYNC_INT32_TAS */
+#endif	 /* __riscv */
+
+
 /* S/390 and S/390x Linux (32- and 64-bit zSeries) */
 #if defined(__s390__) || defined(__s390x__)
 #define HAS_TEST_AND_SET
