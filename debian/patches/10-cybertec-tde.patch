diff --git a/COPYRIGHT b/COPYRIGHT
index 9d65dbea7e..6df59847cd 100644
--- a/COPYRIGHT
+++ b/COPYRIGHT
@@ -1,6 +1,6 @@
-PostgreSQL Database Management System
-(formerly known as Postgres, then as Postgres95)
+PostgreSQL-TDE Database Management System
 
+Portions Copyright (c) 2020-2022, Cybertec Schönig & Schönig GmbH
 Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
 
 Portions Copyright (c) 1994, The Regents of the University of California
@@ -21,3 +21,12 @@ INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+
+History
+=======
+
+PostgreSQL-TDE is the PostgreSQL database server to which the Transparent Data
+Encryption (TDE) feature has been added. While TDE is copyrighted by Cybertec
+Schönig & Schönig GmbH, all the prior work is copyrighted by the PostgreSQL
+Global Development Group.
diff --git a/NEWS.TDE b/NEWS.TDE
new file mode 100644
index 0000000000..738113be5d
--- /dev/null
+++ b/NEWS.TDE
@@ -0,0 +1,62 @@
+TDE_1.0.3
+=========
+
+Bug Fixes
+---------
+
+1. Reset the statistics if the statistics file is corrupt.
+
+The particular problem was an encrypted statistics file whose size was not a
+whole multiple of BLCKSZ (typically 8 kB). Although there can be other kinds
+of corruption, this one is very easy to identify and handle.
+
+
+TDE_1.0.2
+=========
+
+Bug Fixes
+---------
+
+* Make sure that the shared memory data cannot be written to disk.
+
+  If the dynamic_shared_memory_type configuration variable is set to "mmap",
+  the (unencrypted) shared memory data can be written to disk. This value is
+  rather unusual and the initdb utility should never set it, but in theory the
+  DBA can do. Our fix is to refuse startup if this value is set and if the
+  instance is encrypted at the same time.
+
+
+TDE_1.0.1
+=========
+
+Bug fixes
+---------
+
+* When a buffer of a temporary file has been dumped, the following block (if
+  it exists) must be loaded into the buffer before we start writing into
+  it. Otherwise the next dump can overwrite valid data of the following block
+  with zeroes.
+
+  Fortunately this bugs seems to be hidden by the fact that logtape.c only
+  writes whole blocks and that other callers of the buffile.c API do not seem
+  to overwrite the temporary files at all.
+
+* Fixed the use and processing of the "encryption key command".
+
+  The command that should generate the encryption key is passed to various
+  processes via the -K command line option. So far it had two issues:
+
+  1) If one program was passing the -K option to another (e.g. initdb to
+  bootstrap), it didn't quote the argument. This was typically a problem when
+  the command called the pg_keytool utility. (Spaces are needed to separate
+  the pg_keytool executable from its command line options.)
+
+  2) If the command contained the '%D' pattern (for the substitution of the
+  data directory path), not enough memory was allocated for the final command
+  string.
+
+
+TDE_1.0.0
+=========
+
+The initial implementation of the TDE feature.
diff --git a/configure b/configure
index 8972c6a2dc..b8b304a549 100755
--- a/configure
+++ b/configure
@@ -580,11 +580,11 @@ MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
-PACKAGE_NAME='PostgreSQL'
-PACKAGE_TARNAME='postgresql'
-PACKAGE_VERSION='12.13'
-PACKAGE_STRING='PostgreSQL 12.13'
-PACKAGE_BUGREPORT='pgsql-bugs@lists.postgresql.org'
+PACKAGE_NAME='PostgreSQL-TDE'
+PACKAGE_TARNAME='postgresql-tde'
+PACKAGE_VERSION='12.13_TDE_1.0.3'
+PACKAGE_STRING='PostgreSQL 12.13 TDE 1.0.3'
+PACKAGE_BUGREPORT='bugs-tde@cybertec.at'
 PACKAGE_URL=''
 
 ac_unique_file="src/backend/access/common/heaptuple.c"
diff --git a/contrib/bloom/blinsert.c b/contrib/bloom/blinsert.c
index 4b2186b8dd..20fc1e489f 100644
--- a/contrib/bloom/blinsert.c
+++ b/contrib/bloom/blinsert.c
@@ -177,6 +177,9 @@ blbuildempty(Relation index)
 	 * itself might remove it while replaying, for example, an
 	 * XLOG_DBASE_CREATE or XLOG_TBLSPC_CREATE record.  Therefore, we need
 	 * this even when wal_level=minimal.
+	 *
+	 * Encryption: nothing to do, LSN (the encryption IV) is not set and there
+	 * is no user data yet.
 	 */
 	PageSetChecksumInplace(metapage, BLOOM_METAPAGE_BLKNO);
 	smgrwrite(index->rd_smgr, INIT_FORKNUM, BLOOM_METAPAGE_BLKNO,
diff --git a/contrib/pg_visibility/pg_visibility.c b/contrib/pg_visibility/pg_visibility.c
index 1372bb638f..a166b0399d 100644
--- a/contrib/pg_visibility/pg_visibility.c
+++ b/contrib/pg_visibility/pg_visibility.c
@@ -392,7 +392,7 @@ pg_truncate_visibility_map(PG_FUNCTION_ARGS)
 	RelationOpenSmgr(rel);
 	rel->rd_smgr->smgr_vm_nblocks = InvalidBlockNumber;
 
-	visibilitymap_truncate(rel, 0);
+	visibilitymap_truncate(rel, 0, InvalidXLogRecPtr);
 
 	if (RelationNeedsWAL(rel))
 	{
diff --git a/doc/src/sgml/acronyms.sgml b/doc/src/sgml/acronyms.sgml
index e7801736a5..01f2bda31c 100644
--- a/doc/src/sgml/acronyms.sgml
+++ b/doc/src/sgml/acronyms.sgml
@@ -387,6 +387,16 @@
     </listitem>
    </varlistentry>
 
+   <varlistentry>
+    <term><acronym>KDF</acronym></term>
+    <listitem>
+     <para>
+      <ulink url="https://en.wikipedia.org/wiki/Key_derivation_function">Key
+      Derivation Function</ulink>
+     </para>
+    </listitem>
+   </varlistentry>
+
    <varlistentry>
     <term><acronym>LDAP</acronym></term>
     <listitem>
diff --git a/doc/src/sgml/config.sgml b/doc/src/sgml/config.sgml
index 46b044de90..36f091f638 100644
--- a/doc/src/sgml/config.sgml
+++ b/doc/src/sgml/config.sgml
@@ -9338,6 +9338,20 @@ dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'
       </listitem>
      </varlistentry>
 
+     <varlistentry id="guc-data-encryption" xreflabel="data_encryption">
+      <term><varname>data_encryption</varname> (<type>boolean</type>)
+      <indexterm>
+       <primary><varname>data_encryption</varname> configuration parameter</primary>
+      </indexterm>
+      </term>
+      <listitem>
+       <para>
+        Reports whether data encryption is enabled for this cluster.
+        See <xref linkend="encryption"/> for more information.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry id="guc-data-directory-mode" xreflabel="data_directory_mode">
       <term><varname>data_directory_mode</varname> (<type>integer</type>)
       <indexterm>
diff --git a/doc/src/sgml/encryption.sgml b/doc/src/sgml/encryption.sgml
new file mode 100644
index 0000000000..9dbee2ad33
--- /dev/null
+++ b/doc/src/sgml/encryption.sgml
@@ -0,0 +1,147 @@
+<!-- doc/src/sgml/encryption.sgml -->
+
+<chapter id="encryption">
+ <title>Transparent Data Encryption</title>
+
+ <para>
+  Cluster encryption can be used if the <acronym>DBA</acronym> cannot or does not
+  want to rely on the filesystem in terms of data confidentiality. If this
+  feature is enabled, <productname>PostgreSQL</productname> encrypts data
+  (both relations and write-ahead log) when writing it to disk, and decrypts
+  it when reading it. The encryption is transparent, so applications see no
+  difference between encrypted and unencrypted clusters.
+ </para>
+
+ <para>
+  If you want to use this feature, please make sure
+  that <productname>OpenSSL</productname> is installed on your server and that
+  support in <productname>PostgreSQL</productname> is enabled at build time
+  (see <xref linkend="installation"/>).
+ </para>
+
+ <para>
+  To create an encrypted cluster, call <xref linkend="app-initdb"/> with the
+  option <option>-K</option> and the path to the command that will retrieve
+  the encryption key. For example:
+<screen>
+<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data -K /usr/local/pgsql/fetch_key_cmd</userinput>
+</screen>
+  Here <filename>/usr/local/pgsql/fetch_key_cmd</filename> is an executable
+  file that writes the encryption key to its standard output and returns
+  zero.
+ </para>
+
+ <para>
+   The encryption key is expected in hexadecimal format, two characters
+   (hexadecimal digits) per byte. Since <productname>PostgreSQL</productname>
+   currently uses a key of length 16 bytes (128 bits), the expected length of
+   the key string is 32 characters. For example:
+   <computeroutput>
+     882fb7c12e80280fd664c69d2d636913
+   </computeroutput>
+ </para>
+
+ <para>
+   <application>initdb</application> eventually puts the encryption key
+   command into the <filename>postgresql.conf</filename> file, as the value
+   of the <literal>encryption_key_command</literal> parameter. That ensures that
+   you don't need to pass it to <application>pg_ctl</application> each time
+   you want to start the server.
+ </para>
+
+ <para>
+   If you want to enter a password, you can use the
+   <xref linkend="app-pg-keytool"/> utility to derive an encryption key from
+   it. For example, if the <option>-K</option> option looks like the
+   following example, the DBA will be asked for a password interactively:
+
+<screen>
+<prompt>$</prompt> <userinput>initdb -K '(read -sp "Cluster encryption password: " PGENCRPWD; echo $PGENCRPWD | pg_keytool -D %D -w)' -D data
+</userinput>
+</screen>
+
+ </para>
+
+ <note id="encryption_kdf_file">
+  <title>kdf_params file</title>
+  <para>
+    If the cluster should be encrypted, <application>initdb</application>
+    creates <filename>global/kdf_params</filename> file in the data
+    directory. This file contains parameters of
+    the <ulink url="https://en.wikipedia.org/wiki/Key_derivation_function">key
+    derivation function</ulink> (<acronym>KDF</acronym>) and is needed to
+    derive the encryption key from a password. Currently the only
+    supported <acronym>KDF</acronym>
+    is <ulink url="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</ulink>, so
+    the parameters stored in the file are: 1) number of iterations and 2)
+    salt. Since the salt is data directory specific, a different key will be
+    derived from the same password for different data directories.
+  </para>
+
+  <para>
+   The <filename>kdf_params</filename> file contents is not secret, but if it
+   gets lost, you can no longer derive the encryption key from the
+   password. However but you can still use the encryption key if you have it
+   stored somewhere.
+  </para>
+ </note>
+
+ <para>
+   As long as <application>pg_keytool</application> is called
+   by <application>initdb</application>, you can put <literal>%D</literal>
+   into the command and
+   <application>initdb</application> will replace it with the actual directory
+   path. Note, however, that only the actual value of the <option>-K</option>
+   option is subject to this replacement. No replacement will take place
+   if <application>pg_keytool</application> is called from a shell script
+   whose path is passed to <application>initdb</application> via
+   the <option>-K</option> option. In such a case, it may be easier to pass the
+   data directory to
+   <application>pg_keytool</application> via the <envar>PGDATA</envar> environment
+   variable.
+ </para>
+
+ <para>
+   If the <literal>encryption_key_command</literal> setting is not present
+   in <filename>postgresql.conf</filename>, the command can be passed to
+   <xref linkend="app-pg-ctl"/> when starting the cluster:
+
+<screen>
+<prompt>$</prompt> <userinput>pg_ctl -K '(read -sp "Cluster encryption password: " PGENCRPWD; echo $PGENCRPWD | pg_keytool -D %D -w)' -D data start
+</userinput>
+</screen>
+ </para>
+
+ <note>
+   <para>
+     You need to use the <option>-K</option> option if the encryption key
+     command needs to read the password from the console, like it does in the
+     example above. In such a case, please comment out
+     the <literal>encryption_key_command</literal> parameter
+     in <filename>postgresql.conf</filename>.
+   </para>
+ </note>
+
+ <para>
+  Once the <productname>PostgreSQL</productname> server is running, client
+  applications should recognize no difference to an unencrypted cluster,
+  except that the <xref linkend="guc-data-encryption"/> variable is set.
+ </para>
+
+ <para>
+  Since WAL is encrypted, any replication solution based on log shipping
+  (<xref linkend="warm-standby"/>) assumes that all standby servers are
+  encrypted using the same key as their primary server. On the other hand,
+  logical replication (see <xref linkend="logical-replication"/>) allows
+  replication between encrypted and unencrypted clusters, or between clusters
+  encrypted with different keys.
+ </para>
+
+ <note>
+  <para>
+   Key rotation is currently not supported. If you need it, you can use the key
+   management system of your choice and rotate the corresponding key encryption
+   key (KEK) instead.
+  </para>
+ </note>
+</chapter>
diff --git a/doc/src/sgml/filelist.sgml b/doc/src/sgml/filelist.sgml
index a58494720f..d3b3ab7a84 100644
--- a/doc/src/sgml/filelist.sgml
+++ b/doc/src/sgml/filelist.sgml
@@ -48,6 +48,7 @@
 <!ENTITY wal           SYSTEM "wal.sgml">
 <!ENTITY logical-replication    SYSTEM "logical-replication.sgml">
 <!ENTITY jit    SYSTEM "jit.sgml">
+<!ENTITY encryption    SYSTEM "encryption.sgml">
 
 <!-- programmer's guide -->
 <!ENTITY bgworker   SYSTEM "bgworker.sgml">
diff --git a/doc/src/sgml/installation.sgml b/doc/src/sgml/installation.sgml
index f723533619..2eb21b2d76 100644
--- a/doc/src/sgml/installation.sgml
+++ b/doc/src/sgml/installation.sgml
@@ -251,8 +251,9 @@ su - postgres
     <listitem>
      <para>
       You need <productname>OpenSSL</productname>, if you want to support
-      encrypted client connections.  <productname>OpenSSL</productname> is
-      also required for random number generation on platforms that do not
+      on-disk data encryption or encrypted client
+      connections.  <productname>OpenSSL</productname> is also required for
+      random number generation on platforms that do not
       have <filename>/dev/urandom</filename> (except Windows).  The minimum
       version required is 0.9.8.
      </para>
@@ -841,10 +842,11 @@ su - postgres
        </term>
        <listitem>
         <para>
-         Build with support for <acronym>SSL</acronym> (encrypted)
-         connections. This requires the <productname>OpenSSL</productname>
-         package to be installed.  <filename>configure</filename> will check
-         for the required header files and libraries to make sure that
+         Build with support for on-disk data encryption
+         or <acronym>SSL</acronym> (encrypted) connections. This requires
+         the <productname>OpenSSL</productname> package to be
+         installed.  <filename>configure</filename> will check for the
+         required header files and libraries to make sure that
          your <productname>OpenSSL</productname> installation is sufficient
          before proceeding.
         </para>
diff --git a/doc/src/sgml/postgres.sgml b/doc/src/sgml/postgres.sgml
index 405e1c7b08..049a09d3b7 100644
--- a/doc/src/sgml/postgres.sgml
+++ b/doc/src/sgml/postgres.sgml
@@ -163,6 +163,7 @@
   &wal;
   &logical-replication;
   &jit;
+  &encryption;
   &regress;
 
  </part>
diff --git a/doc/src/sgml/protocol.sgml b/doc/src/sgml/protocol.sgml
index e91611157c..9fc952e34b 100644
--- a/doc/src/sgml/protocol.sgml
+++ b/doc/src/sgml/protocol.sgml
@@ -2117,7 +2117,7 @@ The commands accepted in replication mode are:
   </varlistentry>
 
   <varlistentry>
-    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
+    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ] [ <literal>DECRYPT</literal> ]
      <indexterm><primary>START_REPLICATION</primary></indexterm>
     </term>
     <listitem>
@@ -2171,6 +2171,11 @@ The commands accepted in replication mode are:
       client contains a message of one of the following formats:
      </para>
 
+     <para>
+      If the server is encrypted, the <literal>DECRYPT</literal> option can be
+      passed to tell the server that the WAL stream should be sent in decrypted form.
+     </para>
+
      <para>
       <variablelist>
       <varlistentry>
@@ -2567,7 +2572,7 @@ The commands accepted in replication mode are:
   </varlistentry>
 
   <varlistentry>
-    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ]
+    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ] [ <literal>DECRYPT</literal> ]
      <indexterm><primary>BASE_BACKUP</primary></indexterm>
     </term>
     <listitem>
@@ -2677,6 +2682,22 @@ The commands accepted in replication mode are:
          </para>
         </listitem>
        </varlistentry>
+
+       <varlistentry>
+        <term><literal>DECRYPT</literal></term>
+        <listitem>
+         <para>
+          If the cluster is encrypted and this option is passed, the relation
+          files and WAL files are decrypted before they are sent to the
+          client. In addition, the <literal>Data encryption</literal> field of
+          the control file is set to <literal>off</literal>. This option also
+          ensures that the <filename>global/kdf_params</filename> file
+          (containing parameters of the key derivation function, which is used
+          to derive the encryption key from the password) is not sent to the
+          client.
+         </para>
+        </listitem>
+       </varlistentry>
       </variablelist>
      </para>
      <para>
diff --git a/doc/src/sgml/ref/allfiles.sgml b/doc/src/sgml/ref/allfiles.sgml
index 378380c0e2..58e25b917d 100644
--- a/doc/src/sgml/ref/allfiles.sgml
+++ b/doc/src/sgml/ref/allfiles.sgml
@@ -206,6 +206,7 @@ Complete list of usable sgml source files in this directory.
 <!ENTITY pgDump             SYSTEM "pg_dump.sgml">
 <!ENTITY pgDumpall          SYSTEM "pg_dumpall.sgml">
 <!ENTITY pgIsready          SYSTEM "pg_isready.sgml">
+<!ENTITY pgKeytool          SYSTEM "pg_keytool.sgml">
 <!ENTITY pgReceivewal       SYSTEM "pg_receivewal.sgml">
 <!ENTITY pgRecvlogical      SYSTEM "pg_recvlogical.sgml">
 <!ENTITY pgResetwal         SYSTEM "pg_resetwal.sgml">
diff --git a/doc/src/sgml/ref/initdb.sgml b/doc/src/sgml/ref/initdb.sgml
index af76dbede4..e5711b88a1 100644
--- a/doc/src/sgml/ref/initdb.sgml
+++ b/doc/src/sgml/ref/initdb.sgml
@@ -209,6 +209,17 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry id="app-initdb-data-encr-cmd" xreflabel="data encryption">
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        Encrypt the cluster using a key retrieved from the command specified
+        here. See <xref linkend="encryption"/> for more information.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry id="app-initdb-data-checksums" xreflabel="data checksums">
       <term><option>-k</option></term>
       <term><option>--data-checksums</option></term>
diff --git a/doc/src/sgml/ref/pg_basebackup.sgml b/doc/src/sgml/ref/pg_basebackup.sgml
index 4e2db60b83..6ec0ff4574 100644
--- a/doc/src/sgml/ref/pg_basebackup.sgml
+++ b/doc/src/sgml/ref/pg_basebackup.sgml
@@ -355,6 +355,19 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-y</option></term>
+      <term><option>--decrypt</option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted (see <xref linkend="encryption"/>), this
+        option can be passed to tell the server that the data should be
+        decrypted before it's sent
+        to <application>pg_basebackup</application>.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-z</option></term>
       <term><option>--gzip</option></term>
diff --git a/doc/src/sgml/ref/pg_ctl-ref.sgml b/doc/src/sgml/ref/pg_ctl-ref.sgml
index 3946fa52ea..a3c0c8eb57 100644
--- a/doc/src/sgml/ref/pg_ctl-ref.sgml
+++ b/doc/src/sgml/ref/pg_ctl-ref.sgml
@@ -24,6 +24,7 @@ PostgreSQL documentation
    <command>pg_ctl</command>
    <arg choice="plain"><option>init[db]</option></arg>
    <arg choice="opt"><option>-D</option> <replaceable>datadir</replaceable></arg>
+   <arg choice="opt"><option>-K</option> <replaceable>command</replaceable></arg>
    <arg choice="opt"><option>-s</option></arg>
    <arg choice="opt"><option>-o</option> <replaceable>initdb-options</replaceable></arg>
   </cmdsynopsis>
@@ -32,6 +33,7 @@ PostgreSQL documentation
    <command>pg_ctl</command>
    <arg choice="plain"><option>start</option></arg>
    <arg choice="opt"><option>-D</option> <replaceable>datadir</replaceable></arg>
+   <arg choice="opt"><option>-K</option> <replaceable>command</replaceable></arg>
    <arg choice="opt"><option>-l</option> <replaceable>filename</replaceable></arg>
    <arg choice="opt"><option>-W</option></arg>
    <arg choice="opt"><option>-t</option> <replaceable>seconds</replaceable></arg>
@@ -61,6 +63,7 @@ PostgreSQL documentation
    <command>pg_ctl</command>
    <arg choice="plain"><option>restart</option></arg>
    <arg choice="opt"><option>-D</option> <replaceable>datadir</replaceable></arg>
+   <arg choice="opt"><option>-K</option> <replaceable>command</replaceable></arg>
    <arg choice="opt"><option>-m</option>
      <group choice="plain">
        <arg choice="plain"><option>s[mart]</option></arg>
@@ -292,6 +295,33 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K <replaceable class="parameter">command</replaceable></option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted and
+        if <literal>encryption_key_command</literal> is not present
+        in <filename>postgresql.conf</filename>, this option can be used to
+        pass the encryption key command to <application>pg_ctl</application>.
+        <application>pg_ctl</application> runs this command to retrieve the
+        encryption key and sends the key to the database server during startup
+        - see <xref linkend="encryption"/> for details.
+       </para>
+
+       <note>
+        <para>
+         If you start your cluster in another way than
+         using <application>pg_ctl</application> (for example
+         using <firstterm>systemd</firstterm> or a custom script) (and
+         if <literal>encryption_key_command</literal> is not present
+         in <filename>postgresql.conf</filename>), consider sending the key
+         using the <xref linkend="app-pg-keytool"/> utility.
+        </para>
+       </note>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-l <replaceable class="parameter">filename</replaceable></option></term>
       <term><option>--log=<replaceable class="parameter">filename</replaceable></option></term>
diff --git a/doc/src/sgml/ref/pg_keytool.sgml b/doc/src/sgml/ref/pg_keytool.sgml
new file mode 100644
index 0000000000..91da4c2c32
--- /dev/null
+++ b/doc/src/sgml/ref/pg_keytool.sgml
@@ -0,0 +1,145 @@
+<!--
+doc/src/sgml/ref/pg_keytool.sgml
+PostgreSQL documentation
+-->
+
+<refentry id="app-pg-keytool">
+ <indexterm zone="app-pg-keytool">
+  <primary>pg_keytool</primary>
+ </indexterm>
+
+ <refmeta>
+  <refentrytitle><application>pg_keytool</application></refentrytitle>
+  <manvolnum>1</manvolnum>
+  <refmiscinfo>Application</refmiscinfo>
+ </refmeta>
+
+ <refnamediv>
+  <refname>pg_keytool</refname>
+  <refpurpose>derive cluster encryption key and/or send it to the
+    <productname>PostgreSQL</productname> server</refpurpose>
+ </refnamediv>
+
+ <refsynopsisdiv>
+  <cmdsynopsis>
+   <command>pg_keytool</command>
+   <arg rep="repeat"><replaceable class="parameter">option</replaceable></arg>
+  </cmdsynopsis>
+ </refsynopsisdiv>
+
+ <refsect1>
+  <title>Description</title>
+  <para>
+   <application>pg_keytool</application> reads either an encryption key or a
+   password (if the <option>-w</option> was specified) from standard input. If
+   it receives a password, it runs
+   the <ulink url="https://en.wikipedia.org/wiki/Key_derivation_function"><firstterm>key
+   derivation function</firstterm></ulink> (<acronym>KDF</acronym>) on it in
+   order to derive the key.
+  </para>
+
+  <para>
+   The encryption key is written either to standard output (the default
+   behavior) or, if any of the <option>-s</option>, <option>-h</option>
+   or <option>-p</option> options is specified, sent via a frontend/backend
+   protocol to the <productname>PostgreSQL</productname> server during start
+   up.
+  </para>
+
+  <para>
+   One common use case is that <application>pg_keytool</application> is used
+   with the <option>-K</option> option of <command>initdb</command> or
+   <command>pg_ctl</command>, see the examples in
+   <xref linkend="encryption"/>. In this case it sends the encryption key to
+   standard output.
+  </para>
+
+  <para>
+   The other use case is that <productname>PostgreSQL</productname> is started
+   in another way than using <xref linkend="app-pg-ctl"/>, typically
+   using <firstterm>systemd</firstterm> or a custom script. In this
+   case, <application>pg_keytool</application> can be used to send the key to
+   the server. (<application>pg_keytool</application> should connect to
+   the same port or Unix-domain socket to which applications will eventually
+   connect.)
+  </para>
+
+  <para>
+   If in the latter case you provide <application>pg_keytool</application>
+   with an encryption key (as opposed to with a password), the utility only ensures
+   transmission of the key to the database server.
+  </para>
+ </refsect1>
+
+ <refsect1>
+  <title>Options</title>
+
+   <para>
+    <variablelist>
+     <varlistentry>
+      <term><option>-D <replaceable>directory</replaceable></option></term>
+      <listitem>
+       <para>
+        Specifies the directory where the database cluster is stored. In
+        particular, <application>pg_keytool</application> looks for
+        the <filename>global/kdf_params</filename> file here, see
+        <xref linkend="encryption_kdf_file"/>.
+       </para>
+
+       <para>
+         If this option is not passed, <application>pg_keytool</application>
+         tries to get the data directory from the <envar>PGDATA</envar>
+         environment variable.
+       </para>
+      </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-h <replaceable class="parameter">hostname</replaceable></option></term>
+       <term><option>--host=<replaceable class="parameter">hostname</replaceable></option></term>
+       <listitem>
+        <para>
+          Specifies the host name of the machine on which the server is
+          running. If the value begins with a slash, it is used as the
+          directory for the Unix-domain socket.
+        </para>
+       </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-p <replaceable class="parameter">port</replaceable></option></term>
+       <listitem>
+         <para>
+           Specifies the TCP port or the local Unix-domain socket file
+           extension on which the server is listening for connections.
+           Defaults to the port specified at compile time, usually 5432.
+         </para>
+       </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-s</option></term>
+       <listitem>
+         <para>
+           Send the key to the <productname>PostgreSQL</productname> server
+           rather than to standard output. This option does not have to be
+           specified explicitly if the
+           <literal>--host</literal> or <literal>--port</literal> option is
+           passed.
+         </para>
+       </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-w</option></term>
+       <listitem>
+         <para>
+           If this option is given, the data read from the standard input is
+           the password, otherwise it is the encryption key itself.
+         </para>
+       </listitem>
+     </varlistentry>
+    </variablelist>
+   </para>
+ </refsect1>
+</refentry>
diff --git a/doc/src/sgml/ref/pg_receivewal.sgml b/doc/src/sgml/ref/pg_receivewal.sgml
index f0c76fa69d..d5d367810a 100644
--- a/doc/src/sgml/ref/pg_receivewal.sgml
+++ b/doc/src/sgml/ref/pg_receivewal.sgml
@@ -253,6 +253,19 @@ PostgreSQL documentation
      </varlistentry>
 
      <varlistentry>
+      <term><option>-y</option></term>
+      <term><option>--decrypt</option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted (see <xref linkend="encryption"/>), this
+        option can be passed to tell the server that the data should be
+        decrypted before it's sent
+        to <application>pg_receivewal</application>.
+       </para>
+      </listitem>
+     </varlistentry>
+
+   <varlistentry>
       <term><option>-Z <replaceable class="parameter">level</replaceable></option></term>
       <term><option>--compress=<replaceable class="parameter">level</replaceable></option></term>
       <listitem>
diff --git a/doc/src/sgml/ref/pg_resetwal.sgml b/doc/src/sgml/ref/pg_resetwal.sgml
index fd539f5604..5de101fcf1 100644
--- a/doc/src/sgml/ref/pg_resetwal.sgml
+++ b/doc/src/sgml/ref/pg_resetwal.sgml
@@ -99,6 +99,17 @@ PostgreSQL documentation
     </listitem>
    </varlistentry>
 
+   <varlistentry>
+     <term><option>-K</option></term>
+     <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+     <listitem>
+       <para>
+        If the cluster is encrypted (see <xref linkend="encryption"/>), run
+        this command to retrieve the encryption key.
+       </para>
+     </listitem>
+   </varlistentry>
+
    <varlistentry>
     <term><option>-n</option></term>
     <term><option>--dry-run</option></term>
diff --git a/doc/src/sgml/ref/pg_rewind.sgml b/doc/src/sgml/ref/pg_rewind.sgml
index 272bd113b9..0fab471940 100644
--- a/doc/src/sgml/ref/pg_rewind.sgml
+++ b/doc/src/sgml/ref/pg_rewind.sgml
@@ -137,6 +137,17 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted, run this command to retrieve the
+        encryption key. See <xref linkend="encryption"/> for details.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>--source-pgdata=<replaceable class="parameter">directory</replaceable></option></term>
       <listitem>
diff --git a/doc/src/sgml/ref/pg_waldump.sgml b/doc/src/sgml/ref/pg_waldump.sgml
index 667093f060..ea0ef0e414 100644
--- a/doc/src/sgml/ref/pg_waldump.sgml
+++ b/doc/src/sgml/ref/pg_waldump.sgml
@@ -100,6 +100,17 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted, run this command to retrieve the
+        encryption key. See <xref linkend="encryption"/> for details.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-n <replaceable>limit</replaceable></option></term>
       <term><option>--limit=<replaceable>limit</replaceable></option></term>
diff --git a/doc/src/sgml/ref/pgupgrade.sgml b/doc/src/sgml/ref/pgupgrade.sgml
index b1c37fd083..fa0acdb92b 100644
--- a/doc/src/sgml/ref/pgupgrade.sgml
+++ b/doc/src/sgml/ref/pgupgrade.sgml
@@ -122,6 +122,37 @@ PostgreSQL documentation
       </para></listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option> <replaceable class="parameter">command</replaceable></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the clusters are encrypted, run this command to retrieve the
+        encryption key. This is the same command that was passed to
+        <xref linkend="app-initdb"/> for cluster creation. For the upgrade to
+        be successful, both old and new clusters must use the same key.
+        Therefore, unless the command contains the <literal>%D</literal>
+        string, it does not matter which cluster the command comes from.
+       </para>
+
+       <note>
+         <para>
+           If you are using <xref linkend="app-pg-keytool"/> to derive the
+           encryption key (see <xref linkend="app-initdb-data-encr-cmd"/>),
+           make sure the <option>-D</option> option points to
+           the <emphasis>old</emphasis> cluster. If it pointed to the new
+           one, then the new cluster would derive a different key from the same
+           password, thus <xref linkend="pgupgrade"/> would fail to start
+           the new cluster.
+         </para>
+       </note>
+
+       <para>
+         See <xref linkend="encryption"/> for details on the command.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-k</option></term>
       <term><option>--link</option></term>
diff --git a/doc/src/sgml/reference.sgml b/doc/src/sgml/reference.sgml
index cef09dd38b..5eed489f27 100644
--- a/doc/src/sgml/reference.sgml
+++ b/doc/src/sgml/reference.sgml
@@ -279,6 +279,7 @@
    &pgChecksums;
    &pgControldata;
    &pgCtl;
+   &pgKeytool;
    &pgResetwal;
    &pgRewind;
    &pgtestfsync;
diff --git a/src/backend/access/brin/brin.c b/src/backend/access/brin/brin.c
index d9573bece7..83111e0755 100644
--- a/src/backend/access/brin/brin.c
+++ b/src/backend/access/brin/brin.c
@@ -668,6 +668,7 @@ brinbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 	BrinBuildState *state;
 	Buffer		meta;
 	BlockNumber pagesPerRange;
+	Page		page;
 
 	/*
 	 * We expect to be called exactly once for any index relation.
@@ -689,11 +690,11 @@ brinbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 					   BRIN_CURRENT_VERSION);
 	MarkBufferDirty(meta);
 
+	page = BufferGetPage(meta);
 	if (RelationNeedsWAL(index))
 	{
 		xl_brin_createidx xlrec;
 		XLogRecPtr	recptr;
-		Page		page;
 
 		xlrec.version = BRIN_CURRENT_VERSION;
 		xlrec.pagesPerRange = BrinGetPagesPerRange(index);
@@ -704,9 +705,10 @@ brinbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 
 		recptr = XLogInsert(RM_BRIN_ID, XLOG_BRIN_CREATE_INDEX);
 
-		page = BufferGetPage(meta);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	UnlockReleaseBuffer(meta);
 
@@ -1186,7 +1188,8 @@ terminate_brin_buildstate(BrinBuildState *state)
 		blk = BufferGetBlockNumber(state->bs_currentInsertBuf);
 		ReleaseBuffer(state->bs_currentInsertBuf);
 		RecordPageWithFreeSpace(state->bs_irel, blk, freespace);
-		FreeSpaceMapVacuumRange(state->bs_irel, blk, blk + 1);
+		FreeSpaceMapVacuumRange(state->bs_irel, blk, blk + 1,
+								InvalidXLogRecPtr);
 	}
 
 	brin_free_desc(state->bs_bdesc);
diff --git a/src/backend/access/brin/brin_pageops.c b/src/backend/access/brin/brin_pageops.c
index 94e9d6bf5d..1a56ccd4b5 100644
--- a/src/backend/access/brin/brin_pageops.c
+++ b/src/backend/access/brin/brin_pageops.c
@@ -139,7 +139,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 				brin_initialize_empty_new_buffer(idxrel, newbuf);
 			UnlockReleaseBuffer(newbuf);
 			if (extended)
-				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+										InvalidXLogRecPtr);
 		}
 		return false;
 	}
@@ -160,7 +161,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 				brin_initialize_empty_new_buffer(idxrel, newbuf);
 			UnlockReleaseBuffer(newbuf);
 			if (extended)
-				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+										InvalidXLogRecPtr);
 		}
 		return false;
 	}
@@ -201,6 +203,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 
 			PageSetLSN(oldpage, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(oldpage);
 
 		END_CRIT_SECTION();
 
@@ -213,7 +217,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 				brin_initialize_empty_new_buffer(idxrel, newbuf);
 			UnlockReleaseBuffer(newbuf);
 			if (extended)
-				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+										InvalidXLogRecPtr);
 		}
 
 		return true;
@@ -301,6 +306,9 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 			PageSetLSN(newpage, recptr);
 			PageSetLSN(BufferGetPage(revmapbuf), recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption3(oldpage, newpage,
+										 BufferGetPage(revmapbuf));
 
 		END_CRIT_SECTION();
 
@@ -311,7 +319,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 		if (extended)
 		{
 			RecordPageWithFreeSpace(idxrel, newblk, freespace);
-			FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+			FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+									InvalidXLogRecPtr);
 		}
 
 		return true;
@@ -449,6 +458,8 @@ brin_doinsert(Relation idxrel, BlockNumber pagesPerRange,
 		PageSetLSN(page, recptr);
 		PageSetLSN(BufferGetPage(revmapbuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(page, BufferGetPage(revmapbuf));
 
 	END_CRIT_SECTION();
 
@@ -462,7 +473,8 @@ brin_doinsert(Relation idxrel, BlockNumber pagesPerRange,
 	if (extended)
 	{
 		RecordPageWithFreeSpace(idxrel, blk, freespace);
-		FreeSpaceMapVacuumRange(idxrel, blk, blk + 1);
+		FreeSpaceMapVacuumRange(idxrel, blk, blk + 1,
+								InvalidXLogRecPtr);
 	}
 
 	return off;
@@ -788,7 +800,8 @@ brin_getinsertbuffer(Relation irel, Buffer oldbuf, Size itemsz,
 
 				if (*extended)
 				{
-					FreeSpaceMapVacuumRange(irel, newblk, newblk + 1);
+					FreeSpaceMapVacuumRange(irel, newblk, newblk + 1,
+											InvalidXLogRecPtr);
 					/* shouldn't matter, but don't confuse caller */
 					*extended = false;
 				}
diff --git a/src/backend/access/brin/brin_revmap.c b/src/backend/access/brin/brin_revmap.c
index 1776184185..7a03eb389e 100644
--- a/src/backend/access/brin/brin_revmap.c
+++ b/src/backend/access/brin/brin_revmap.c
@@ -432,6 +432,8 @@ brinRevmapDesummarizeRange(Relation idxrel, BlockNumber heapBlk)
 		PageSetLSN(revmapPg, recptr);
 		PageSetLSN(regPg, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(revmapPg, regPg);
 
 	END_CRIT_SECTION();
 
@@ -654,6 +656,8 @@ revmap_physical_extend(BrinRevmap *revmap)
 		PageSetLSN(metapage, recptr);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(metapage, page);
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/gin/ginbtree.c b/src/backend/access/gin/ginbtree.c
index fde350eef1..5deb540f75 100644
--- a/src/backend/access/gin/ginbtree.c
+++ b/src/backend/access/gin/ginbtree.c
@@ -437,6 +437,14 @@ ginPlaceToPage(GinBtree btree, GinBtreeStack *stack,
 			if (BufferIsValid(childbuf))
 				PageSetLSN(childpage, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr recptr = get_lsn_for_encryption();
+
+			PageSetLSN(page, recptr);
+			if (BufferIsValid(childbuf))
+				PageSetLSN(childpage, recptr);
+		}
 
 		END_CRIT_SECTION();
 
@@ -624,6 +632,17 @@ ginPlaceToPage(GinBtree btree, GinBtreeStack *stack,
 			if (BufferIsValid(childbuf))
 				PageSetLSN(childpage, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			PageSetLSN(page, recptr);
+			PageSetLSN(BufferGetPage(rbuffer), recptr);
+			if (stack->parent == NULL)
+				PageSetLSN(BufferGetPage(lbuffer), recptr);
+			if (BufferIsValid(childbuf))
+				PageSetLSN(childpage, recptr);
+		}
 		END_CRIT_SECTION();
 
 		/*
diff --git a/src/backend/access/gin/gindatapage.c b/src/backend/access/gin/gindatapage.c
index 197aea3bd3..dcd4fb4306 100644
--- a/src/backend/access/gin/gindatapage.c
+++ b/src/backend/access/gin/gindatapage.c
@@ -855,6 +855,8 @@ ginVacuumPostingTreeLeaf(Relation indexrel, Buffer buffer, GinVacuumState *gvs)
 			recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_VACUUM_DATA_LEAF_PAGE);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 	}
@@ -1847,6 +1849,8 @@ createPostingTree(Relation index, ItemPointerData *items, uint32 nitems,
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_CREATE_PTREE);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	UnlockReleaseBuffer(buffer);
 
diff --git a/src/backend/access/gin/ginfast.c b/src/backend/access/gin/ginfast.c
index a7a49b36fd..270ddb5738 100644
--- a/src/backend/access/gin/ginfast.c
+++ b/src/backend/access/gin/ginfast.c
@@ -129,6 +129,8 @@ writeListPage(Relation index, Buffer buffer,
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_INSERT_LISTPAGE);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	/* get free space before releasing buffer */
 	freesize = PageGetExactFreeSpace(page);
@@ -434,6 +436,17 @@ ginHeapTupleFastInsert(GinState *ginstate, GinTupleCollector *collector)
 			PageSetLSN(page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(metapage, recptr);
+
+		if (buffer != InvalidBuffer)
+		{
+			PageSetLSN(page, recptr);
+		}
+	}
 
 	if (buffer != InvalidBuffer)
 		UnlockReleaseBuffer(buffer);
@@ -658,6 +671,18 @@ shiftList(Relation index, Buffer metabuffer, BlockNumber newHead,
 				PageSetLSN(page, recptr);
 			}
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			PageSetLSN(metapage, recptr);
+
+			for (i = 0; i < data.ndeleted; i++)
+			{
+				page = BufferGetPage(buffers[i]);
+				PageSetLSN(page, recptr);
+			}
+		}
 
 		for (i = 0; i < data.ndeleted; i++)
 			UnlockReleaseBuffer(buffers[i]);
diff --git a/src/backend/access/gin/gininsert.c b/src/backend/access/gin/gininsert.c
index 55eab14617..c9af84244d 100644
--- a/src/backend/access/gin/gininsert.c
+++ b/src/backend/access/gin/gininsert.c
@@ -415,6 +415,8 @@ ginbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 						  0, RelationGetNumberOfBlocks(index),
 						  true);
 	}
+	else if (data_encrypted)
+		newpage_range_set_lsn(index, 0, RelationGetNumberOfBlocks(index));
 
 	/*
 	 * Return statistics
diff --git a/src/backend/access/gin/ginutil.c b/src/backend/access/gin/ginutil.c
index cf9699ad18..8a445f2d36 100644
--- a/src/backend/access/gin/ginutil.c
+++ b/src/backend/access/gin/ginutil.c
@@ -709,6 +709,8 @@ ginUpdateStats(Relation index, const GinStatsData *stats, bool is_build)
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_UPDATE_META_PAGE);
 		PageSetLSN(metapage, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(metapage);
 
 	UnlockReleaseBuffer(metabuffer);
 
diff --git a/src/backend/access/gin/ginvacuum.c b/src/backend/access/gin/ginvacuum.c
index 10d814d4aa..08974aaa7d 100644
--- a/src/backend/access/gin/ginvacuum.c
+++ b/src/backend/access/gin/ginvacuum.c
@@ -97,7 +97,12 @@ xlogVacuumPage(Relation index, Buffer buffer)
 	Assert(GinPageIsLeaf(page));
 
 	if (!RelationNeedsWAL(index))
+	{
+		if (data_encrypted)
+			set_page_lsn_for_encryption(page);
+
 		return;
+	}
 
 	/*
 	 * Always create a full image, we don't track the changes on the page at
@@ -224,6 +229,8 @@ ginDeletePage(GinVacuumState *gvs, BlockNumber deleteBlkno, BlockNumber leftBlkn
 		PageSetLSN(parentPage, recptr);
 		PageSetLSN(BufferGetPage(lBuffer), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption3(page, parentPage, BufferGetPage(lBuffer));
 
 	ReleaseBuffer(pBuffer);
 	ReleaseBuffer(lBuffer);
diff --git a/src/backend/access/gist/gist.c b/src/backend/access/gist/gist.c
index 9a5a98a61e..9c8bc0060a 100644
--- a/src/backend/access/gist/gist.c
+++ b/src/backend/access/gist/gist.c
@@ -502,6 +502,8 @@ gistplacetopage(Relation rel, Size freespace, GISTSTATE *giststate,
 				recptr = gistXLogSplit(is_leaf,
 									   dist, oldrlink, oldnsn, leftchildbuf,
 									   markfollowright);
+			else if (data_encrypted)
+				recptr = get_lsn_for_encryption();
 			else
 				recptr = gistGetFakeLSN(rel);
 		}
@@ -580,6 +582,8 @@ gistplacetopage(Relation rel, Size freespace, GISTSTATE *giststate,
 										deloffs, ndeloffs, itup, ntup,
 										leftchildbuf);
 			}
+			else if (data_encrypted)
+				recptr = get_lsn_for_encryption();
 			else
 				recptr = gistGetFakeLSN(rel);
 		}
@@ -1702,6 +1706,8 @@ gistprunepage(Relation rel, Page page, Buffer buffer, Relation heapRel)
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 		else
 			PageSetLSN(page, gistGetFakeLSN(rel));
 
diff --git a/src/backend/access/gist/gistbuild.c b/src/backend/access/gist/gistbuild.c
index ecef0ff072..74dad2705c 100644
--- a/src/backend/access/gist/gistbuild.c
+++ b/src/backend/access/gist/gistbuild.c
@@ -224,6 +224,8 @@ gistbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 						  0, RelationGetNumberOfBlocks(index),
 						  true);
 	}
+	else if (data_encrypted)
+		newpage_range_set_lsn(index, 0, RelationGetNumberOfBlocks(index));
 
 	/*
 	 * Return statistics
diff --git a/src/backend/access/gist/gistvacuum.c b/src/backend/access/gist/gistvacuum.c
index 710e4015b3..369a58d049 100644
--- a/src/backend/access/gist/gistvacuum.c
+++ b/src/backend/access/gist/gistvacuum.c
@@ -199,6 +199,8 @@ gistvacuumscan(IndexVacuumInfo *info, GistBulkDeleteResult *stats,
 	vstate.callback_state = callback_state;
 	if (RelationNeedsWAL(rel))
 		vstate.startNSN = GetInsertRecPtr();
+	else if (data_encrypted)
+		vstate.startNSN = get_lsn_for_encryption();
 	else
 		vstate.startNSN = gistGetFakeLSN(rel);
 
@@ -383,6 +385,8 @@ restart:
 										NULL, 0, InvalidBuffer);
 				PageSetLSN(page, recptr);
 			}
+			else if (data_encrypted)
+				PageSetLSN(page, get_lsn_for_encryption());
 			else
 				PageSetLSN(page, gistGetFakeLSN(rel));
 
@@ -673,6 +677,8 @@ gistdeletepage(IndexVacuumInfo *info, GistBulkDeleteResult *stats,
 
 	if (RelationNeedsWAL(info->index))
 		recptr = gistXLogPageDelete(leafBuffer, txid, parentBuffer, downlink);
+	else if (data_encrypted)
+		recptr = get_lsn_for_encryption();
 	else
 		recptr = gistGetFakeLSN(info->index);
 	PageSetLSN(parentPage, recptr);
diff --git a/src/backend/access/hash/hash.c b/src/backend/access/hash/hash.c
index 5cc30dac42..31a5554283 100644
--- a/src/backend/access/hash/hash.c
+++ b/src/backend/access/hash/hash.c
@@ -616,6 +616,8 @@ loop_top:
 		recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_UPDATE_META_PAGE);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(metabuf));
 
 	END_CRIT_SECTION();
 
@@ -832,6 +834,8 @@ hashbucketcleanup(Relation rel, Bucket cur_bucket, Buffer bucket_buf,
 				recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_DELETE);
 				PageSetLSN(BufferGetPage(buf), recptr);
 			}
+			else if (data_encrypted)
+				set_page_lsn_for_encryption(BufferGetPage(buf));
 
 			END_CRIT_SECTION();
 		}
@@ -898,6 +902,8 @@ hashbucketcleanup(Relation rel, Bucket cur_bucket, Buffer bucket_buf,
 			recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_SPLIT_CLEANUP);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 	}
diff --git a/src/backend/access/hash/hashinsert.c b/src/backend/access/hash/hashinsert.c
index 5321762d5e..0f2fcd6259 100644
--- a/src/backend/access/hash/hashinsert.c
+++ b/src/backend/access/hash/hashinsert.c
@@ -231,6 +231,9 @@ restart_insert:
 		PageSetLSN(BufferGetPage(buf), recptr);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(buf),
+									 BufferGetPage(metabuf));
 
 	END_CRIT_SECTION();
 
@@ -420,6 +423,9 @@ _hash_vacuum_one_page(Relation rel, Relation hrel, Buffer metabuf, Buffer buf)
 			PageSetLSN(BufferGetPage(buf), recptr);
 			PageSetLSN(BufferGetPage(metabuf), recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption2(BufferGetPage(buf),
+										 BufferGetPage(metabuf));
 
 		END_CRIT_SECTION();
 
diff --git a/src/backend/access/hash/hashovfl.c b/src/backend/access/hash/hashovfl.c
index a07bd27a0e..20ca71c5fa 100644
--- a/src/backend/access/hash/hashovfl.c
+++ b/src/backend/access/hash/hashovfl.c
@@ -419,6 +419,21 @@ found:
 
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(BufferGetPage(ovflbuf), recptr);
+		PageSetLSN(BufferGetPage(buf), recptr);
+
+		if (BufferIsValid(mapbuf))
+			PageSetLSN(BufferGetPage(mapbuf), recptr);
+
+		if (BufferIsValid(newmapbuf))
+			PageSetLSN(BufferGetPage(newmapbuf), recptr);
+
+		PageSetLSN(BufferGetPage(metabuf), recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -710,6 +725,23 @@ _hash_freeovflpage(Relation rel, Buffer bucketbuf, Buffer ovflbuf,
 		if (update_metap)
 			PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(BufferGetPage(wbuf), recptr);
+		PageSetLSN(BufferGetPage(ovflbuf), recptr);
+
+		if (BufferIsValid(prevbuf) && !(wbuf == prevbuf))
+			PageSetLSN(BufferGetPage(prevbuf), recptr);
+		if (BufferIsValid(nextbuf))
+			PageSetLSN(BufferGetPage(nextbuf), recptr);
+
+		PageSetLSN(BufferGetPage(mapbuf), recptr);
+
+		if (update_metap)
+			PageSetLSN(BufferGetPage(metabuf), recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -980,6 +1012,9 @@ readpage:
 						PageSetLSN(BufferGetPage(wbuf), recptr);
 						PageSetLSN(BufferGetPage(rbuf), recptr);
 					}
+					else if (data_encrypted)
+						set_page_lsn_for_encryption2(BufferGetPage(wbuf),
+													 BufferGetPage(rbuf));
 
 					END_CRIT_SECTION();
 
diff --git a/src/backend/access/hash/hashpage.c b/src/backend/access/hash/hashpage.c
index 376ee2a63b..ca586ec3d5 100644
--- a/src/backend/access/hash/hashpage.c
+++ b/src/backend/access/hash/hashpage.c
@@ -3,6 +3,7 @@
  * hashpage.c
  *	  Hash table page management code for the Postgres hash access method
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -400,6 +401,8 @@ _hash_init(Relation rel, double num_tuples, ForkNumber forkNum)
 
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(metabuf));
 
 	num_buckets = metap->hashm_maxbucket + 1;
 
@@ -432,6 +435,9 @@ _hash_init(Relation rel, double num_tuples, ForkNumber forkNum)
 						blkno,
 						BufferGetPage(buf),
 						true);
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(BufferGetPage(buf));
+
 		_hash_relbuf(rel, buf);
 	}
 
@@ -936,6 +942,10 @@ restart_expand:
 		PageSetLSN(BufferGetPage(buf_nblkno), recptr);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption3(BufferGetPage(buf_oblkno),
+									 BufferGetPage(buf_nblkno),
+									 BufferGetPage(metabuf));
 
 	END_CRIT_SECTION();
 
@@ -993,6 +1003,7 @@ _hash_alloc_buckets(Relation rel, BlockNumber firstblock, uint32 nblocks)
 	PGAlignedBlock zerobuf;
 	Page		page;
 	HashPageOpaque ovflopaque;
+	XLogRecPtr	lsn;
 
 	lastblock = firstblock + nblocks - 1;
 
@@ -1021,15 +1032,36 @@ _hash_alloc_buckets(Relation rel, BlockNumber firstblock, uint32 nblocks)
 	ovflopaque->hasho_page_id = HASHO_PAGE_ID;
 
 	if (RelationNeedsWAL(rel))
+	{
 		log_newpage(&rel->rd_node,
 					MAIN_FORKNUM,
 					lastblock,
 					zerobuf.data,
 					true);
+		lsn = PageGetLSN(zerobuf.data);
+	}
+	else if (data_encrypted)
+		lsn = get_lsn_for_encryption();
+
+	/*
+	 * Encrypt only if we have valid IV. It should be always except when
+	 * log_newpage() encountered an empty page - it should be safe not to
+	 * encrypt such one.
+	 */
+	if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+	{
+		encrypt_page(zerobuf.data,
+					 encrypt_buf.data,
+					 lsn,
+					 lastblock,
+					 rel->rd_rel->relpersistence);
+
+		page = encrypt_buf.data;
+	}
 
 	RelationOpenSmgr(rel);
 	PageSetChecksumInplace(page, lastblock);
-	smgrextend(rel->rd_smgr, MAIN_FORKNUM, lastblock, zerobuf.data, false);
+	smgrextend(rel->rd_smgr, MAIN_FORKNUM, lastblock, page, false);
 
 	return true;
 }
@@ -1312,6 +1344,9 @@ _hash_splitbucket(Relation rel,
 		PageSetLSN(BufferGetPage(bucket_obuf), recptr);
 		PageSetLSN(BufferGetPage(bucket_nbuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(bucket_obuf),
+									 BufferGetPage(bucket_nbuf));
 
 	END_CRIT_SECTION();
 
@@ -1484,6 +1519,8 @@ log_split_page(Relation rel, Buffer buf)
 
 		PageSetLSN(BufferGetPage(buf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(buf));
 }
 
 /*
diff --git a/src/backend/access/heap/heapam.c b/src/backend/access/heap/heapam.c
index dc90660fe3..aa0303241e 100644
--- a/src/backend/access/heap/heapam.c
+++ b/src/backend/access/heap/heapam.c
@@ -2054,6 +2054,12 @@ heap_insert(Relation relation, HeapTuple tup, CommandId cid,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+	{
+		Page		page = BufferGetPage(buffer);
+
+		set_page_lsn_for_encryption(page);
+	}
 
 	END_CRIT_SECTION();
 
@@ -2370,6 +2376,8 @@ heap_multi_insert(Relation relation, TupleTableSlot **slots, int ntuples,
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 
@@ -2840,6 +2848,8 @@ l1:
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -3554,6 +3564,8 @@ l2:
 			recptr = XLogInsert(RM_HEAP_ID, XLOG_HEAP_LOCK);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 
@@ -3788,6 +3800,14 @@ l2:
 		}
 		PageSetLSN(BufferGetPage(buffer), recptr);
 	}
+	else if (data_encrypted)
+	{
+		if (newbuf != buffer)
+			set_page_lsn_for_encryption2(BufferGetPage(newbuf),
+										 BufferGetPage(buffer));
+		else
+			set_page_lsn_for_encryption(BufferGetPage(buffer));
+	}
 
 	END_CRIT_SECTION();
 
@@ -4747,6 +4767,8 @@ failed:
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -5499,6 +5521,12 @@ l4:
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			Page		page = BufferGetPage(buf);
+
+			set_page_lsn_for_encryption(page);
+		}
 
 		END_CRIT_SECTION();
 
@@ -5657,6 +5685,8 @@ heap_finish_speculative(Relation relation, ItemPointer tid)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -5800,6 +5830,8 @@ heap_abort_speculative(Relation relation, ItemPointer tid)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -5907,6 +5939,8 @@ heap_inplace_update(Relation relation, HeapTuple tuple)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -7948,7 +7982,7 @@ heap_xlog_clean(XLogReaderState *record)
 		 * Do this regardless of a full-page image being applied, since the
 		 * FSM data is not in the page anyway.
 		 */
-		XLogRecordPageWithFreeSpace(rnode, blkno, freespace);
+		XLogRecordPageWithFreeSpace(rnode, blkno, freespace, lsn);
 	}
 }
 
@@ -8047,7 +8081,7 @@ heap_xlog_visible(XLogReaderState *record)
 		 * FSM data is not in the page anyway.
 		 */
 		if (xlrec->flags & VISIBILITYMAP_VALID_BITS)
-			XLogRecordPageWithFreeSpace(rnode, blkno, space);
+			XLogRecordPageWithFreeSpace(rnode, blkno, space, lsn);
 	}
 
 	/*
@@ -8362,7 +8396,7 @@ heap_xlog_insert(XLogReaderState *record)
 	 * totally accurate anyway.
 	 */
 	if (action == BLK_NEEDS_REDO && freespace < BLCKSZ / 5)
-		XLogRecordPageWithFreeSpace(target_node, blkno, freespace);
+		XLogRecordPageWithFreeSpace(target_node, blkno, freespace, lsn);
 }
 
 /*
@@ -8501,7 +8535,7 @@ heap_xlog_multi_insert(XLogReaderState *record)
 	 * totally accurate anyway.
 	 */
 	if (action == BLK_NEEDS_REDO && freespace < BLCKSZ / 5)
-		XLogRecordPageWithFreeSpace(rnode, blkno, freespace);
+		XLogRecordPageWithFreeSpace(rnode, blkno, freespace, lsn);
 }
 
 /*
@@ -8776,7 +8810,7 @@ heap_xlog_update(XLogReaderState *record, bool hot_update)
 	 * totally accurate anyway.
 	 */
 	if (newaction == BLK_NEEDS_REDO && !hot_update && freespace < BLCKSZ / 5)
-		XLogRecordPageWithFreeSpace(rnode, newblk, freespace);
+		XLogRecordPageWithFreeSpace(rnode, newblk, freespace, lsn);
 }
 
 static void
diff --git a/src/backend/access/heap/hio.c b/src/backend/access/heap/hio.c
index a383137508..00c3c82bdc 100644
--- a/src/backend/access/heap/hio.c
+++ b/src/backend/access/heap/hio.c
@@ -257,7 +257,8 @@ RelationAddExtraBlocks(Relation relation, BulkInsertState bistate)
 	 * subsequent insertion activity sees all of those nifty free pages we
 	 * just inserted.
 	 */
-	FreeSpaceMapVacuumRange(relation, firstBlock, blockNum + 1);
+	FreeSpaceMapVacuumRange(relation, firstBlock, blockNum + 1,
+							InvalidXLogRecPtr);
 }
 
 /*
diff --git a/src/backend/access/heap/pruneheap.c b/src/backend/access/heap/pruneheap.c
index 349b82d609..3bd717cc74 100644
--- a/src/backend/access/heap/pruneheap.c
+++ b/src/backend/access/heap/pruneheap.c
@@ -270,6 +270,8 @@ heap_page_prune(Relation relation, Buffer buffer, TransactionId OldestXmin,
 
 			PageSetLSN(BufferGetPage(buffer), recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(BufferGetPage(buffer));
 	}
 	else
 	{
diff --git a/src/backend/access/heap/rewriteheap.c b/src/backend/access/heap/rewriteheap.c
index 489c72582d..63a5f4a2f6 100644
--- a/src/backend/access/heap/rewriteheap.c
+++ b/src/backend/access/heap/rewriteheap.c
@@ -92,6 +92,7 @@
  * heap's TOAST table will go through the normal bufmgr.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994-5, Regents of the University of California
  *
@@ -330,18 +331,42 @@ end_heap_rewrite(RewriteState state)
 	/* Write the last page, if any */
 	if (state->rs_buffer_valid)
 	{
+		char	*buf = (char *) state->rs_buffer;
+		XLogRecPtr	lsn;
+
 		if (state->rs_use_wal)
+		{
 			log_newpage(&state->rs_new_rel->rd_node,
 						MAIN_FORKNUM,
 						state->rs_blockno,
-						state->rs_buffer,
+						buf,
 						true);
-		RelationOpenSmgr(state->rs_new_rel);
+			lsn = PageGetLSN(buf);
+		}
+		else if (data_encrypted)
+			lsn = get_lsn_for_encryption();
+
+		/*
+		 * Encrypt only if we have valid IV. It should be always except when
+		 * log_newpage() encountered an empty page - it should be safe not to
+		 * encrypt such one.
+		 */
+		if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+		{
+			encrypt_page(buf,
+						 encrypt_buf.data,
+						 lsn,
+						 state->rs_blockno,
+						 state->rs_new_rel->rd_rel->relpersistence);
+
+			buf = encrypt_buf.data;
+		}
 
-		PageSetChecksumInplace(state->rs_buffer, state->rs_blockno);
+		RelationOpenSmgr(state->rs_new_rel);
 
+		PageSetChecksumInplace(buf, state->rs_blockno);
 		smgrextend(state->rs_new_rel->rd_smgr, MAIN_FORKNUM, state->rs_blockno,
-				   (char *) state->rs_buffer, true);
+				   buf, true);
 	}
 
 	/*
@@ -692,15 +717,23 @@ raw_heap_insert(RewriteState state, HeapTuple tup)
 
 		if (len + saveFreeSpace > pageFreeSpace)
 		{
+			char	*buf = (char *) page;
+			XLogRecPtr	lsn = InvalidXLogRecPtr;
+
 			/* Doesn't fit, so write out the existing page */
 
 			/* XLOG stuff */
 			if (state->rs_use_wal)
+			{
 				log_newpage(&state->rs_new_rel->rd_node,
 							MAIN_FORKNUM,
 							state->rs_blockno,
-							page,
+							buf,
 							true);
+				lsn = PageGetLSN(buf);
+			}
+			else if (data_encrypted)
+				lsn = get_lsn_for_encryption();
 
 			/*
 			 * Now write the page. We say isTemp = true even if it's not a
@@ -710,10 +743,25 @@ raw_heap_insert(RewriteState state, HeapTuple tup)
 			 */
 			RelationOpenSmgr(state->rs_new_rel);
 
-			PageSetChecksumInplace(page, state->rs_blockno);
+			/*
+			 * Encrypt only if we have valid IV. It should be always except
+			 * when log_newpage() encountered an empty page - it should be
+			 * safe not to encrypt such one.
+			 */
+			if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+			{
+				encrypt_page(buf,
+							 encrypt_buf.data,
+							 lsn,
+							 state->rs_blockno,
+							 state->rs_new_rel->rd_rel->relpersistence);
+
+				buf = encrypt_buf.data;
+			}
 
+			PageSetChecksumInplace(buf, state->rs_blockno);
 			smgrextend(state->rs_new_rel->rd_smgr, MAIN_FORKNUM,
-					   state->rs_blockno, (char *) page, true);
+					   state->rs_blockno, buf, true);
 
 			state->rs_blockno++;
 			state->rs_buffer_valid = false;
@@ -934,7 +982,7 @@ logical_heap_rewrite_flush_mappings(RewriteState state)
 		 * check the above "Logical rewrite support" comment for reasoning.
 		 */
 		written = FileWrite(src->vfd, waldata_start, len, src->off,
-							WAIT_EVENT_LOGICAL_REWRITE_WRITE);
+							WAIT_EVENT_LOGICAL_REWRITE_WRITE, ERROR);
 		if (written != len)
 			ereport(ERROR,
 					(errcode_for_file_access(),
diff --git a/src/backend/access/heap/vacuumlazy.c b/src/backend/access/heap/vacuumlazy.c
index 3d4719d53a..5053aa3732 100644
--- a/src/backend/access/heap/vacuumlazy.c
+++ b/src/backend/access/heap/vacuumlazy.c
@@ -780,7 +780,8 @@ lazy_scan_heap(Relation onerel, VacuumParams *params, LVRelStats *vacrelstats,
 			 * Vacuum the Free Space Map to make newly-freed space visible on
 			 * upper-level FSM pages.  Note we have not yet processed blkno.
 			 */
-			FreeSpaceMapVacuumRange(onerel, next_fsm_block_to_vacuum, blkno);
+			FreeSpaceMapVacuumRange(onerel, next_fsm_block_to_vacuum, blkno,
+									InvalidXLogRecPtr);
 			next_fsm_block_to_vacuum = blkno;
 
 			/* Report that we are once again scanning the heap */
@@ -940,6 +941,9 @@ lazy_scan_heap(Relation onerel, VacuumParams *params, LVRelStats *vacrelstats,
 				if (RelationNeedsWAL(onerel) &&
 					PageGetLSN(page) == InvalidXLogRecPtr)
 					log_newpage_buffer(buf, true);
+				else if (data_encrypted &&
+						 PageGetLSN(page) == InvalidXLogRecPtr)
+					set_page_lsn_for_encryption(page);
 
 				PageSetAllVisible(page);
 				visibilitymap_set(onerel, blkno, buf, InvalidXLogRecPtr,
@@ -1215,6 +1219,8 @@ lazy_scan_heap(Relation onerel, VacuumParams *params, LVRelStats *vacrelstats,
 										 frozen, nfrozen);
 				PageSetLSN(page, recptr);
 			}
+			else if (data_encrypted)
+				set_page_lsn_for_encryption(page);
 
 			END_CRIT_SECTION();
 		}
@@ -1264,7 +1270,7 @@ lazy_scan_heap(Relation onerel, VacuumParams *params, LVRelStats *vacrelstats,
 			if (blkno - next_fsm_block_to_vacuum >= VACUUM_FSM_EVERY_PAGES)
 			{
 				FreeSpaceMapVacuumRange(onerel, next_fsm_block_to_vacuum,
-										blkno);
+										blkno, InvalidXLogRecPtr);
 				next_fsm_block_to_vacuum = blkno;
 			}
 		}
@@ -1440,7 +1446,8 @@ lazy_scan_heap(Relation onerel, VacuumParams *params, LVRelStats *vacrelstats,
 	 * not there were indexes.
 	 */
 	if (blkno > next_fsm_block_to_vacuum)
-		FreeSpaceMapVacuumRange(onerel, next_fsm_block_to_vacuum, blkno);
+		FreeSpaceMapVacuumRange(onerel, next_fsm_block_to_vacuum, blkno,
+								InvalidXLogRecPtr);
 
 	/* report all blocks vacuumed; and that we're cleaning up */
 	pgstat_progress_update_param(PROGRESS_VACUUM_HEAP_BLKS_VACUUMED, blkno);
@@ -1618,6 +1625,8 @@ lazy_vacuum_page(Relation onerel, BlockNumber blkno, Buffer buffer,
 								vacrelstats->latestRemovedXid);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	/*
 	 * End critical section, so we safely can do visibility tests (which
diff --git a/src/backend/access/heap/visibilitymap.c b/src/backend/access/heap/visibilitymap.c
index 64dfe06b26..2f24a70f03 100644
--- a/src/backend/access/heap/visibilitymap.c
+++ b/src/backend/access/heap/visibilitymap.c
@@ -3,6 +3,7 @@
  * visibilitymap.c
  *	  bitmap for tracking visibility of heap tuples
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -299,6 +300,19 @@ visibilitymap_set(Relation rel, BlockNumber heapBlk, Buffer heapBuf,
 			}
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			if (XLogRecPtrIsInvalid(recptr))
+				set_page_lsn_for_encryption(page);
+			else
+			{
+				/*
+				 * The LSN must be set even during recovery because it's used
+				 * as the encryption IV.
+				 */
+				PageSetLSN(page, recptr);
+			}
+		}
 
 		END_CRIT_SECTION();
 	}
@@ -437,9 +451,13 @@ visibilitymap_count(Relation rel, BlockNumber *all_visible, BlockNumber *all_fro
  * before they access the VM again.
  *
  * nheapblocks is the new size of the heap.
+ *
+ * Valid recptr is passed iff called during WAL replay, see
+ * visibilitymap_set() for details.
  */
 void
-visibilitymap_truncate(Relation rel, BlockNumber nheapblocks)
+visibilitymap_truncate(Relation rel, BlockNumber nheapblocks,
+					   XLogRecPtr recptr)
 {
 	BlockNumber newnblocks;
 
@@ -452,6 +470,8 @@ visibilitymap_truncate(Relation rel, BlockNumber nheapblocks)
 	elog(DEBUG1, "vm_truncate %s %d", RelationGetRelationName(rel), nheapblocks);
 #endif
 
+	Assert(InRecovery || XLogRecPtrIsInvalid(recptr));
+
 	RelationOpenSmgr(rel);
 
 	/*
@@ -517,6 +537,19 @@ visibilitymap_truncate(Relation rel, BlockNumber nheapblocks)
 		MarkBufferDirty(mapBuffer);
 		if (!InRecovery && RelationNeedsWAL(rel) && XLogHintBitIsNeeded())
 			log_newpage_buffer(mapBuffer, false);
+		else if (data_encrypted)
+		{
+			if (XLogRecPtrIsInvalid(recptr))
+				set_page_lsn_for_encryption(BufferGetPage(mapBuffer));
+			else
+			{
+				/*
+				 * The LSN must be set even during recovery because it's
+				 * used as the encryption IV.
+				 */
+				PageSetLSN(BufferGetPage(mapBuffer), recptr);
+			}
+		}
 
 		END_CRIT_SECTION();
 
@@ -658,8 +691,13 @@ vm_extend(Relation rel, BlockNumber vm_nblocks)
 	/* Now extend the file */
 	while (vm_nblocks_now < vm_nblocks)
 	{
-		PageSetChecksumInplace((Page) pg.data, vm_nblocks_now);
+		/*
+		 * Encryption: invalid LSN means that the page should not be
+		 * encrypted. This is o.k. as the page is still empty.
+		 */
+		Assert(XLogRecPtrIsInvalid(PageGetLSN(pg.data)));
 
+		PageSetChecksumInplace((Page) pg.data, vm_nblocks_now);
 		smgrextend(rel->rd_smgr, VISIBILITYMAP_FORKNUM, vm_nblocks_now,
 				   pg.data, false);
 		vm_nblocks_now++;
diff --git a/src/backend/access/nbtree/nbtinsert.c b/src/backend/access/nbtree/nbtinsert.c
index 602f8849d4..8377b7db57 100644
--- a/src/backend/access/nbtree/nbtinsert.c
+++ b/src/backend/access/nbtree/nbtinsert.c
@@ -1167,6 +1167,16 @@ _bt_insertonpg(Relation rel,
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			if (BufferIsValid(metabuf))
+				PageSetLSN(metapg, recptr);
+			if (BufferIsValid(cbuf))
+				PageSetLSN(BufferGetPage(cbuf), recptr);
+			PageSetLSN(page, recptr);
+		}
 
 		END_CRIT_SECTION();
 
@@ -1707,6 +1717,17 @@ _bt_split(Relation rel, BTScanInsert itup_key, Buffer buf, Buffer cbuf,
 			PageSetLSN(BufferGetPage(cbuf), recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(origpage, recptr);
+		PageSetLSN(rightpage, recptr);
+		if (!P_RIGHTMOST(ropaque))
+			PageSetLSN(spage, recptr);
+		if (!isleaf)
+			PageSetLSN(BufferGetPage(cbuf), recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -2187,6 +2208,14 @@ _bt_newroot(Relation rel, Buffer lbuf, Buffer rbuf)
 		PageSetLSN(rootpage, recptr);
 		PageSetLSN(metapg, recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(lpage, recptr);
+		PageSetLSN(rootpage, recptr);
+		PageSetLSN(metapg, recptr);
+	}
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/nbtree/nbtpage.c b/src/backend/access/nbtree/nbtpage.c
index a4f2ae09d9..b38c79c2d2 100644
--- a/src/backend/access/nbtree/nbtpage.c
+++ b/src/backend/access/nbtree/nbtpage.c
@@ -224,6 +224,8 @@ _bt_update_meta_cleanup_info(Relation rel, TransactionId oldestBtpoXact,
 
 		PageSetLSN(metapg, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(metapg);
 
 	END_CRIT_SECTION();
 	_bt_relbuf(rel, metabuf);
@@ -413,6 +415,8 @@ _bt_getroot(Relation rel, int access)
 			PageSetLSN(rootpage, recptr);
 			PageSetLSN(metapg, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption2(rootpage, metapg);
 
 		END_CRIT_SECTION();
 
@@ -1043,6 +1047,8 @@ _bt_delitems_vacuum(Relation rel, Buffer buf,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
@@ -1123,6 +1129,8 @@ _bt_delitems_delete(Relation rel, Buffer buf,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
@@ -1772,6 +1780,9 @@ _bt_mark_page_halfdead(Relation rel, Buffer leafbuf, BTStack stack)
 		page = BufferGetPage(leafbuf);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(topparent),
+									 BufferGetPage(leafbuf));
 
 	END_CRIT_SECTION();
 
@@ -2179,6 +2190,27 @@ _bt_unlink_halfdead_page(Relation rel, Buffer leafbuf, BlockNumber scanblkno,
 			PageSetLSN(page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		if (BufferIsValid(metabuf))
+			PageSetLSN(metapg, recptr);
+		page = BufferGetPage(rbuf);
+		PageSetLSN(page, recptr);
+		page = BufferGetPage(buf);
+		PageSetLSN(page, recptr);
+		if (BufferIsValid(lbuf))
+		{
+			page = BufferGetPage(lbuf);
+			PageSetLSN(page, recptr);
+		}
+		if (target != leafblkno)
+		{
+			page = BufferGetPage(leafbuf);
+			PageSetLSN(page, recptr);
+		}
+	}
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/nbtree/nbtree.c b/src/backend/access/nbtree/nbtree.c
index 01684685ea..318459013e 100644
--- a/src/backend/access/nbtree/nbtree.c
+++ b/src/backend/access/nbtree/nbtree.c
@@ -8,6 +8,7 @@
  *	  This file contains only the public interface routines.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -170,6 +171,7 @@ btbuildempty(Relation index)
 	 * this even when wal_level=minimal.
 	 */
 	PageSetChecksumInplace(metapage, BTREE_METAPAGE);
+	/* Encryption: no-op, the page has no LSN (i.e. IV) yet. */
 	smgrwrite(index->rd_smgr, INIT_FORKNUM, BTREE_METAPAGE,
 			  (char *) metapage, true);
 	log_newpage(&index->rd_smgr->smgr_rnode.node, INIT_FORKNUM,
diff --git a/src/backend/access/nbtree/nbtsort.c b/src/backend/access/nbtree/nbtsort.c
index d177b9f233..b3019daeff 100644
--- a/src/backend/access/nbtree/nbtsort.c
+++ b/src/backend/access/nbtree/nbtsort.c
@@ -46,6 +46,7 @@
  * This code isn't concerned about the FSM at all. The caller is responsible
  * for initializing that.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -655,6 +656,9 @@ _bt_blnewpage(uint32 level)
 static void
 _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 {
+	char	*buf;
+	XLogRecPtr	lsn = InvalidXLogRecPtr;
+
 	/* Ensure rd_smgr is open (could have been closed by relcache flush!) */
 	RelationOpenSmgr(wstate->index);
 
@@ -663,7 +667,10 @@ _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 	{
 		/* We use the heap NEWPAGE record type for this */
 		log_newpage(&wstate->index->rd_node, MAIN_FORKNUM, blkno, page, true);
+		lsn = PageGetLSN(page);
 	}
+	else if (data_encrypted)
+		lsn = get_lsn_for_encryption();
 
 	/*
 	 * If we have to write pages nonsequentially, fill in the space with
@@ -676,14 +683,37 @@ _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 	{
 		if (!wstate->btws_zeropage)
 			wstate->btws_zeropage = (Page) palloc0(BLCKSZ);
+
 		/* don't set checksum for all-zero page */
+		/*
+		 * Encryption: no need to enforce LSN, all-zero page won't be
+		 * encrypted anyway.
+		 */
 		smgrextend(wstate->index->rd_smgr, MAIN_FORKNUM,
 				   wstate->btws_pages_written++,
 				   (char *) wstate->btws_zeropage,
 				   true);
 	}
 
-	PageSetChecksumInplace(page, blkno);
+	buf = (char *) page;
+
+	/*
+	 * Encrypt only if we have valid IV. It should be always except when
+	 * log_newpage() encountered an empty page - it should be safe not to
+	 * encrypt such one.
+	 */
+	if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+	{
+		encrypt_page(buf,
+					 encrypt_buf.data,
+					 lsn,
+					 blkno,
+					 wstate->index->rd_rel->relpersistence);
+
+		buf = encrypt_buf.data;
+	}
+
+	PageSetChecksumInplace(buf, blkno);
 
 	/*
 	 * Now write the page.  There's no need for smgr to schedule an fsync for
@@ -692,15 +722,13 @@ _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 	if (blkno == wstate->btws_pages_written)
 	{
 		/* extending the file... */
-		smgrextend(wstate->index->rd_smgr, MAIN_FORKNUM, blkno,
-				   (char *) page, true);
+		smgrextend(wstate->index->rd_smgr, MAIN_FORKNUM, blkno, buf, true);
 		wstate->btws_pages_written++;
 	}
 	else
 	{
 		/* overwriting a block we zero-filled before */
-		smgrwrite(wstate->index->rd_smgr, MAIN_FORKNUM, blkno,
-				  (char *) page, true);
+		smgrwrite(wstate->index->rd_smgr, MAIN_FORKNUM, blkno, buf, true);
 	}
 
 	pfree(page);
diff --git a/src/backend/access/spgist/spgdoinsert.c b/src/backend/access/spgist/spgdoinsert.c
index 6440dc6a7d..c2edde1c55 100644
--- a/src/backend/access/spgist/spgdoinsert.c
+++ b/src/backend/access/spgist/spgdoinsert.c
@@ -315,6 +315,15 @@ addLeafTuple(Relation index, SpGistState *state, SpGistLeafTuple leafTuple,
 			PageSetLSN(parent->page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(current->page, recptr);
+
+		if (xlrec.offnumParent != InvalidOffsetNumber)
+			PageSetLSN(parent->page, recptr);
+	}
 
 	END_CRIT_SECTION();
 }
@@ -548,6 +557,14 @@ moveLeafs(Relation index, SpGistState *state,
 		PageSetLSN(npage, recptr);
 		PageSetLSN(parent->page, recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(current->page, recptr);
+		PageSetLSN(npage, recptr);
+		PageSetLSN(parent->page, recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -1412,6 +1429,31 @@ doPickSplit(Relation index, SpGistState *state,
 			PageSetLSN(parent->page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		if (newLeafBuffer != InvalidBuffer)
+		{
+			Page		page = BufferGetPage(newLeafBuffer);
+
+			PageSetLSN(page, recptr);
+		}
+
+		if (saveCurrent.buffer != InvalidBuffer)
+		{
+			Page		page = BufferGetPage(saveCurrent.buffer);
+
+			PageSetLSN(page, recptr);
+		}
+
+		PageSetLSN(current->page, recptr);
+
+		if (parent->buffer != InvalidBuffer)
+		{
+			PageSetLSN(parent->page, recptr);
+		}
+	}
 
 	END_CRIT_SECTION();
 
@@ -1546,6 +1588,8 @@ spgAddNodeAction(Relation index, SpGistState *state,
 
 			PageSetLSN(current->page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(current->page);
 
 		END_CRIT_SECTION();
 	}
@@ -1673,6 +1717,14 @@ spgAddNodeAction(Relation index, SpGistState *state,
 			PageSetLSN(parent->page, recptr);
 			PageSetLSN(saveCurrent.page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			PageSetLSN(current->page, recptr);
+			PageSetLSN(parent->page, recptr);
+			PageSetLSN(saveCurrent.page, recptr);
+		}
 
 		END_CRIT_SECTION();
 
@@ -1870,6 +1922,15 @@ spgSplitNodeAction(Relation index, SpGistState *state,
 			PageSetLSN(BufferGetPage(newBuffer), recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(current->page, recptr);
+
+		if (newBuffer != InvalidBuffer)
+			PageSetLSN(BufferGetPage(newBuffer), recptr);
+	}
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/spgist/spginsert.c b/src/backend/access/spgist/spginsert.c
index b40bd440cf..f27c4631a9 100644
--- a/src/backend/access/spgist/spginsert.c
+++ b/src/backend/access/spgist/spginsert.c
@@ -5,6 +5,7 @@
  *
  * All the actual insertion logic is in spgdoinsert.c.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -141,6 +142,8 @@ spgbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 						  0, RelationGetNumberOfBlocks(index),
 						  true);
 	}
+	else if (data_encrypted)
+		newpage_range_set_lsn(index, 0, RelationGetNumberOfBlocks(index));
 
 	result = (IndexBuildResult *) palloc0(sizeof(IndexBuildResult));
 	result->heap_tuples = reltuples;
@@ -169,6 +172,14 @@ spgbuildempty(Relation index)
 	 * replayed.
 	 */
 	PageSetChecksumInplace(page, SPGIST_METAPAGE_BLKNO);
+	/*
+	 * On encryption: LSN is used as the encryption IV, but all the three
+	 * pages created here have initially invalid LSN. Since no user data will
+	 * be written so far, it doesn't seem worth the complexity to generate
+	 * either regular or fake LSN (depending on relperistence) and to encrypt
+	 * the pages before they are logged. Let's just leave them unencrypted
+	 * until any data is added to the index.
+	 */
 	smgrwrite(index->rd_smgr, INIT_FORKNUM, SPGIST_METAPAGE_BLKNO,
 			  (char *) page, true);
 	log_newpage(&index->rd_smgr->smgr_rnode.node, INIT_FORKNUM,
diff --git a/src/backend/access/spgist/spgvacuum.c b/src/backend/access/spgist/spgvacuum.c
index 2b1662a267..ae76eb4bd4 100644
--- a/src/backend/access/spgist/spgvacuum.c
+++ b/src/backend/access/spgist/spgvacuum.c
@@ -394,6 +394,8 @@ vacuumLeafPage(spgBulkDeleteState *bds, Relation index, Buffer buffer,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
@@ -475,6 +477,8 @@ vacuumLeafRoot(spgBulkDeleteState *bds, Relation index, Buffer buffer)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
@@ -596,6 +600,8 @@ vacuumRedirectAndPlaceholder(Relation index, Buffer buffer)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
diff --git a/src/backend/access/transam/generic_xlog.c b/src/backend/access/transam/generic_xlog.c
index d259160103..2fb695180a 100644
--- a/src/backend/access/transam/generic_xlog.c
+++ b/src/backend/access/transam/generic_xlog.c
@@ -419,10 +419,15 @@ GenericXLogFinish(GenericXLogState *state)
 
 			if (BufferIsInvalid(pageData->buffer))
 				continue;
+
+			/* We don't worry about zeroing the "hole" in this case */
 			memcpy(BufferGetPage(pageData->buffer),
 				   pageData->image,
 				   BLCKSZ);
-			/* We don't worry about zeroing the "hole" in this case */
+
+			if (data_encrypted)
+				set_page_lsn_for_encryption(BufferGetPage(pageData->buffer));
+
 			MarkBufferDirty(pageData->buffer);
 		}
 		END_CRIT_SECTION();
diff --git a/src/backend/access/transam/xlog.c b/src/backend/access/transam/xlog.c
index 36e077045b..f87e77747b 100644
--- a/src/backend/access/transam/xlog.c
+++ b/src/backend/access/transam/xlog.c
@@ -4,6 +4,7 @@
  *		PostgreSQL write-ahead log manager
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -55,6 +56,7 @@
 #include "replication/walreceiver.h"
 #include "replication/walsender.h"
 #include "storage/bufmgr.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
 #include "storage/large_object.h"
@@ -77,6 +79,7 @@
 #include "pg_trace.h"
 
 extern uint32 bootstrap_data_checksum_version;
+extern char *bootstrap_encryption_sample;
 
 /* Unsupported old recovery command file names (relative to $PGDATA) */
 #define RECOVERY_COMMAND_FILE	"recovery.conf"
@@ -887,6 +890,7 @@ static void CreateEndOfRecoveryRecord(void);
 static XLogRecPtr CreateOverwriteContrecordRecord(XLogRecPtr aborted_lsn);
 static void CheckPointGuts(XLogRecPtr checkPointRedo, int flags);
 static void KeepLogSeg(XLogRecPtr recptr, XLogSegNo *logSegNo);
+static Size XLogWritePages(char *from, int npages, uint32 startoffset);
 static XLogRecPtr XLogGetReplicationSlotMinimumLSN(void);
 
 static void AdvanceXLInsertBuffer(XLogRecPtr upto, bool opportunistic);
@@ -2509,35 +2513,70 @@ XLogWrite(XLogwrtRqst WriteRqst, bool flexible)
 			finishing_seg)
 		{
 			char	   *from;
-			Size		nbytes;
-			Size		nleft;
-			int			written;
 
 			/* OK to write the page(s) */
 			from = XLogCtl->pages + startidx * (Size) XLOG_BLCKSZ;
-			nbytes = npages * (Size) XLOG_BLCKSZ;
-			nleft = nbytes;
-			do
+			if (data_encrypted)
 			{
-				errno = 0;
-				pgstat_report_wait_start(WAIT_EVENT_WAL_WRITE);
-				written = pg_pwrite(openLogFile, from, nleft, startoffset);
-				pgstat_report_wait_end();
-				if (written <= 0)
+				int			i,
+							nencrypted;
+				char	   *to;
+				uint32		encr_offset;
+
+				/*
+				 * Encrypt and write multiple pages at a time, in order to
+				 * reduce the number of syscalls.
+				 */
+				nencrypted = 0;
+				to = encrypt_buf_xlog;
+				encr_offset = startoffset;
+				for (i = 1; i <= npages; i++)
 				{
-					if (errno == EINTR)
-						continue;
-					ereport(PANIC,
-							(errcode_for_file_access(),
-							 errmsg("could not write to log file %s "
-									"at offset %u, length %zu: %m",
-									XLogFileNameP(ThisTimeLineID, openLogSegNo),
-									startoffset, nleft)));
+					char		tweak[TWEAK_SIZE];
+					Size		nbytes;
+
+					XLogEncryptionTweak(tweak, ThisTimeLineID, openLogSegNo, encr_offset);
+
+					/*
+					 * We should not encrypt the unused space, in order to
+					 * avoid "reused key attack".
+					 */
+					if (i == npages && ispartialpage)
+						nbytes = WriteRqst.Write % XLOG_BLCKSZ;
+					else
+						nbytes = XLOG_BLCKSZ;
+
+					encrypt_block(from,
+								  to,
+								  nbytes,
+								  tweak,
+								  InvalidXLogRecPtr,
+								  InvalidBlockNumber,
+								  EDK_PERMANENT);
+					nencrypted++;
+					from += XLOG_BLCKSZ;
+					to += XLOG_BLCKSZ;
+					encr_offset += XLOG_BLCKSZ;
+
+					/*
+					 * Write the encrypted data if the encryption buffer is
+					 * full or if the last page has been encrypted.
+					 */
+					if (nencrypted >= XLOG_ENCRYPT_BUF_PAGES || i >= npages)
+					{
+						startoffset += XLogWritePages(encrypt_buf_xlog,
+													  nencrypted,
+													  startoffset);
+
+						/* Prepare for the next round of page encryptions. */
+						nencrypted = 0;
+						to = encrypt_buf_xlog;
+						encr_offset = startoffset;
+					}
 				}
-				nleft -= written;
-				from += written;
-				startoffset += written;
-			} while (nleft > 0);
+			}
+			else
+				startoffset += XLogWritePages(from, npages, startoffset);
 
 			npages = 0;
 
@@ -2653,6 +2692,45 @@ XLogWrite(XLogwrtRqst WriteRqst, bool flexible)
 	}
 }
 
+/*
+ * Write page(s) to the XLOG file.
+ *
+ * Returns the number of bytes written.
+ */
+static Size
+XLogWritePages(char *from, int npages, uint32 startoffset)
+{
+	Size		nbytes,
+				nleft;
+	Size		written;
+
+	nbytes = npages * (Size) XLOG_BLCKSZ;
+	nleft = nbytes;
+	do
+	{
+		errno = 0;
+		pgstat_report_wait_start(WAIT_EVENT_WAL_WRITE);
+		written = pg_pwrite(openLogFile, from, nleft, startoffset);
+		pgstat_report_wait_end();
+		if (written <= 0)
+		{
+			if (errno == EINTR)
+				continue;
+			ereport(PANIC,
+					(errcode_for_file_access(),
+					 errmsg("could not write to log file %s "
+							"at offset %u, length %zu: %m",
+							XLogFileNameP(ThisTimeLineID, openLogSegNo),
+							startoffset, nbytes)));
+		}
+		nleft -= written;
+		from += written;
+		startoffset += written;
+	} while (nleft > 0);
+
+	return written;
+}
+
 /*
  * Record the LSN for an asynchronous transaction commit/abort
  * and nudge the WALWriter if there is work for it to do.
@@ -3491,6 +3569,35 @@ XLogFileCopy(XLogSegNo destsegno, TimeLineID srcTLI, XLogSegNo srcsegno,
 			}
 			pgstat_report_wait_end();
 		}
+
+		/*
+		 * Since timeline is being changed and since encryption tweak contains
+		 * the timeline, we need to decrypt the buffer and encrypt it with the
+		 * new tweak. Do not encrypt the unused space, in order to avoid
+		 * "reused key attack".
+		 */
+		if (data_encrypted && nread > 0)
+		{
+			char		tweak[TWEAK_SIZE];
+
+			XLogEncryptionTweak(tweak, srcTLI, srcsegno, nbytes);
+			decrypt_block(buffer.data,
+						  buffer.data,
+						  nread,
+						  tweak,
+						  InvalidBlockNumber,
+						  EDK_PERMANENT);
+
+			XLogEncryptionTweak(tweak, ThisTimeLineID, destsegno, nbytes);
+			encrypt_block(buffer.data,
+						  buffer.data,
+						  nread,
+						  tweak,
+						  InvalidXLogRecPtr,
+						  InvalidBlockNumber,
+						  EDK_PERMANENT);
+		}
+
 		errno = 0;
 		pgstat_report_wait_start(WAIT_EVENT_WAL_COPY_WRITE);
 		if ((int) write(fd, buffer.data, sizeof(buffer)) != (int) sizeof(buffer))
@@ -4857,6 +4964,28 @@ ReadControlFile(void)
 		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
 						errmsg("\"max_wal_size\" must be at least twice \"wal_segment_size\"")));
 
+	/*
+	 * Initialize encryption, but not if the current backend has already done
+	 * that.
+	 */
+	if (ControlFile->data_cipher > PG_CIPHER_NONE && !data_encrypted)
+	{
+		/*
+		 * Set data_encryption for caller to know that he needs to retrieve
+		 * the key and initialize the encryption context.
+		 */
+		SetConfigOption("data_encryption", "true", PGC_INTERNAL,
+						PGC_S_OVERRIDE);
+
+		/*
+		 * Save the verification string. We'll perform the actual verification
+		 * as soon as the encryption setup is done.
+		 */
+		memcpy(encryption_verification,
+			   ControlFile->encryption_verification,
+			   ENCRYPTION_SAMPLE_SIZE);
+	}
+
 	UsableBytesInSegment =
 		(wal_segment_size / XLOG_BLCKSZ * UsableBytesInPage) -
 		(SizeOfXLogLongPHD - SizeOfXLogShortPHD);
@@ -5287,6 +5416,20 @@ BootStrapXLOG(void)
 	use_existent = false;
 	openLogFile = XLogFileInit(1, &use_existent, false);
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, ThisTimeLineID, 1, 0);
+		encrypt_block((char *) page,
+					  (char *) page,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidXLogRecPtr,
+					  InvalidBlockNumber,
+					  EDK_PERMANENT);
+	}
+
 	/* Write the first page with the initial record */
 	errno = 0;
 	pgstat_report_wait_start(WAIT_EVENT_WAL_BOOTSTRAP_WRITE);
@@ -5338,6 +5481,24 @@ BootStrapXLOG(void)
 	ControlFile->track_commit_timestamp = track_commit_timestamp;
 	ControlFile->data_checksum_version = bootstrap_data_checksum_version;
 
+	if (data_encrypted)
+	{
+		char	sample[ENCRYPTION_SAMPLE_SIZE];
+
+		ControlFile->data_cipher = PG_CIPHER_AES_CTR_128;
+
+		sample_encryption(sample);
+
+		memcpy(ControlFile->encryption_verification, sample,
+			   ENCRYPTION_SAMPLE_SIZE);
+	}
+	else
+	{
+		ControlFile->data_cipher = PG_CIPHER_NONE;
+		memset(ControlFile->encryption_verification, 0,
+			   ENCRYPTION_SAMPLE_SIZE);
+	}
+
 	/* some additional ControlFile fields are set in WriteControlFile() */
 
 	WriteControlFile();
@@ -12032,6 +12193,19 @@ retry:
 	Assert(targetPageOff == readOff);
 	Assert(reqLen <= readLen);
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, curFileTLI, readSegNo, readOff);
+		decrypt_block(readBuf,
+					  readBuf,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_PERMANENT);
+	}
+
 	*readTLI = curFileTLI;
 
 	/*
diff --git a/src/backend/access/transam/xloginsert.c b/src/backend/access/transam/xloginsert.c
index 24a6f3148b..dee2fc53ee 100644
--- a/src/backend/access/transam/xloginsert.c
+++ b/src/backend/access/transam/xloginsert.c
@@ -1109,6 +1109,56 @@ log_newpage_range(Relation rel, ForkNumber forkNum,
 	}
 }
 
+/*
+ * Set fake LSN to pages which log_newpage_range would WAL-log if the relation
+ * was persistent and if encryption was disabled.
+ *
+ * This is for encryption because we uses LSN to construct the encryption IV.
+ */
+void
+newpage_range_set_lsn(Relation rel, BlockNumber startblk, BlockNumber endblk)
+{
+	BlockNumber blkno;
+	XLogRecPtr	recptr;
+
+	if (!data_encrypted)
+		return;
+
+	recptr = get_lsn_for_encryption();
+	blkno = startblk;
+	while (blkno < endblk)
+	{
+		Buffer		buf = ReadBuffer(rel, blkno);
+
+		CHECK_FOR_INTERRUPTS();
+
+		START_CRIT_SECTION();
+
+		LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE);
+
+		/*
+		 * Completely empty pages are not encrypted.
+		 */
+		if (!PageIsNew(BufferGetPage(buf)))
+		{
+			MarkBufferDirty(buf);
+			PageSetLSN(BufferGetPage(buf), recptr);
+		}
+#ifdef USE_ASSERT_CHECKING
+		else
+		{
+			Assert(XLogRecPtrIsInvalid(PageGetLSN(BufferGetPage(buf))));
+
+		}
+#endif	/* USE_ASSERT_CHECKING */
+		UnlockReleaseBuffer(buf);
+
+		END_CRIT_SECTION();
+
+		blkno++;
+	}
+}
+
 /*
  * Allocate working buffers needed for WAL record construction.
  */
diff --git a/src/backend/access/transam/xlogutils.c b/src/backend/access/transam/xlogutils.c
index 10a663bae6..1cfb9769cd 100644
--- a/src/backend/access/transam/xlogutils.c
+++ b/src/backend/access/transam/xlogutils.c
@@ -8,6 +8,7 @@
  * None of this code is used during normal system operation.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -25,6 +26,7 @@
 #include "access/xlogutils.h"
 #include "miscadmin.h"
 #include "pgstat.h"
+#include "storage/encryption.h"
 #include "storage/smgr.h"
 #include "utils/guc.h"
 #include "utils/hsearch.h"
@@ -656,9 +658,11 @@ static void
 XLogRead(char *buf, int segsize, TimeLineID tli, XLogRecPtr startptr,
 		 Size count)
 {
-	char	   *p;
 	XLogRecPtr	recptr;
 	Size		nbytes;
+	char	   *decrypt_p;
+	uint32		decryptOff;
+	char	   *p;
 
 	/* state maintained across calls */
 	static int	sendFile = -1;
@@ -668,17 +672,46 @@ XLogRead(char *buf, int segsize, TimeLineID tli, XLogRecPtr startptr,
 
 	Assert(segsize == wal_segment_size);
 
+	/*
+	 * TODO Currently the function is only called with startptr at page
+	 * boundary. walsender.c:XLogRead() is more generic but it's a bit
+	 * different, so decryption also needs to be adopted in a little different
+	 * way (i.e. the decryption cannot be merged here mechanically). Manual
+	 * merge is not worth the effort right now because a separate patch to
+	 * consolidate XLogRead() functions is in the queue
+	 * (https://commitfest.postgresql.org/23/2098/). Let's implement the
+	 * decryption in a generic way when that patch is committed.
+	 */
+	Assert(startptr % XLOG_BLCKSZ == 0);
+
 	p = buf;
 	recptr = startptr;
 	nbytes = count;
 
+	decrypt_p = p;
+	decryptOff = XLogSegmentOffset(recptr, segsize);
+
 	while (nbytes > 0)
 	{
 		uint32		startoff;
 		int			segbytes;
 		int			readbytes;
 
-		startoff = XLogSegmentOffset(recptr, segsize);
+		if (recptr == startptr)
+			startoff = decryptOff;
+		else
+		{
+			startoff = XLogSegmentOffset(recptr, segsize);
+			if (startoff == 0)
+			{
+				/*
+				 * If segment boundary was reached, decryptOff should have
+				 * caught up, so we can (and should) sync it with startoff.
+				 */
+				Assert(decryptOff == segsize);
+				decryptOff = startoff;
+			}
+		}
 
 		/* Do we need to switch to a different xlog segment? */
 		if (sendFile < 0 || !XLByteInSeg(recptr, sendSegNo, segsize) ||
@@ -758,7 +791,33 @@ XLogRead(char *buf, int segsize, TimeLineID tli, XLogRecPtr startptr,
 		sendOff += readbytes;
 		nbytes -= readbytes;
 		p += readbytes;
+
+		/* Decrypt completed blocks */
+		if (data_encrypted)
+		{
+			while (decrypt_p + XLOG_BLCKSZ <= p)
+			{
+				char		tweak[TWEAK_SIZE];
+
+				XLogEncryptionTweak(tweak, tli, sendSegNo, decryptOff);
+				decrypt_block(decrypt_p,
+							  decrypt_p,
+							  XLOG_BLCKSZ,
+							  tweak,
+							  InvalidBlockNumber,
+							  EDK_PERMANENT);
+
+				decrypt_p += XLOG_BLCKSZ;
+				decryptOff += XLOG_BLCKSZ;
+			}
+		}
 	}
+
+	/*
+	 * TODO Currently the function is only called with count==XLOG_BLCKSZ. See
+	 * the comment on consolidation of XLogRead() above.
+	 */
+	Assert(decrypt_p == p || !data_encrypted);
 }
 
 /*
diff --git a/src/backend/bootstrap/bootstrap.c b/src/backend/bootstrap/bootstrap.c
index 43627ab8f4..514604aef8 100644
--- a/src/backend/bootstrap/bootstrap.c
+++ b/src/backend/bootstrap/bootstrap.c
@@ -4,6 +4,7 @@
  *	  routines to support running postgres in 'bootstrap' mode
  *	bootstrap mode is used to create the initial template database
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -40,6 +41,7 @@
 #include "storage/bufmgr.h"
 #include "storage/bufpage.h"
 #include "storage/condition_variable.h"
+#include "storage/encryption.h"
 #include "storage/ipc.h"
 #include "storage/proc.h"
 #include "tcop/tcopprot.h"
@@ -58,6 +60,7 @@ uint32		bootstrap_data_checksum_version = 0;	/* No checksum */
 
 static void CheckerModeMain(void);
 static void BootstrapModeMain(void);
+static int bootstrap_getc(void);
 static void bootstrap_signals(void);
 static void ShutdownAuxiliaryProcess(int code, Datum arg);
 static Form_pg_attribute AllocateAttribute(void);
@@ -226,7 +229,7 @@ AuxiliaryProcessMain(int argc, char *argv[])
 	/* If no -x argument, we are a CheckerProcess */
 	MyAuxProcType = CheckerProcess;
 
-	while ((flag = getopt(argc, argv, "B:c:d:D:Fkr:x:X:-:")) != -1)
+	while ((flag = getopt(argc, argv, "B:c:d:D:FkKr:x:X:-:")) != -1)
 	{
 		switch (flag)
 		{
@@ -252,6 +255,22 @@ AuxiliaryProcessMain(int argc, char *argv[])
 			case 'F':
 				SetConfigOption("fsync", "false", PGC_POSTMASTER, PGC_S_ARGV);
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				/*
+				 * When auxiliary process (bootstrap) starts, the control file
+				 * does not exist yet, so command line option needs to be used
+				 * to indicate that the encryption is enabled.
+				 *
+				 * Postmaster should not pass this option. Instead, it just
+				 * sets data_encrypted according to the control file and child
+				 * processes inherit that.
+				 */
+				Assert(!IsUnderPostmaster);
+				data_encrypted = true;
+
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'k':
 				bootstrap_data_checksum_version = PG_DATA_CHECKSUM_VERSION;
 				break;
@@ -373,6 +392,24 @@ AuxiliaryProcessMain(int argc, char *argv[])
 	if (!IsUnderPostmaster)
 		InitializeMaxBackends();
 
+	/*
+	 * If data_encryption is set because of command line option, do the setup
+	 * now. (If set by postmaster, postmaster should have performed the
+	 * setup.)
+	 *
+	 * This should only be useful for the bootstrap process. Anyone else
+	 * detects the encryption via ReadControlFile().
+	 */
+	if (data_encrypted && MyAuxProcType == BootstrapProcess)
+	{
+		Assert(!IsUnderPostmaster);
+
+		/* Read the key from stdin. */
+		read_encryption_key(bootstrap_getc);
+
+		setup_encryption();
+	}
+
 	BaseInit();
 
 	/*
@@ -550,6 +587,16 @@ BootstrapModeMain(void)
  * ----------------------------------------------------------------
  */
 
+/*
+ * Read a single character from stdin. This is a callback for
+ * read_encryption_key().
+ */
+static int
+bootstrap_getc(void)
+{
+	return getc(stdin);
+}
+
 /*
  * Set up signal handling for a bootstrap process
  */
diff --git a/src/backend/catalog/storage.c b/src/backend/catalog/storage.c
index 5c76e7a39b..f1356d87c5 100644
--- a/src/backend/catalog/storage.c
+++ b/src/backend/catalog/storage.c
@@ -3,6 +3,7 @@
  * storage.c
  *	  code to create and destroy physical storage for relations
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -246,12 +247,12 @@ RelationTruncate(Relation rel, BlockNumber nblocks)
 	/* Truncate the FSM first if it exists */
 	fsm = smgrexists(rel->rd_smgr, FSM_FORKNUM);
 	if (fsm)
-		FreeSpaceMapTruncateRel(rel, nblocks);
+		FreeSpaceMapTruncateRel(rel, nblocks, InvalidXLogRecPtr);
 
 	/* Truncate the visibility map too if it exists. */
 	vm = smgrexists(rel->rd_smgr, VISIBILITYMAP_FORKNUM);
 	if (vm)
-		visibilitymap_truncate(rel, nblocks);
+		visibilitymap_truncate(rel, nblocks, InvalidXLogRecPtr);
 
 	/*
 	 * Make sure that a concurrent checkpoint can't complete while truncation
@@ -357,13 +358,29 @@ RelationCopyStorage(SMgrRelation src, SMgrRelation dst,
 
 	for (blkno = 0; blkno < nblocks; blkno++)
 	{
+		char	*buf_read, *buf_dst;
+		Page	page_encr = NULL;
+		XLogRecPtr	lsn;
+
 		/* If we got a cancel signal during the copy of the data, quit */
 		CHECK_FOR_INTERRUPTS();
 
-		smgrread(src, forkNum, blkno, buf.data);
+		if (!data_encrypted)
+			buf_read = buf.data;
+		else
+			buf_read = encrypt_buf.data;
+
+		smgrread(src, forkNum, blkno, buf_read);
+
+		if (data_encrypted)
+		{
+			decrypt_page(buf_read, buf.data, blkno, relpersistence);
+			page_encr = buf_read;
+		}
 
 		if (!PageIsVerifiedExtended(page, blkno,
-									PIV_LOG_WARNING | PIV_REPORT_STAT))
+									PIV_LOG_WARNING | PIV_REPORT_STAT,
+									page_encr))
 			ereport(ERROR,
 					(errcode(ERRCODE_DATA_CORRUPTED),
 					 errmsg("invalid page in block %u of relation %s",
@@ -378,16 +395,39 @@ RelationCopyStorage(SMgrRelation src, SMgrRelation dst,
 		 * space.
 		 */
 		if (use_wal)
+		{
 			log_newpage(&dst->smgr_rnode.node, forkNum, blkno, page, false);
+			lsn = PageGetLSN(page);
+		}
+		else if (data_encrypted)
+			lsn = get_lsn_for_encryption();
+
+		buf_dst = (char *) page;
+
+		/*
+		 * Encrypt only if we have valid IV. It should be always except when
+		 * log_newpage() encountered an empty page - it should be safe not to
+		 * encrypt such one.
+		 */
+		if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+		{
+			encrypt_page(buf_dst,
+						 encrypt_buf.data,
+						 lsn,
+						 blkno,
+						 relpersistence);
+
+			buf_dst = encrypt_buf.data;
+		}
 
-		PageSetChecksumInplace(page, blkno);
+		PageSetChecksumInplace(buf_dst, blkno);
 
 		/*
 		 * Now write the page.  We say isTemp = true even if it's not a temp
 		 * rel, because there's no need for smgr to schedule an fsync for this
 		 * write; we'll do it ourselves below.
 		 */
-		smgrextend(dst, forkNum, blkno, buf.data, true);
+		smgrextend(dst, forkNum, blkno, buf_dst, true);
 	}
 
 	/*
@@ -654,10 +694,10 @@ smgr_redo(XLogReaderState *record)
 
 		if ((xlrec->flags & SMGR_TRUNCATE_FSM) != 0 &&
 			smgrexists(reln, FSM_FORKNUM))
-			FreeSpaceMapTruncateRel(rel, xlrec->blkno);
+			FreeSpaceMapTruncateRel(rel, xlrec->blkno, lsn);
 		if ((xlrec->flags & SMGR_TRUNCATE_VM) != 0 &&
 			smgrexists(reln, VISIBILITYMAP_FORKNUM))
-			visibilitymap_truncate(rel, xlrec->blkno);
+			visibilitymap_truncate(rel, xlrec->blkno, lsn);
 
 		FreeFakeRelcacheEntry(rel);
 	}
diff --git a/src/backend/commands/sequence.c b/src/backend/commands/sequence.c
index 0577184f82..c9cbd55abf 100644
--- a/src/backend/commands/sequence.c
+++ b/src/backend/commands/sequence.c
@@ -415,6 +415,8 @@ fill_seq_with_data(Relation rel, HeapTuple tuple)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -819,6 +821,8 @@ nextval_internal(Oid relid, bool check_permissions)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	/* Now update sequence tuple to the intended final state */
 	seq->last_value = last;		/* last fetched number */
@@ -1014,6 +1018,8 @@ do_setval(Oid relid, int64 next, bool iscalled)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(buf));
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/postmaster/pgstat.c b/src/backend/postmaster/pgstat.c
index e03233ae7d..b6dc22aac1 100644
--- a/src/backend/postmaster/pgstat.c
+++ b/src/backend/postmaster/pgstat.c
@@ -11,6 +11,7 @@
  *			- Add a pgstat config column to pg_database, so this
  *			  entire thing can be enabled/disabled on a per db basis.
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2001-2019, PostgreSQL Global Development Group
  *
  *	src/backend/postmaster/pgstat.c
@@ -53,6 +54,7 @@
 #include "postmaster/postmaster.h"
 #include "replication/walsender.h"
 #include "storage/backendid.h"
+#include "storage/buffile.h"
 #include "storage/dsm.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
@@ -292,10 +294,16 @@ static void pgstat_sighup_handler(SIGNAL_ARGS);
 static PgStat_StatDBEntry *pgstat_get_db_entry(Oid databaseid, bool create);
 static PgStat_StatTabEntry *pgstat_get_tab_entry(PgStat_StatDBEntry *dbentry,
 												 Oid tableoid, bool create);
+static void pgstat_tweak_base(bool permanent, bool global, Oid database,
+							  char tweak_base[TWEAK_BASE_SIZE]);
 static void pgstat_write_statsfiles(bool permanent, bool allDbs);
 static void pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent);
+static void pgstat_write_bytes(TransientBufFile *file, void *ptr, size_t size,
+							   bool *failed);
 static HTAB *pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep);
 static void pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash, bool permanent);
+static void pgstat_read_bytes(TransientBufFile *file, void *ptr, size_t size,
+							  bool *failed);
 static void backend_read_statsfile(void);
 static void pgstat_read_current_status(void);
 
@@ -4013,12 +4021,6 @@ pgstat_get_wait_io(WaitEventIO w)
 		case WAIT_EVENT_RELATION_MAP_WRITE:
 			event_name = "RelationMapWrite";
 			break;
-		case WAIT_EVENT_REORDER_BUFFER_READ:
-			event_name = "ReorderBufferRead";
-			break;
-		case WAIT_EVENT_REORDER_BUFFER_WRITE:
-			event_name = "ReorderBufferWrite";
-			break;
 		case WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ:
 			event_name = "ReorderLogicalMappingRead";
 			break;
@@ -4462,6 +4464,9 @@ PgstatCollectorMain(int argc, char *argv[])
 	 */
 	init_ps_display("stats collector", "", "", "");
 
+	/* BufFileOpenTransient() and friends do use VFD. */
+	InitFileAccess();
+
 	/*
 	 * Read in existing stats files or initialize the stats to zero.
 	 */
@@ -4845,6 +4850,26 @@ pgstat_get_tab_entry(PgStat_StatDBEntry *dbentry, Oid tableoid, bool create)
 	return result;
 }
 
+/*
+ * Initialize the common part of the encryption tweak.
+ */
+static void
+pgstat_tweak_base(bool permanent, bool global, Oid database,
+				  char tweak_base[TWEAK_BASE_SIZE])
+{
+	char	*c = tweak_base;
+
+	StaticAssertStmt(3 + sizeof(Oid) <= TWEAK_BASE_SIZE,
+					 "tweak components do not fit into TWEAK_BASE_SIZE");
+	memset(tweak_base, 0, TWEAK_BASE_SIZE);
+	*c = TRANS_BUF_FILE_PGSTATS;
+	c++;
+	*c = permanent;
+	c++;
+	*c = global;
+	c++;
+	memcpy(c, &database, sizeof(Oid));
+}
 
 /* ----------
  * pgstat_write_statsfiles() -
@@ -4865,18 +4890,25 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 {
 	HASH_SEQ_STATUS hstat;
 	PgStat_StatDBEntry *dbentry;
-	FILE	   *fpout;
+	TransientBufFile	   *fpout;
+	File	vfd;
 	int32		format_id;
 	const char *tmpfile = permanent ? PGSTAT_STAT_PERMANENT_TMPFILE : pgstat_stat_tmpname;
 	const char *statfile = permanent ? PGSTAT_STAT_PERMANENT_FILENAME : pgstat_stat_filename;
-	int			rc;
+	bool	failed = false;
+	char tweak_base[TWEAK_BASE_SIZE];
 
 	elog(DEBUG2, "writing stats file \"%s\"", statfile);
 
 	/*
 	 * Open the statistics temp file to write out the current values.
 	 */
-	fpout = AllocateFile(tmpfile, PG_BINARY_W);
+	if (data_encrypted)
+		pgstat_tweak_base(permanent, true, InvalidOid, tweak_base);
+	fpout = BufFileOpenTransient(tmpfile,
+								 O_CREAT | O_WRONLY | O_APPEND | PG_BINARY,
+								 tweak_base,
+								 WARNING);
 	if (fpout == NULL)
 	{
 		ereport(LOG,
@@ -4895,20 +4927,17 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 	 * Write the file header --- currently just a format ID.
 	 */
 	format_id = PGSTAT_FILE_FORMAT_ID;
-	rc = fwrite(&format_id, sizeof(format_id), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &format_id, sizeof(format_id), &failed);
 
 	/*
 	 * Write global stats struct
 	 */
-	rc = fwrite(&globalStats, sizeof(globalStats), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &globalStats, sizeof(globalStats), &failed);
 
 	/*
 	 * Write archiver stats struct
 	 */
-	rc = fwrite(&archiverStats, sizeof(archiverStats), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &archiverStats, sizeof(archiverStats), &failed);
 
 	/*
 	 * Walk through the database table.
@@ -4932,28 +4961,37 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 		 * Write out the DB entry. We don't write the tables or functions
 		 * pointers, since they're of no use to any other process.
 		 */
-		fputc('D', fpout);
-		rc = fwrite(dbentry, offsetof(PgStat_StatDBEntry, tables), 1, fpout);
-		(void) rc;				/* we'll check for error with ferror */
+		pgstat_write_bytes(fpout, "D", 1, &failed);
+		pgstat_write_bytes(fpout,
+						   dbentry,
+						   offsetof(PgStat_StatDBEntry, tables),
+						   &failed);
 	}
 
 	/*
 	 * No more output to be done. Close the temp file and replace the old
-	 * pgstat.stat with it.  The ferror() check replaces testing for error
-	 * after each individual fputc or fwrite above.
+	 * pgstat.stat with it.
 	 */
-	fputc('E', fpout);
+	pgstat_write_bytes(fpout, "E", 1, &failed);
 
-	if (ferror(fpout))
+	if (failed)
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
 				 errmsg("could not write temporary statistics file \"%s\": %m",
 						tmpfile)));
-		FreeFile(fpout);
+		BufFileCloseTransient(fpout);
 		unlink(tmpfile);
+		return;
 	}
-	else if (FreeFile(fpout) < 0)
+
+	/*
+	 * XXX This might PANIC, see FileClose(). Don't we need special behaviour
+	 * for statistics?
+	 */
+	vfd = BufFileTransientGetVfd(fpout);
+	BufFileCloseTransient(fpout);
+	if (!FileIsClosed(vfd))
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
@@ -5018,12 +5056,14 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	HASH_SEQ_STATUS fstat;
 	PgStat_StatTabEntry *tabentry;
 	PgStat_StatFuncEntry *funcentry;
-	FILE	   *fpout;
+	TransientBufFile	   *fpout;
+	File	vfd;
 	int32		format_id;
 	Oid			dbid = dbentry->databaseid;
-	int			rc;
 	char		tmpfile[MAXPGPATH];
 	char		statfile[MAXPGPATH];
+	bool	failed = false;
+	char tweak_base[TWEAK_BASE_SIZE];
 
 	get_dbstat_filename(permanent, true, dbid, tmpfile, MAXPGPATH);
 	get_dbstat_filename(permanent, false, dbid, statfile, MAXPGPATH);
@@ -5033,7 +5073,12 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	/*
 	 * Open the statistics temp file to write out the current values.
 	 */
-	fpout = AllocateFile(tmpfile, PG_BINARY_W);
+	if (data_encrypted)
+		pgstat_tweak_base(permanent, false, dbid, tweak_base);
+	fpout = BufFileOpenTransient(tmpfile,
+								 O_CREAT | O_WRONLY | O_APPEND | PG_BINARY,
+								 tweak_base,
+								 WARNING);
 	if (fpout == NULL)
 	{
 		ereport(LOG,
@@ -5047,8 +5092,7 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	 * Write the file header --- currently just a format ID.
 	 */
 	format_id = PGSTAT_FILE_FORMAT_ID;
-	rc = fwrite(&format_id, sizeof(format_id), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &format_id, sizeof(format_id), &failed);
 
 	/*
 	 * Walk through the database's access stats per table.
@@ -5056,9 +5100,14 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	hash_seq_init(&tstat, dbentry->tables);
 	while ((tabentry = (PgStat_StatTabEntry *) hash_seq_search(&tstat)) != NULL)
 	{
-		fputc('T', fpout);
-		rc = fwrite(tabentry, sizeof(PgStat_StatTabEntry), 1, fpout);
-		(void) rc;				/* we'll check for error with ferror */
+		pgstat_write_bytes(fpout, "T", 1, &failed);
+		if (failed)
+			break;
+
+		pgstat_write_bytes(fpout, tabentry, sizeof(PgStat_StatTabEntry),
+						   &failed);
+		if (failed)
+			break;
 	}
 
 	/*
@@ -5067,28 +5116,42 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	hash_seq_init(&fstat, dbentry->functions);
 	while ((funcentry = (PgStat_StatFuncEntry *) hash_seq_search(&fstat)) != NULL)
 	{
-		fputc('F', fpout);
-		rc = fwrite(funcentry, sizeof(PgStat_StatFuncEntry), 1, fpout);
-		(void) rc;				/* we'll check for error with ferror */
+		pgstat_write_bytes(fpout, "F", 1, &failed);
+		if (failed)
+			break;
+
+		pgstat_write_bytes(fpout,
+						   funcentry,
+						   sizeof(PgStat_StatFuncEntry),
+						   &failed);
+		if (failed)
+			break;
 	}
 
 	/*
 	 * No more output to be done. Close the temp file and replace the old
-	 * pgstat.stat with it.  The ferror() check replaces testing for error
-	 * after each individual fputc or fwrite above.
+	 * pgstat.stat with it.
 	 */
-	fputc('E', fpout);
+	pgstat_write_bytes(fpout, "E", 1, &failed);
 
-	if (ferror(fpout))
+	if (failed)
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
 				 errmsg("could not write temporary statistics file \"%s\": %m",
 						tmpfile)));
-		FreeFile(fpout);
+		BufFileCloseTransient(fpout);
 		unlink(tmpfile);
+		return;
 	}
-	else if (FreeFile(fpout) < 0)
+
+	/*
+	 * XXX This might PANIC, see FileClose(). Don't we need special behaviour
+	 * for statistics?
+	 */
+	vfd = BufFileTransientGetVfd(fpout);
+	BufFileCloseTransient(fpout);
+	if (!FileIsClosed(vfd))
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
@@ -5114,6 +5177,25 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	}
 }
 
+/*
+ * Convenience routine to write data to file and check for errors.
+ */
+static void
+pgstat_write_bytes(TransientBufFile *file, void *ptr, size_t size,
+	bool *failed)
+{
+	/* Do nothing if any previous write failed. */
+	if (*failed)
+		return;
+
+	/*
+	 * Use BufFileWriteTransient() because it handles encryption
+	 * transparently.
+	 */
+	if (BufFileWriteTransient(file, ptr, size) != size)
+		*failed = true;
+}
+
 /* ----------
  * pgstat_read_statsfiles() -
  *
@@ -5141,10 +5223,12 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	PgStat_StatDBEntry dbbuf;
 	HASHCTL		hash_ctl;
 	HTAB	   *dbhash;
-	FILE	   *fpin;
+	TransientBufFile *fpin;
 	int32		format_id;
 	bool		found;
 	const char *statfile = permanent ? PGSTAT_STAT_PERMANENT_FILENAME : pgstat_stat_filename;
+	bool	failed = false;
+	char tweak_base[TWEAK_BASE_SIZE];
 
 	/*
 	 * The tables will live in pgStatLocalContext.
@@ -5184,7 +5268,12 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	 * not yet written the stats file the first time.  Any other failure
 	 * condition is suspicious.
 	 */
-	if ((fpin = AllocateFile(statfile, PG_BINARY_R)) == NULL)
+	if (data_encrypted)
+		pgstat_tweak_base(permanent, true, InvalidOid, tweak_base);
+	if ((fpin = BufFileOpenTransient(statfile,
+									 O_RDONLY | PG_BINARY,
+									 tweak_base,
+									 WARNING)) == NULL)
 	{
 		if (errno != ENOENT)
 			ereport(pgStatRunningInCollector ? LOG : WARNING,
@@ -5197,8 +5286,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Verify it's of the expected format.
 	 */
-	if (fread(&format_id, 1, sizeof(format_id), fpin) != sizeof(format_id) ||
-		format_id != PGSTAT_FILE_FORMAT_ID)
+	pgstat_read_bytes(fpin, &format_id, sizeof(format_id), &failed);
+	if (failed || format_id != PGSTAT_FILE_FORMAT_ID)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -5208,7 +5297,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Read global stats struct
 	 */
-	if (fread(&globalStats, 1, sizeof(globalStats), fpin) != sizeof(globalStats))
+	pgstat_read_bytes(fpin, &globalStats, sizeof(globalStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -5229,7 +5319,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Read archiver stats struct
 	 */
-	if (fread(&archiverStats, 1, sizeof(archiverStats), fpin) != sizeof(archiverStats))
+	pgstat_read_bytes(fpin, &archiverStats, sizeof(archiverStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -5243,15 +5334,22 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	 */
 	for (;;)
 	{
-		switch (fgetc(fpin))
+		char	c;
+
+		pgstat_read_bytes(fpin, &c, 1, &failed);
+
+		switch (c)
 		{
 				/*
 				 * 'D'	A PgStat_StatDBEntry struct describing a database
 				 * follows.
 				 */
 			case 'D':
-				if (fread(&dbbuf, 1, offsetof(PgStat_StatDBEntry, tables),
-						  fpin) != offsetof(PgStat_StatDBEntry, tables))
+				pgstat_read_bytes(fpin,
+								  &dbbuf,
+								  offsetof(PgStat_StatDBEntry, tables),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -5339,7 +5437,7 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	}
 
 done:
-	FreeFile(fpin);
+	BufFileCloseTransient(fpin);
 
 	/* If requested to read the permanent file, also get rid of it. */
 	if (permanent)
@@ -5374,10 +5472,12 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	PgStat_StatTabEntry tabbuf;
 	PgStat_StatFuncEntry funcbuf;
 	PgStat_StatFuncEntry *funcentry;
-	FILE	   *fpin;
+	TransientBufFile	   *fpin;
 	int32		format_id;
 	bool		found;
 	char		statfile[MAXPGPATH];
+	bool	failed = false;
+	char tweak_base[TWEAK_BASE_SIZE];
 
 	get_dbstat_filename(permanent, false, databaseid, statfile, MAXPGPATH);
 
@@ -5390,7 +5490,12 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	 * not yet written the stats file the first time.  Any other failure
 	 * condition is suspicious.
 	 */
-	if ((fpin = AllocateFile(statfile, PG_BINARY_R)) == NULL)
+	if (data_encrypted)
+		pgstat_tweak_base(permanent, false, databaseid, tweak_base);
+	if ((fpin = BufFileOpenTransient(statfile,
+									 O_RDONLY | PG_BINARY,
+									 tweak_base,
+									 WARNING)) == NULL)
 	{
 		if (errno != ENOENT)
 			ereport(pgStatRunningInCollector ? LOG : WARNING,
@@ -5403,8 +5508,8 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	/*
 	 * Verify it's of the expected format.
 	 */
-	if (fread(&format_id, 1, sizeof(format_id), fpin) != sizeof(format_id) ||
-		format_id != PGSTAT_FILE_FORMAT_ID)
+	pgstat_read_bytes(fpin, &format_id, sizeof(format_id), &failed);
+	if (failed || format_id != PGSTAT_FILE_FORMAT_ID)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -5417,14 +5522,19 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	 */
 	for (;;)
 	{
-		switch (fgetc(fpin))
+		char	c;
+
+		pgstat_read_bytes(fpin, &c, 1, &failed);
+
+		switch (c)
 		{
 				/*
 				 * 'T'	A PgStat_StatTabEntry follows.
 				 */
 			case 'T':
-				if (fread(&tabbuf, 1, sizeof(PgStat_StatTabEntry),
-						  fpin) != sizeof(PgStat_StatTabEntry))
+				pgstat_read_bytes(fpin, &tabbuf, sizeof(PgStat_StatTabEntry),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -5457,8 +5567,11 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 				 * 'F'	A PgStat_StatFuncEntry follows.
 				 */
 			case 'F':
-				if (fread(&funcbuf, 1, sizeof(PgStat_StatFuncEntry),
-						  fpin) != sizeof(PgStat_StatFuncEntry))
+				pgstat_read_bytes(fpin,
+								  &funcbuf,
+								  sizeof(PgStat_StatFuncEntry),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -5502,7 +5615,7 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	}
 
 done:
-	FreeFile(fpin);
+	BufFileCloseTransient(fpin);
 
 	if (permanent)
 	{
@@ -5535,15 +5648,22 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	PgStat_StatDBEntry dbentry;
 	PgStat_GlobalStats myGlobalStats;
 	PgStat_ArchiverStats myArchiverStats;
-	FILE	   *fpin;
+	TransientBufFile	   *fpin;
 	int32		format_id;
 	const char *statfile = permanent ? PGSTAT_STAT_PERMANENT_FILENAME : pgstat_stat_filename;
+	bool	failed = false;
+	char tweak_base[TWEAK_BASE_SIZE];
 
 	/*
 	 * Try to open the stats file.  As above, anything but ENOENT is worthy of
 	 * complaining about.
 	 */
-	if ((fpin = AllocateFile(statfile, PG_BINARY_R)) == NULL)
+	if (data_encrypted)
+		pgstat_tweak_base(permanent, true, InvalidOid, tweak_base);
+	if ((fpin = BufFileOpenTransient(statfile,
+									 O_RDONLY | PG_BINARY,
+									 tweak_base,
+									 WARNING)) == NULL)
 	{
 		if (errno != ENOENT)
 			ereport(pgStatRunningInCollector ? LOG : WARNING,
@@ -5556,36 +5676,37 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	/*
 	 * Verify it's of the expected format.
 	 */
-	if (fread(&format_id, 1, sizeof(format_id), fpin) != sizeof(format_id) ||
-		format_id != PGSTAT_FILE_FORMAT_ID)
+	pgstat_read_bytes(fpin, &format_id, sizeof(format_id), &failed);
+	if (failed || format_id != PGSTAT_FILE_FORMAT_ID)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
 	/*
 	 * Read global stats struct
 	 */
-	if (fread(&myGlobalStats, 1, sizeof(myGlobalStats),
-			  fpin) != sizeof(myGlobalStats))
+	pgstat_read_bytes(fpin, &myGlobalStats, sizeof(myGlobalStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
 	/*
 	 * Read archiver stats struct
 	 */
-	if (fread(&myArchiverStats, 1, sizeof(myArchiverStats),
-			  fpin) != sizeof(myArchiverStats))
+	pgstat_read_bytes(fpin, &myArchiverStats, sizeof(myArchiverStats),
+					  &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
@@ -5598,15 +5719,22 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	 */
 	for (;;)
 	{
-		switch (fgetc(fpin))
+		char	c;
+
+		pgstat_read_bytes(fpin, &c, 1, &failed);
+
+		switch (c)
 		{
 				/*
 				 * 'D'	A PgStat_StatDBEntry struct describing a database
 				 * follows.
 				 */
 			case 'D':
-				if (fread(&dbentry, 1, offsetof(PgStat_StatDBEntry, tables),
-						  fpin) != offsetof(PgStat_StatDBEntry, tables))
+				pgstat_read_bytes(fpin,
+								  &dbentry,
+								  offsetof(PgStat_StatDBEntry, tables),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -5638,10 +5766,28 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	}
 
 done:
-	FreeFile(fpin);
+	BufFileCloseTransient(fpin);
 	return true;
 }
 
+/*
+ * Convenience routine to read data from file and check for errors.
+ */
+static void
+pgstat_read_bytes(TransientBufFile *file, void *ptr, size_t size,
+	bool *failed)
+{
+	/* Do nothing if any previous read failed. */
+	if (*failed)
+		return;
+
+	/*
+	 * Use BufFileReadTransient() because it handles encryption transparently.
+	 */
+	if (BufFileReadTransient(file, ptr, size) != size)
+		*failed = true;
+}
+
 /*
  * If not already done, read the statistics collector stats file into
  * some hash tables.  The results will be kept until pgstat_clear_snapshot()
diff --git a/src/backend/postmaster/postmaster.c b/src/backend/postmaster/postmaster.c
index a8b3f5000c..cb7f7749f3 100644
--- a/src/backend/postmaster/postmaster.c
+++ b/src/backend/postmaster/postmaster.c
@@ -32,6 +32,7 @@
  *	  clients.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -117,6 +118,7 @@
 #include "postmaster/syslogger.h"
 #include "replication/logicallauncher.h"
 #include "replication/walsender.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
 #include "storage/pg_shmem.h"
@@ -387,6 +389,14 @@ static bool LoadedSSL = false;
 static DNSServiceRef bonjour_sdref = NULL;
 #endif
 
+#ifdef USE_ENCRYPTION
+/* Is the only purpose of this backend to receive encryption key? */
+static bool key_only_backend = false;
+
+/* Has the "key only backend" received an empty key message? */
+static bool got_empty_key_msg = false;
+#endif	/* USE_ENCRYPTION */
+
 /*
  * postmaster.c - function prototypes
  */
@@ -414,11 +424,16 @@ static void PostmasterStateMachine(void);
 static void BackendInitialize(Port *port);
 static void BackendRun(Port *port) pg_attribute_noreturn();
 static void ExitPostmaster(int status) pg_attribute_noreturn();
-static int	ServerLoop(void);
+static int	ServerLoop(bool receive_encryption_key);
+static void ServerLoopCheckTimeouts(void);
 static int	BackendStartup(Port *port);
 static int	ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done);
 static void SendNegotiateProtocolVersion(List *unrecognized_protocol_options);
 static void processCancelRequest(Port *port, void *pkt);
+#ifdef USE_ENCRYPTION
+static bool processEncryptionKeyMessage(void *pkt);
+static void shareEncryptionKey(void);
+#endif	/* USE_ENCRYPTION */
 static int	initMasks(fd_set *rmask);
 static void report_fork_failure_to_client(Port *port, int errnum);
 static CAC_state canAcceptConnections(int backend_type);
@@ -523,6 +538,10 @@ typedef struct
 	bool		IsBinaryUpgrade;
 	int			max_safe_fds;
 	int			MaxBackends;
+#ifdef USE_ENCRYPTION
+	bool		data_encrypted;
+	unsigned char encryption_key[ENCRYPTION_KEY_LENGTH];
+#endif
 #ifdef WIN32
 	HANDLE		PostmasterHandle;
 	HANDLE		initial_signal_pipe;
@@ -1384,6 +1403,56 @@ PostmasterMain(int argc, char *argv[])
 	 */
 	AddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);
 
+#ifdef USE_ENCRYPTION
+	/*
+	 * If encryption key is needed and we don't have it yet, call ServerLoop()
+	 * in a restricted mode which allows a client application to send us the
+	 * key. Regular client connections are not allowed yet.
+	 *
+	 * (If encryption_setup_done is true, it probably means that postmaster is
+	 * restarting after crash.)
+	 */
+	if (data_encrypted && !encryption_setup_done)
+	{
+		char	sample[ENCRYPTION_SAMPLE_SIZE];
+
+		/*
+		 * If the key command is in the configuration file, just run it,
+		 * otherwise let frontend application deliver it via FE/BE protocol.
+		 */
+		if (encryption_key_command)
+			run_encryption_key_command(DataDir);
+		else
+		{
+			status = ServerLoop(true);
+
+			/* No other return code should be seen here. */
+			Assert(status == STATUS_OK);
+
+			if (!encryption_key_shmem->received ||
+				encryption_key_shmem->empty)
+				ereport(FATAL, (errmsg("Encryption key not received.")));
+
+			/*
+			 * Take a local copy of the key so that we don't have to receive
+			 * it again if restarting after a crash.
+			 */
+			memcpy(encryption_key, encryption_key_shmem, ENCRYPTION_KEY_LENGTH);
+		}
+
+		/* Finalize the setup. */
+		setup_encryption();
+
+		/* Verify the key. */
+		sample_encryption(sample);
+		if (memcmp(encryption_verification, sample, ENCRYPTION_SAMPLE_SIZE))
+			ereport(FATAL,
+					(errmsg("invalid encryption key"),
+					 errdetail("The passed encryption key does not match"
+							   " database encryption key.")));
+	}
+#endif /* USE_ENCRYPTION */
+
 	/*
 	 * We're ready to rock and roll...
 	 */
@@ -1395,7 +1464,7 @@ PostmasterMain(int argc, char *argv[])
 	/* Some workers may be scheduled to start now */
 	maybe_start_bgworkers();
 
-	status = ServerLoop();
+	status = ServerLoop(false);
 
 	/*
 	 * ServerLoop probably shouldn't ever return, but if it does, close down.
@@ -1632,28 +1701,47 @@ DetermineSleepTime(struct timeval *timeout)
 	}
 }
 
+static time_t		last_lockfile_recheck_time, last_touch_time;
+
+/*
+ * The maximum amount of time postmaster can wait for encryption key if the
+ * cluster is encrypted. It should be shorter than the time pg_ctl waits for
+ * postgres to start (60 seconds) and should not be too long so that failure
+ * to specify encryption key command is recognized soon.
+ */
+#define	MAX_WAIT_FOR_KEY_SECS	20
+
+/* When should waiting for encryption key end. */
+static TimestampTz	wait_for_keys_until = 0;
+
 /*
  * Main idle loop of postmaster
  *
+ * If receive_encryption_key is true, only launch backend(s) to receive
+ * cluster encryption key and return as soon as the key is in shared memory or
+ * MAX_WAIT_FOR_KEY_SECS elapsed.
+ *
  * NB: Needs to be called with signals blocked
  */
 static int
-ServerLoop(void)
+ServerLoop(bool receive_encryption_key)
 {
 	fd_set		readmask;
 	int			nSockets;
-	time_t		last_lockfile_recheck_time,
-				last_touch_time;
 
 	last_lockfile_recheck_time = last_touch_time = time(NULL);
 
+	/* Compute wait_for_keys_until if needed and not done yet. */
+	if (receive_encryption_key && wait_for_keys_until == 0)
+		wait_for_keys_until = PgStartTime +
+			MAX_WAIT_FOR_KEY_SECS * USECS_PER_SEC;
+
 	nSockets = initMasks(&readmask);
 
 	for (;;)
 	{
 		fd_set		rmask;
 		int			selres;
-		time_t		now;
 
 		/*
 		 * Wait for a connection request to arrive.
@@ -1684,6 +1772,27 @@ ServerLoop(void)
 			/* Needs to run with blocked signals! */
 			DetermineSleepTime(&timeout);
 
+			/*
+			 * If waiting for the encryption key, make sure
+			 * MAX_WAIT_FOR_KEY_SECS is not exceeded.
+			 */
+			if (receive_encryption_key)
+			{
+				TimestampTz	timeout_tz, timeout_end;;
+
+				timeout_tz = timeout.tv_sec * USECS_PER_SEC +
+					timeout.tv_usec;
+				timeout_end = GetCurrentTimestamp() + timeout_tz;
+
+				if (timeout_end > wait_for_keys_until)
+				{
+					timeout_tz -= (timeout_end - wait_for_keys_until);
+
+					timeout.tv_sec = timeout_tz / USECS_PER_SEC;
+					timeout.tv_usec = timeout_tz % USECS_PER_SEC;
+				}
+			}
+
 			PG_SETMASK(&UnBlockSig);
 
 			selres = select(nSockets, &rmask, NULL, NULL, &timeout);
@@ -1735,6 +1844,42 @@ ServerLoop(void)
 			}
 		}
 
+		/*
+		 * If only waiting for the encryption key, it's too early to launch
+		 * the other processes.
+		 */
+		if (receive_encryption_key)
+		{
+			/* The regular checks should take place though. */
+			ServerLoopCheckTimeouts();
+
+			/* Done if the key has been delivered. */
+			if (encryption_key_shmem->received)
+			{
+				/*
+				 * Make sure the key is read from main memory again if it had
+				 * been prefetched before processEncryptionKey() could have
+				 * written it there.
+				 */
+				pg_read_barrier();
+
+				return STATUS_OK;
+			}
+
+			/*
+			 * Do not wait for the key forever.
+			 *
+			 * Since pg_ctl sends an "empty key message" if passed no key
+			 * command, we should only get here if the cluster is being
+			 * started using a custom script which failed to send the key.
+			 */
+			if (GetCurrentTimestamp() >= wait_for_keys_until)
+				/* ok here, caller should examine the conditions in detail. */
+				return STATUS_OK;
+
+			continue;
+		}
+
 		/* If we have lost the log collector, try to start a new one */
 		if (SysLoggerPID == 0 && Logging_collector)
 			SysLoggerPID = SysLogger_Start();
@@ -1818,58 +1963,68 @@ ServerLoop(void)
 		 * us sleep at most that long; except for SIGKILL timeout which has
 		 * special-case logic there.
 		 */
-		now = time(NULL);
+		ServerLoopCheckTimeouts();
+	}
+}
 
-		/*
-		 * If we already sent SIGQUIT to children and they are slow to shut
-		 * down, it's time to send them SIGKILL.  This doesn't happen
-		 * normally, but under certain conditions backends can get stuck while
-		 * shutting down.  This is a last measure to get them unwedged.
-		 *
-		 * Note we also do this during recovery from a process crash.
-		 */
-		if ((Shutdown >= ImmediateShutdown || (FatalError && !SendStop)) &&
-			AbortStartTime != 0 &&
-			(now - AbortStartTime) >= SIGKILL_CHILDREN_AFTER_SECS)
-		{
-			/* We were gentle with them before. Not anymore */
-			TerminateChildren(SIGKILL);
-			/* reset flag so we don't SIGKILL again */
-			AbortStartTime = 0;
-		}
+/*
+ * Subroutine of ServerLoop() that checks if various timeouts elapsed, and if
+ * so, takes the appropriate action.
+ */
+static void
+ServerLoopCheckTimeouts(void)
+{
+	time_t		now = time(NULL);
 
-		/*
-		 * Once a minute, verify that postmaster.pid hasn't been removed or
-		 * overwritten.  If it has, we force a shutdown.  This avoids having
-		 * postmasters and child processes hanging around after their database
-		 * is gone, and maybe causing problems if a new database cluster is
-		 * created in the same place.  It also provides some protection
-		 * against a DBA foolishly removing postmaster.pid and manually
-		 * starting a new postmaster.  Data corruption is likely to ensue from
-		 * that anyway, but we can minimize the damage by aborting ASAP.
-		 */
-		if (now - last_lockfile_recheck_time >= 1 * SECS_PER_MINUTE)
-		{
-			if (!RecheckDataDirLockFile())
-			{
-				ereport(LOG,
-						(errmsg("performing immediate shutdown because data directory lock file is invalid")));
-				kill(MyProcPid, SIGQUIT);
-			}
-			last_lockfile_recheck_time = now;
-		}
+	/*
+	 * If we already sent SIGQUIT to children and they are slow to shut down,
+	 * it's time to send them SIGKILL.  This doesn't happen normally, but
+	 * under certain conditions backends can get stuck while shutting down.
+	 * This is a last measure to get them unwedged.
+	 *
+	 * Note we also do this during recovery from a process crash.
+	 */
+	if ((Shutdown >= ImmediateShutdown || (FatalError && !SendStop)) &&
+		AbortStartTime != 0 &&
+		(now - AbortStartTime) >= SIGKILL_CHILDREN_AFTER_SECS)
+	{
+		/* We were gentle with them before. Not anymore */
+		TerminateChildren(SIGKILL);
+		/* reset flag so we don't SIGKILL again */
+		AbortStartTime = 0;
+	}
 
-		/*
-		 * Touch Unix socket and lock files every 58 minutes, to ensure that
-		 * they are not removed by overzealous /tmp-cleaning tasks.  We assume
-		 * no one runs cleaners with cutoff times of less than an hour ...
-		 */
-		if (now - last_touch_time >= 58 * SECS_PER_MINUTE)
+	/*
+	 * Once a minute, verify that postmaster.pid hasn't been removed or
+	 * overwritten.  If it has, we force a shutdown.  This avoids having
+	 * postmasters and child processes hanging around after their database is
+	 * gone, and maybe causing problems if a new database cluster is created
+	 * in the same place.  It also provides some protection against a DBA
+	 * foolishly removing postmaster.pid and manually starting a new
+	 * postmaster.  Data corruption is likely to ensue from that anyway, but
+	 * we can minimize the damage by aborting ASAP.
+	 */
+	if (now - last_lockfile_recheck_time >= 1 * SECS_PER_MINUTE)
+	{
+		if (!RecheckDataDirLockFile())
 		{
-			TouchSocketFiles();
-			TouchSocketLockFiles();
-			last_touch_time = now;
+			ereport(LOG,
+					(errmsg("performing immediate shutdown because data directory lock file is invalid")));
+			kill(MyProcPid, SIGQUIT);
 		}
+		last_lockfile_recheck_time = now;
+	}
+
+	/*
+	 * Touch Unix socket and lock files every 58 minutes, to ensure that they
+	 * are not removed by overzealous /tmp-cleaning tasks.  We assume no one
+	 * runs cleaners with cutoff times of less than an hour ...
+	 */
+	if (now - last_touch_time >= 58 * SECS_PER_MINUTE)
+	{
+		TouchSocketFiles();
+		TouchSocketLockFiles();
+		last_touch_time = now;
 	}
 }
 
@@ -2005,6 +2160,44 @@ ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)
 		return STATUS_ERROR;
 	}
 
+#ifdef USE_ENCRYPTION
+	/*
+	 * Catch the encryption key message even if the cluster is not encrypted:
+	 * pg_ctl can send an empty message if was passed no key, just to let
+	 * postmaster know that it shouldn't wait for the key message (pg_ctl does
+	 * not know whether the cluster is encrypted). If we didn't catch it here,
+	 * this empty message would make the first started backend of the cluster
+	 * complain about "unsupported frontend protocol".
+	 */
+	if (proto == ENCRYPTION_KEY_MSG_CODE)
+	{
+		if (data_encrypted)
+		{
+			if (ssl_done || gss_done)
+				ereport(DEBUG1,
+						(errmsg_internal("receiving encryption key via SSL/GSSAPI")));
+
+			if (processEncryptionKeyMessage(buf))
+			{
+				/* Information to be displayed by init_ps_display(). */
+				port->user_name = pstrdup("<no user>");
+				port->database_name = pstrdup("<no database>");
+
+				/* This backend needs to be run specially. */
+				key_only_backend = true;
+
+				/*
+				 * processEncryptionKey() will finalize the key delivery as
+				 * soon as shared memory can be accessed.
+				 */
+				return STATUS_OK;
+			}
+		}
+
+		return STATUS_ERROR;
+	}
+#endif	/* USE_ENCRYPTION */
+
 	if (proto == NEGOTIATE_SSL_CODE && !ssl_done)
 	{
 		char		SSLok;
@@ -2442,6 +2635,127 @@ processCancelRequest(Port *port, void *pkt)
 					backendPID)));
 }
 
+#ifdef USE_ENCRYPTION
+/*
+ * Process a message from backend that contains the encryption key.
+ *
+ * If valid key message was received, either initialize the encryption_key
+ * variable or set got_empty_key_msg, and return true. In such a case,
+ * shareEncryptionKey() will put the encryption key into shared memory as soon
+ * as it's available or just set a shared memory flag saying that the message
+ * was empty. Return false if the message is invalid or if the current backend
+ * should not receive it.
+ */
+bool
+processEncryptionKeyMessage(void *pkt)
+{
+	EncryptionKeyMsg	*msg = (EncryptionKeyMsg *) pkt;
+
+	/* Backend to receive the key should not be launched otherwise. */
+	Assert(data_encrypted);
+
+	/*
+	 * The checks in shareEncryptionKey() would fire in this case too, but the
+	 * error message is clearer if this case is handled explicitly.
+	 */
+	if (pmState != PM_INIT)
+	{
+		ereport(DEBUG1,
+				(errmsg("postmaster received the encryption key message in state %d",
+						pmState)));
+		return false;
+	}
+
+	if (msg->version != 1)
+	{
+		ereport(COMMERROR,
+				(errmsg("unexpected version of encryption key message %d",
+					msg->version)));
+		return false;
+	}
+
+	/*
+	 * If pg_ctl sent an empty message, the encryption key command should have
+	 * already been read from postgresql.conf and processed.
+	 */
+	if (msg->empty)
+	{
+		got_empty_key_msg = true;
+		return true;
+	}
+
+	memcpy(encryption_key, msg->data, ENCRYPTION_KEY_LENGTH);
+
+	return true;
+}
+
+/*
+ * Put the contents of encryption_key into shared memory so that postmaster
+ * and its child processes can use it. Caller is responsible for
+ * encryption_key to have been initialized.
+ *
+ * processEncryptionKeyMessage() cannot access shared memory if EXEC_BACKEND
+ * mechanism is used so we split the key transfer into two phases. This is the
+ * second one.
+ *
+ * Currently there's no guarantee that only a single backend tries to deliver
+ * the key, but it's not worth trying to synchronize the access. If multiple
+ * callers try to process the same message, nothing should get broken. If some
+ * caller is delivering a wrong key (e.g. due to misconfiguration of another
+ * cluster), it does not help if it waits until processing of the correct key
+ * is finished.  If the key gets messed up, the worst case is that the server
+ * fails to start up. (No data corruption is expected.)
+ *
+ * To ensure that postmaster does not read the key before it's initialized, we
+ * use a memory barrier, see below.
+ *
+ * Client should not expect any response to this request: failure on client
+ * side indicates either broken connection, wrong key, bug in
+ * send_key_to_postmaster() or repeated call of the client - nothing to be
+ * handled easily by client code. Most of these failures need attention of the
+ * DBA.
+ */
+void
+shareEncryptionKey(void)
+{
+	Assert(key_only_backend);
+
+	if (got_empty_key_msg)
+	{
+		encryption_key_shmem->empty = true;
+		ereport(LOG,
+				(errmsg_internal("empty encryption key message received")));
+	}
+	else
+	{
+		/*
+		 * Check if someone else already initialized the key. This is not
+		 * fatal but seems to indicate misconfiguration which DBA should be
+		 * aware of. Check also encryption_setup_done because shared memory
+		 * could have been reset. As postmaster has a local copy of the key,
+		 * the new key should not be used, but it'd be inconsistent if we
+		 * didn't complain in this special case.
+		 */
+		if (encryption_key_shmem->received || encryption_setup_done)
+		{
+			ereport(COMMERROR,
+					(errmsg("received encryption key more than once")));
+			return;
+		}
+
+		ereport(LOG, (errmsg_internal("encryption key received")));
+		memcpy(encryption_key_shmem->data, encryption_key, ENCRYPTION_KEY_LENGTH);
+	}
+
+	/*
+	 * received==true should be a guarantee that the key is in the shared
+	 * memory or that "empty" is set.
+	 */
+	pg_write_barrier();
+	encryption_key_shmem->received = true;
+}
+#endif	/* USE_ENCRYPTION */
+
 /*
  * canAcceptConnections --- check to see if database state allows connections
  * of the specified type.  backend_type can be BACKEND_TYPE_NORMAL,
@@ -2465,7 +2779,13 @@ canAcceptConnections(int backend_type)
 		if (Shutdown > NoShutdown)
 			return CAC_SHUTDOWN;	/* shutdown is pending */
 		else if (!FatalError &&
-				 (pmState == PM_STARTUP ||
+				 /*
+				  * If the cluster is encrypted, PM_INIT should allow for
+				  * launching a special backend that merely receives the
+				  * encryption key.
+				  */
+				 ((data_encrypted && pmState == PM_INIT) ||
+				  pmState == PM_STARTUP ||
 				  pmState == PM_RECOVERY))
 			return CAC_STARTUP; /* normal startup */
 		else
@@ -2805,6 +3125,16 @@ pmdie(SIGNAL_ARGS)
 				/* There should be no clients, so proceed to stop children */
 				pmState = PM_STOP_BACKENDS;
 			}
+			else if (pmState == PM_INIT && data_encrypted &&
+					 !encryption_setup_done)
+			{
+				/*
+				 * Only backends to receive encryption key may be active now,
+				 * and these should not be involved in any transactions.
+				 */
+				SignalSomeChildren(SIGTERM, BACKEND_TYPE_NORMAL);
+				pmState = PM_WAIT_BACKENDS;
+			}
 
 			/*
 			 * Now wait for online backup mode to end and backends to exit. If
@@ -2847,6 +3177,16 @@ pmdie(SIGNAL_ARGS)
 						(errmsg("aborting any active transactions")));
 				pmState = PM_STOP_BACKENDS;
 			}
+			else if (pmState == PM_INIT && data_encrypted &&
+					 !encryption_setup_done)
+			{
+				/*
+				 * Only backends to receive encryption key may be active now,
+				 * and these should not be involved in any transactions.
+				 */
+				SignalSomeChildren(SIGTERM, BACKEND_TYPE_NORMAL);
+				pmState = PM_WAIT_BACKENDS;
+			}
 
 			/*
 			 * PostmasterStateMachine will issue any necessary signals, or
@@ -4126,6 +4466,7 @@ BackendStartup(Port *port)
 {
 	Backend    *bn;				/* for backend cleanup */
 	pid_t		pid;
+	CAC_state	cac;
 
 	/*
 	 * Create backend data structure.  Better before the fork() so we can
@@ -4156,10 +4497,15 @@ BackendStartup(Port *port)
 
 	bn->cancel_key = MyCancelKey;
 
-	/* Pass down canAcceptConnections state */
-	port->canAcceptConnections = canAcceptConnections(BACKEND_TYPE_NORMAL);
-	bn->dead_end = (port->canAcceptConnections != CAC_OK &&
-					port->canAcceptConnections != CAC_SUPERUSER);
+	/*
+	 * Pass down canAcceptConnections state.
+	 *
+	 * The special case of data_encrypted means that we might need special
+	 * backend to receive encryption key.
+	 */
+	cac = port->canAcceptConnections = canAcceptConnections(BACKEND_TYPE_NORMAL);
+	bn->dead_end = (cac != CAC_OK && cac != CAC_SUPERUSER &&
+					!(data_encrypted && cac == CAC_STARTUP));
 
 	/*
 	 * Unless it's a dead_end child, assign it a child slot number
@@ -4189,6 +4535,18 @@ BackendStartup(Port *port)
 		/* Perform additional initialization and collect startup packet */
 		BackendInitialize(port);
 
+#ifdef USE_ENCRYPTION
+		if (key_only_backend)
+		{
+			/*
+			 * Putting the encryption key into shared memory is the only thing
+			 * we're expected to do.
+			 */
+			shareEncryptionKey();
+			proc_exit(0);
+		}
+#endif	/* USE_ENCRYPTION */
+
 		/* And run the backend */
 		BackendRun(port);
 	}
@@ -5016,6 +5374,23 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores(0);
 
+#ifdef USE_ENCRYPTION
+		if (key_only_backend)
+		{
+			Assert(data_encrypted);
+
+			/*
+			 * Putting the encryption key into shared memory is the only thing
+			 * we're expected to do.
+			 */
+			shareEncryptionKey();
+			proc_exit(0);
+		}
+
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		/* And run the backend */
 		BackendRun(&port);		/* does not return */
 	}
@@ -5030,6 +5405,11 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores(0);
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		AuxiliaryProcessMain(argc - 2, argv + 2);	/* does not return */
 	}
 	if (strcmp(argv[1], "--forkavlauncher") == 0)
@@ -5043,6 +5423,12 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores(0);
 
+		/* XXX Do we need encryption here? */
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		AutoVacLauncherMain(argc - 2, argv + 2);	/* does not return */
 	}
 	if (strcmp(argv[1], "--forkavworker") == 0)
@@ -5056,6 +5442,11 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores(0);
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		AutoVacWorkerMain(argc - 2, argv + 2);	/* does not return */
 	}
 	if (strncmp(argv[1], "--forkbgworker=", 15) == 0)
@@ -5078,6 +5469,11 @@ SubPostmasterMain(int argc, char *argv[])
 		shmem_slot = atoi(argv[1] + 15);
 		MyBgworkerEntry = BackgroundWorkerEntry(shmem_slot);
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		StartBackgroundWorker();
 	}
 	if (strcmp(argv[1], "--forkarch") == 0)
@@ -5090,6 +5486,11 @@ SubPostmasterMain(int argc, char *argv[])
 	{
 		/* Do not want to attach to shared memory */
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		PgstatCollectorMain(argc, argv);	/* does not return */
 	}
 	if (strcmp(argv[1], "--forklog") == 0)
@@ -6221,6 +6622,10 @@ save_backend_variables(BackendParameters *param, Port *port,
 	param->max_safe_fds = max_safe_fds;
 
 	param->MaxBackends = MaxBackends;
+#ifdef USE_ENCRYPTION
+	param->data_encrypted = data_encrypted;
+	memcpy(param->encryption_key, encryption_key, ENCRYPTION_KEY_LENGTH);
+#endif
 
 #ifdef WIN32
 	param->PostmasterHandle = PostmasterHandle;
@@ -6457,6 +6862,11 @@ restore_backend_variables(BackendParameters *param, Port *port)
 
 	MaxBackends = param->MaxBackends;
 
+#ifdef USE_ENCRYPTION
+	data_encrypted = param->data_encrypted;
+	memcpy(encryption_key, param->encryption_key, ENCRYPTION_KEY_LENGTH);
+#endif
+
 #ifdef WIN32
 	PostmasterHandle = param->PostmasterHandle;
 	pgwin32_initial_signal_pipe = param->initial_signal_pipe;
diff --git a/src/backend/replication/basebackup.c b/src/backend/replication/basebackup.c
index 9e54e61441..4e83909b43 100644
--- a/src/backend/replication/basebackup.c
+++ b/src/backend/replication/basebackup.c
@@ -3,6 +3,7 @@
  * basebackup.c
  *	  code for taking a base backup and streaming it to a standby
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -17,7 +18,10 @@
 #include <time.h>
 
 #include "access/xlog_internal.h"	/* for pg_start/stop_backup */
+#include "catalog/pg_class.h"
+#include "catalog/pg_control.h"
 #include "catalog/pg_type.h"
+#include "common/controldata_utils.h"
 #include "common/file_perm.h"
 #include "lib/stringinfo.h"
 #include "libpq/libpq.h"
@@ -60,6 +64,9 @@ static int64 sendDir(const char *path, int basepathlen, bool sizeonly,
 static bool sendFile(const char *readfilename, const char *tarfilename,
 					 struct stat *statbuf, bool missing_ok, Oid dboid);
 static void sendFileWithContent(const char *filename, const char *content);
+static void sendFileWithContentGeneric(const char *filename,
+									   const char *content,
+									   size_t len, struct stat *statbuf);
 static int64 _tarWriteHeader(const char *filename, const char *linktarget,
 							 struct stat *statbuf, bool sizeonly);
 static int64 _tarWriteDir(const char *pathbuf, int basepathlen, struct stat *statbuf,
@@ -134,6 +141,9 @@ struct exclude_list_item
 	bool		match_prefix;
 };
 
+/* Decrypt relation files and WAL. */
+static bool decrypt = false;
+
 /*
  * The contents of these directories are removed or recreated during server
  * start so they are not included in backups.  The directories themselves are
@@ -224,6 +234,7 @@ static const struct exclude_list_item noChecksumFiles[] = {
 	{"pg_filenode.map", false},
 	{"pg_internal.init", true},
 	{"PG_VERSION", false},
+	{"kdf_params", false},
 #ifdef EXEC_BACKEND
 	{"config_exec_params", true},
 #endif
@@ -247,6 +258,10 @@ perform_base_backup(basebackup_options *opt)
 	int			datadirpathlen;
 	List	   *tablespaces = NIL;
 
+	if (decrypt && !data_encrypted)
+		ereport(NOTICE,
+				(errmsg("decryption requested but the cluster is not encrypted")));
+
 	datadirpathlen = strlen(DataDir);
 
 	backup_started_in_recovery = RecoveryInProgress();
@@ -356,7 +371,38 @@ perform_base_backup(basebackup_options *opt)
 							(errcode_for_file_access(),
 							 errmsg("could not stat file \"%s\": %m",
 									XLOG_CONTROL_FILE)));
-				sendFile(XLOG_CONTROL_FILE, XLOG_CONTROL_FILE, &statbuf, false, InvalidOid);
+
+				/*
+				 * Adjust control file if the backup is not encrypted.
+				 */
+				if (decrypt && data_encrypted)
+				{
+					ControlFileData	*cfile;
+					char	*cfile_raw;
+					bool	crc_ok;
+
+					cfile = get_controlfile(".", &crc_ok);
+					cfile->data_cipher = PG_CIPHER_NONE;
+					cfile->encryption_verification[0] = '\0';
+
+					/* Recalculate CRC of control file */
+					INIT_CRC32C(cfile->crc);
+					COMP_CRC32C(cfile->crc, (char *) cfile,
+								offsetof(ControlFileData, crc));
+					FIN_CRC32C(cfile->crc);
+
+					cfile_raw = (char *) palloc0(PG_CONTROL_FILE_SIZE);
+					memcpy(cfile_raw, cfile, sizeof(ControlFileData));
+					sendFileWithContentGeneric(XLOG_CONTROL_FILE,
+											   (char *) cfile_raw,
+											   PG_CONTROL_FILE_SIZE,
+											   &statbuf);
+					pfree(cfile);
+					pfree(cfile_raw);
+				}
+				else
+					sendFile(XLOG_CONTROL_FILE, XLOG_CONTROL_FILE, &statbuf,
+							 false, InvalidOid);
 			}
 			else
 				sendTablespace(ti->path, false);
@@ -509,6 +555,7 @@ perform_base_backup(basebackup_options *opt)
 			char		buf[TAR_SEND_SIZE];
 			size_t		cnt;
 			pgoff_t		len = 0;
+			uint32		seg_offset = 0;
 
 			snprintf(pathbuf, MAXPGPATH, XLOGDIR "/%s", walFiles[i]);
 			XLogFromFileName(walFiles[i], &tli, &segno, wal_segment_size);
@@ -552,6 +599,38 @@ perform_base_backup(basebackup_options *opt)
 								fp)) > 0)
 			{
 				CheckXLogRemoved(segno, tli);
+
+				if (decrypt && data_encrypted)
+				{
+					if (cnt % XLOG_BLCKSZ != 0)
+						ereport(ERROR,
+								(errmsg("could not decrypt page in file "
+										"\"%s\", offset %u: read buffer size "
+										"%d is not whole multiple of %d",
+										pathbuf, seg_offset, (int) cnt,
+										XLOG_BLCKSZ)));
+
+					/*
+					 * Decrypt the data, one XLOG page at a time because this
+					 * is how it was encrypted.
+					 */
+					while (seg_offset < cnt)
+					{
+						char		tweak[TWEAK_SIZE];
+						char	*data = buf + seg_offset;
+
+						XLogEncryptionTweak(tweak, tli, segno, seg_offset);
+						decrypt_block(data,
+									  data,
+									  XLOG_BLCKSZ,
+									  tweak,
+									  InvalidBlockNumber,
+									  EDK_PERMANENT);
+
+						seg_offset += XLOG_BLCKSZ;
+					}
+				}
+
 				/* Send the chunk as a CopyData message */
 				if (pq_putmessage('d', buf, cnt))
 					ereport(ERROR,
@@ -666,6 +745,7 @@ parse_basebackup_options(List *options, basebackup_options *opt)
 	bool		o_maxrate = false;
 	bool		o_tablespace_map = false;
 	bool		o_noverify_checksums = false;
+	bool		o_decrypt = false;
 
 	MemSet(opt, 0, sizeof(*opt));
 	foreach(lopt, options)
@@ -754,6 +834,15 @@ parse_basebackup_options(List *options, basebackup_options *opt)
 			noverify_checksums = true;
 			o_noverify_checksums = true;
 		}
+		else if (strcmp(defel->defname, "decrypt") == 0)
+		{
+			if (o_decrypt)
+				ereport(ERROR,
+						(errcode(ERRCODE_SYNTAX_ERROR),
+						 errmsg("duplicate option \"%s\"", defel->defname)));
+			decrypt = true;
+			o_decrypt = true;
+		}
 		else
 			elog(ERROR, "option \"%s\" not recognized",
 				 defel->defname);
@@ -937,17 +1026,10 @@ SendXlogRecPtrResult(XLogRecPtr ptr, TimeLineID tli)
 	pq_puttextmessage('C', "SELECT");
 }
 
-/*
- * Inject a file with given name and content in the output tar stream.
- */
 static void
 sendFileWithContent(const char *filename, const char *content)
 {
 	struct stat statbuf;
-	int			pad,
-				len;
-
-	len = strlen(content);
 
 	/*
 	 * Construct a stat struct for the backup_label file we're injecting in
@@ -963,9 +1045,26 @@ sendFileWithContent(const char *filename, const char *content)
 #endif
 	statbuf.st_mtime = time(NULL);
 	statbuf.st_mode = pg_file_create_mode;
-	statbuf.st_size = len;
+	statbuf.st_size = strlen(content);
+
+	sendFileWithContentGeneric(filename, content, 0, &statbuf);
+}
+
+/*
+ * Inject a file with given name and content in the output tar stream.
+ *
+ * If "len" is zero, content is considered a NULL-terminated string.
+ */
+static void
+sendFileWithContentGeneric(const char *filename, const char *content,
+						   size_t len, struct stat *statbuf)
+{
+	int			pad;
+
+	if (len == 0)
+		len = strlen(content);
 
-	_tarWriteHeader(filename, NULL, &statbuf, false);
+	_tarWriteHeader(filename, NULL, statbuf, false);
 	/* Send the contents as a CopyData message */
 	pq_putmessage('d', content, len);
 
@@ -1129,6 +1228,25 @@ sendDir(const char *path, int basepathlen, bool sizeonly, List *tablespaces,
 			}
 		}
 
+		/*
+		 * KDF_PARAMS_FILE should only be excluded if the backup will be
+		 * decrypted.
+		 */
+		if (decrypt && data_encrypted)
+		{
+			char	*fn;
+
+			fn = last_dir_separator(KDF_PARAMS_FILE);
+			Assert(fn != NULL);
+			fn++;
+
+			if (strcmp(de->d_name, fn) == 0)
+			{
+				elog(DEBUG1, "file \"%s\" excluded from backup", de->d_name);
+				excludeFound = true;
+			}
+		}
+
 		if (excludeFound)
 			continue;
 
@@ -1415,6 +1533,9 @@ sendFile(const char *readfilename, const char *tarfilename, struct stat *statbuf
 	PageHeader	phdr;
 	int			segmentno = 0;
 	char	   *segmentpath;
+	bool		decrypt_files = decrypt && data_encrypted;
+	bool	decrypt_file = false;
+	bool	verify_checksums = !noverify_checksums && DataChecksumsEnabled();
 	bool		verify_checksum = false;
 
 	fp = AllocateFile(readfilename, "rb");
@@ -1429,7 +1550,11 @@ sendFile(const char *readfilename, const char *tarfilename, struct stat *statbuf
 
 	_tarWriteHeader(tarfilename, NULL, statbuf, false);
 
-	if (!noverify_checksums && DataChecksumsEnabled())
+	/*
+	 * Encryption can be applied to pages for which checksum can be computed
+	 * and only to those.
+	 */
+	if (verify_checksums || decrypt_files)
 	{
 		char	   *filename;
 
@@ -1442,7 +1567,8 @@ sendFile(const char *readfilename, const char *tarfilename, struct stat *statbuf
 
 		if (is_checksummed_file(readfilename, filename))
 		{
-			verify_checksum = true;
+			verify_checksum = verify_checksums;
+			decrypt_file = decrypt_files;
 
 			/*
 			 * Cut off at the segment boundary (".") to get the segment number
@@ -1470,20 +1596,29 @@ sendFile(const char *readfilename, const char *tarfilename, struct stat *statbuf
 		 */
 		Assert(TAR_SEND_SIZE % BLCKSZ == 0);
 
-		if (verify_checksum && (cnt % BLCKSZ != 0))
+		if ((verify_checksum || decrypt_file) && (cnt % BLCKSZ != 0))
 		{
-			ereport(WARNING,
-					(errmsg("could not verify checksum in file \"%s\", block "
-							"%d: read buffer size %d and page size %d "
-							"differ",
-							readfilename, blkno, (int) cnt, BLCKSZ)));
+			const char	*action;
+			int	elevel;
+
+			action = verify_checksum ? "verify checksum" : "decrypt page";
+			elevel = verify_checksum ? WARNING : ERROR;
+
+			ereport(elevel,
+					(errmsg("could not %s in file \"%s\", block "
+							"%d: read buffer size %d is not whole "
+							"multiple of %d ",
+							action, readfilename, blkno, (int) cnt,
+							BLCKSZ)));
 			verify_checksum = false;
 		}
 
-		if (verify_checksum)
+		if (verify_checksum || decrypt_file)
 		{
 			for (i = 0; i < cnt / BLCKSZ; i++)
 			{
+				BlockNumber	blkno_global = blkno + segmentno * RELSEG_SIZE;
+
 				page = buf + BLCKSZ * i;
 
 				/*
@@ -1494,9 +1629,10 @@ sendFile(const char *readfilename, const char *tarfilename, struct stat *statbuf
 				 * this case. We also skip completely new pages, since they
 				 * don't have a checksum yet.
 				 */
-				if (!PageIsNew(page) && PageGetLSN(page) < startptr)
+				if (verify_checksum && !PageIsNew(page) &&
+					PageGetLSN(page) < startptr)
 				{
-					checksum = pg_checksum_page((char *) page, blkno + segmentno * RELSEG_SIZE);
+					checksum = pg_checksum_page((char *) page, blkno_global);
 					phdr = (PageHeader) page;
 					if (phdr->pd_checksum != checksum)
 					{
@@ -1575,6 +1711,26 @@ sendFile(const char *readfilename, const char *tarfilename, struct stat *statbuf
 											"be reported", readfilename)));
 					}
 				}
+
+				/*
+				 * Decrypt the page if needed.
+				 */
+				if (decrypt_file)
+				{
+					/*
+					 * The function should not be called on other than
+					 * permanent relations.
+					 */
+					decrypt_page(page, page, blkno_global,
+								 RELPERSISTENCE_PERMANENT);
+
+					/*
+					 * Compute new checksum for the decrypted page.
+					 */
+					if (DataChecksumsEnabled())
+						PageSetChecksumInplace(page, blkno_global);
+				}
+
 				block_retry = false;
 				blkno++;
 			}
diff --git a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
index dab3152e6b..4627a218d3 100644
--- a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
+++ b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
@@ -6,6 +6,7 @@
  * loaded as a dynamic module to avoid linking the main server binary with
  * libpq.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *
  *
@@ -451,6 +452,10 @@ libpqrcv_startstreaming(WalReceiverConn *conn,
 		appendStringInfo(&cmd, " TIMELINE %u",
 						 options->proto.physical.startpointTLI);
 
+	/* Request decryption of the stream if appropriate. */
+	if (!options->logical && options->proto.physical.decrypt)
+		appendStringInfo(&cmd, " DECRYPT");
+
 	/* Start streaming. */
 	res = libpqrcv_PQexec(conn->streamConn, cmd.data);
 	pfree(cmd.data);
diff --git a/src/backend/replication/logical/reorderbuffer.c b/src/backend/replication/logical/reorderbuffer.c
index 76e6cf5134..9bceb7848b 100644
--- a/src/backend/replication/logical/reorderbuffer.c
+++ b/src/backend/replication/logical/reorderbuffer.c
@@ -71,6 +71,7 @@
 #include "replication/slot.h"
 #include "replication/snapbuild.h"	/* just for SnapBuildSnapDecRefcount */
 #include "storage/bufmgr.h"
+#include "storage/buffile.h"
 #include "storage/fd.h"
 #include "storage/sinval.h"
 #include "utils/builtins.h"
@@ -103,21 +104,13 @@ typedef struct ReorderBufferTupleCidEnt
 	CommandId	combocid;		/* just for debugging */
 } ReorderBufferTupleCidEnt;
 
-/* Virtual file descriptor with file offset tracking */
-typedef struct TXNEntryFile
-{
-	File		vfd;			/* -1 when the file is closed */
-	off_t		curOffset;		/* offset for next write or read. Reset to 0
-								 * when vfd is opened. */
-} TXNEntryFile;
-
 /* k-way in-order change iteration support structures */
 typedef struct ReorderBufferIterTXNEntry
 {
 	XLogRecPtr	lsn;
 	ReorderBufferChange *change;
 	ReorderBufferTXN *txn;
-	TXNEntryFile file;
+	TransientBufFile *file;
 	XLogSegNo	segno;
 } ReorderBufferIterTXNEntry;
 
@@ -198,14 +191,22 @@ static void ReorderBufferExecuteInvalidations(ReorderBuffer *rb, ReorderBufferTX
  * Disk serialization support functions
  * ---------------------------------------
  */
+static void ReorderBufferTweakBase(ReorderBufferTXN *txn,
+								   char tweak_base[TWEAK_BASE_SIZE]);
 static void ReorderBufferCheckSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn);
 static void ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn);
 static void ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-										 int fd, ReorderBufferChange *change);
+							 TransientBufFile *file, ReorderBufferChange *change);
+static void ReorderBufferWriteData(TransientBufFile *file, void *ptr, size_t size,
+					   ReorderBufferTXN *txn);
 static Size ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
-										TXNEntryFile *file, XLogSegNo *segno);
+							TransientBufFile **file, XLogSegNo *segno);
 static void ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-									   char *change);
+						   TransientBufFile **file);
+static ReorderBufferTupleBuf *ReorderBufferRestoreTuple(ReorderBuffer *rb,
+						  TransientBufFile *file);
+static void ReorderBufferReadData(TransientBufFile *file, void *ptr, size_t size,
+					  bool *no_data_p);
 static void ReorderBufferRestoreCleanup(ReorderBuffer *rb, ReorderBufferTXN *txn);
 static void ReorderBufferCleanupSerializedTXNs(const char *slotname);
 static void ReorderBufferSerializedPath(char *path, ReplicationSlot *slot,
@@ -276,9 +277,6 @@ ReorderBufferAllocate(void)
 	buffer->by_txn_last_xid = InvalidTransactionId;
 	buffer->by_txn_last_txn = NULL;
 
-	buffer->outbuf = NULL;
-	buffer->outbufsize = 0;
-
 	buffer->current_restart_decoding_lsn = InvalidXLogRecPtr;
 
 	dlist_init(&buffer->toplevel_by_lsn);
@@ -1020,7 +1018,7 @@ ReorderBufferIterTXNInit(ReorderBuffer *rb, ReorderBufferTXN *txn,
 
 	for (off = 0; off < state->nr_txns; off++)
 	{
-		state->entries[off].file.vfd = -1;
+		state->entries[off].file = NULL;
 		state->entries[off].segno = 0;
 	}
 
@@ -1196,8 +1194,8 @@ ReorderBufferIterTXNFinish(ReorderBuffer *rb,
 
 	for (off = 0; off < state->nr_txns; off++)
 	{
-		if (state->entries[off].file.vfd != -1)
-			FileClose(state->entries[off].file.vfd);
+		if (state->entries[off].file)
+			BufFileCloseTransient(state->entries[off].file);
 	}
 
 	/* free memory we might have "leaked" in the last *Next call */
@@ -2250,21 +2248,39 @@ ReorderBufferXidHasBaseSnapshot(ReorderBuffer *rb, TransactionId xid)
  */
 
 /*
- * Ensure the IO buffer is >= sz.
+ * Initialize the common part of the encryption tweak.
  */
 static void
-ReorderBufferSerializeReserve(ReorderBuffer *rb, Size sz)
+ReorderBufferTweakBase(ReorderBufferTXN *txn,
+					   char tweak_base[TWEAK_BASE_SIZE])
 {
-	if (!rb->outbufsize)
-	{
-		rb->outbuf = MemoryContextAlloc(rb->context, sz);
-		rb->outbufsize = sz;
-	}
-	else if (rb->outbufsize < sz)
-	{
-		rb->outbuf = repalloc(rb->outbuf, sz);
-		rb->outbufsize = sz;
-	}
+	char	*c = tweak_base;
+	pid_t	pid = MyProcPid;
+	int	pid_bytes;
+
+/* Only this part of the PID fits into the tweak. */
+#define PID_BYTES_USABLE	3
+
+	StaticAssertStmt(1 + sizeof(TransactionId) + PID_BYTES_USABLE
+					 <= TWEAK_BASE_SIZE,
+					 "tweak components do not fit into TWEAK_BASE_SIZE");
+
+	memset(tweak_base, 0, TWEAK_BASE_SIZE);
+	*c = TRANS_BUF_FILE_REORDERBUFFER;
+	c++;
+	memcpy(c, &txn->xid, sizeof(TransactionId));
+	c += sizeof(TransactionId);
+
+	/*
+	 * There's only room for PID_BYTES_USABLE bytes of the PID. Use the less
+	 * significant part so that PID increment always causes tweak change.
+	 */
+	pid_bytes = Min(sizeof(pid), PID_BYTES_USABLE);
+#ifdef WORDS_BIGENDIAN
+	memcpy(c, ((char *) &pid) + sizeof(pid) - pid_bytes, pid_bytes);
+#else
+	memcpy(c, &pid, pid_bytes);
+#endif
 }
 
 /*
@@ -2292,7 +2308,7 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 {
 	dlist_iter	subtxn_i;
 	dlist_mutable_iter change_i;
-	int			fd = -1;
+	TransientBufFile *file = NULL;
 	XLogSegNo	curOpenSegNo = 0;
 	Size		spilled = 0;
 
@@ -2319,13 +2335,14 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 		 * store in segment in which it belongs by start lsn, don't split over
 		 * multiple segments tho
 		 */
-		if (fd == -1 ||
+		if (file == NULL ||
 			!XLByteInSeg(change->lsn, curOpenSegNo, wal_segment_size))
 		{
 			char		path[MAXPGPATH];
+			char		tweak_base[TWEAK_BASE_SIZE];
 
-			if (fd != -1)
-				CloseTransientFile(fd);
+			if (file)
+				BufFileCloseTransient(file);
 
 			XLByteToSeg(change->lsn, curOpenSegNo, wal_segment_size);
 
@@ -2336,17 +2353,16 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 			ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,
 										curOpenSegNo);
 
+			if (data_encrypted)
+				ReorderBufferTweakBase(txn, tweak_base);
 			/* open segment, create it if necessary */
-			fd = OpenTransientFile(path,
-								   O_CREAT | O_WRONLY | O_APPEND | PG_BINARY);
-
-			if (fd < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not open file \"%s\": %m", path)));
+			file = BufFileOpenTransient(path,
+										O_CREAT | O_WRONLY | O_APPEND | PG_BINARY,
+										tweak_base,
+										ERROR);
 		}
 
-		ReorderBufferSerializeChange(rb, txn, fd, change);
+		ReorderBufferSerializeChange(rb, txn, file, change);
 		dlist_delete(&change->node);
 		ReorderBufferReturnChange(rb, change);
 
@@ -2358,8 +2374,8 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 	txn->nentries_mem = 0;
 	txn->serialized = true;
 
-	if (fd != -1)
-		CloseTransientFile(fd);
+	if (file)
+		BufFileCloseTransient(file);
 }
 
 /*
@@ -2367,15 +2383,13 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
  */
 static void
 ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-							 int fd, ReorderBufferChange *change)
+							 TransientBufFile *file, ReorderBufferChange *change)
 {
-	ReorderBufferDiskChange *ondisk;
+	ReorderBufferDiskChange hdr;
 	Size		sz = sizeof(ReorderBufferDiskChange);
 
-	ReorderBufferSerializeReserve(rb, sz);
-
-	ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-	memcpy(&ondisk->change, change, sizeof(ReorderBufferChange));
+	memcpy((char *) &hdr + offsetof(ReorderBufferDiskChange, change),
+		   change, sizeof(ReorderBufferChange));
 
 	switch (change->action)
 	{
@@ -2385,7 +2399,6 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 		case REORDER_BUFFER_CHANGE_DELETE:
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:
 			{
-				char	   *data;
 				ReorderBufferTupleBuf *oldtup,
 						   *newtup;
 				Size		oldlen = 0;
@@ -2408,66 +2421,55 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 					sz += newlen;
 				}
 
-				/* make sure we have enough space */
-				ReorderBufferSerializeReserve(rb, sz);
-
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr, sizeof(ReorderBufferDiskChange),
+									   txn);
 
 				if (oldlen)
 				{
-					memcpy(data, &oldtup->tuple, sizeof(HeapTupleData));
-					data += sizeof(HeapTupleData);
-
-					memcpy(data, oldtup->tuple.t_data, oldlen);
-					data += oldlen;
+					ReorderBufferWriteData(file, &oldtup->tuple,
+										   sizeof(HeapTupleData), txn);
+					ReorderBufferWriteData(file, oldtup->tuple.t_data, oldlen,
+										   txn);
 				}
 
 				if (newlen)
 				{
-					memcpy(data, &newtup->tuple, sizeof(HeapTupleData));
-					data += sizeof(HeapTupleData);
-
-					memcpy(data, newtup->tuple.t_data, newlen);
-					data += newlen;
+					ReorderBufferWriteData(file, &newtup->tuple,
+										   sizeof(HeapTupleData), txn);
+					ReorderBufferWriteData(file, newtup->tuple.t_data, newlen,
+										   txn);
 				}
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_MESSAGE:
 			{
-				char	   *data;
 				Size		prefix_size = strlen(change->data.msg.prefix) + 1;
 
 				sz += prefix_size + change->data.msg.message_size +
 					sizeof(Size) + sizeof(Size);
-				ReorderBufferSerializeReserve(rb, sz);
-
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
 
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr,
+									   sizeof(ReorderBufferDiskChange),
+									   txn);
 
 				/* write the prefix including the size */
-				memcpy(data, &prefix_size, sizeof(Size));
-				data += sizeof(Size);
-				memcpy(data, change->data.msg.prefix,
-					   prefix_size);
-				data += prefix_size;
+				ReorderBufferWriteData(file, &prefix_size, sizeof(Size), txn);
+				ReorderBufferWriteData(file, change->data.msg.prefix,
+									   prefix_size, txn);
 
 				/* write the message including the size */
-				memcpy(data, &change->data.msg.message_size, sizeof(Size));
-				data += sizeof(Size);
-				memcpy(data, change->data.msg.message,
-					   change->data.msg.message_size);
-				data += change->data.msg.message_size;
+				ReorderBufferWriteData(file, &change->data.msg.message_size,
+									   sizeof(Size), txn);
+				ReorderBufferWriteData(file, change->data.msg.message,
+									   change->data.msg.message_size, txn);
 
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:
 			{
 				Snapshot	snap;
-				char	   *data;
 
 				snap = change->data.snapshot;
 
@@ -2475,78 +2477,50 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 					sizeof(TransactionId) * snap->xcnt +
 					sizeof(TransactionId) * snap->subxcnt;
 
-				/* make sure we have enough space */
-				ReorderBufferSerializeReserve(rb, sz);
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr,
+									   sizeof(ReorderBufferDiskChange), txn);
 
-				memcpy(data, snap, sizeof(SnapshotData));
-				data += sizeof(SnapshotData);
+				ReorderBufferWriteData(file, snap, sizeof(SnapshotData), txn);
 
 				if (snap->xcnt)
-				{
-					memcpy(data, snap->xip,
-						   sizeof(TransactionId) * snap->xcnt);
-					data += sizeof(TransactionId) * snap->xcnt;
-				}
+					ReorderBufferWriteData(file, snap->xip,
+										   sizeof(TransactionId) * snap->xcnt,
+										   txn);
 
 				if (snap->subxcnt)
-				{
-					memcpy(data, snap->subxip,
-						   sizeof(TransactionId) * snap->subxcnt);
-					data += sizeof(TransactionId) * snap->subxcnt;
-				}
+					ReorderBufferWriteData(file, snap->subxip,
+										   sizeof(TransactionId) * snap->subxcnt,
+										   txn);
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_TRUNCATE:
 			{
 				Size		size;
-				char	   *data;
 
 				/* account for the OIDs of truncated relations */
 				size = sizeof(Oid) * change->data.truncate.nrelids;
 				sz += size;
 
-				/* make sure we have enough space */
-				ReorderBufferSerializeReserve(rb, sz);
-
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-
-				memcpy(data, change->data.truncate.relids, size);
-				data += size;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr, sizeof(ReorderBufferDiskChange),
+									   txn);
 
+				ReorderBufferWriteData(file, change->data.truncate.relids, size,
+									   txn);
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:
 		case REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:
 		case REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:
+			hdr.size = sz;
+			ReorderBufferWriteData(file, &hdr, sizeof(ReorderBufferDiskChange),
+								   txn);
 			/* ReorderBufferChange contains everything important */
 			break;
 	}
 
-	ondisk->size = sz;
-
-	errno = 0;
-	pgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE);
-	if (write(fd, rb->outbuf, ondisk->size) != ondisk->size)
-	{
-		int			save_errno = errno;
-
-		CloseTransientFile(fd);
-
-		/* if write didn't set errno, assume problem is no disk space */
-		errno = save_errno ? save_errno : ENOSPC;
-		ereport(ERROR,
-				(errcode_for_file_access(),
-				 errmsg("could not write to data file for XID %u: %m",
-						txn->xid)));
-	}
-	pgstat_report_wait_end();
-
 	/*
 	 * Keep the transaction's final_lsn up to date with each change we send to
 	 * disk, so that ReorderBufferRestoreCleanup works correctly.  (We used to
@@ -2557,8 +2531,21 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 	 */
 	if (txn->final_lsn < change->lsn)
 		txn->final_lsn = change->lsn;
+}
 
-	Assert(ondisk->change.action == change->action);
+/*
+ * Wrapper for BufFileWriteTransient() that raises ERROR if the whole chunk
+ * was not written. XXX Should this be a macro?
+ */
+static void
+ReorderBufferWriteData(TransientBufFile *file, void *ptr, size_t size,
+					   ReorderBufferTXN *txn)
+{
+	if (BufFileWriteTransient(file, ptr, size) != size)
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not write to data file for XID %u: %m",
+						txn->xid)));
 }
 
 /*
@@ -2566,12 +2553,11 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
  */
 static Size
 ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
-							TXNEntryFile *file, XLogSegNo *segno)
+							TransientBufFile **file, XLogSegNo *segno)
 {
 	Size		restored = 0;
 	XLogSegNo	last_segno;
 	dlist_mutable_iter cleanup_iter;
-	File	   *fd = &file->vfd;
 
 	Assert(txn->first_lsn != InvalidXLogRecPtr);
 	Assert(txn->final_lsn != InvalidXLogRecPtr);
@@ -2592,14 +2578,12 @@ ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
 
 	while (restored < max_changes_in_memory && *segno <= last_segno)
 	{
-		int			readBytes;
-		ReorderBufferDiskChange *ondisk;
-
 		CHECK_FOR_INTERRUPTS();
 
-		if (*fd == -1)
+		if (*file == NULL)
 		{
 			char		path[MAXPGPATH];
+			char		tweak_base[TWEAK_BASE_SIZE];
 
 			/* first time in */
 			if (*segno == 0)
@@ -2614,86 +2598,28 @@ ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
 			ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,
 										*segno);
 
-			*fd = PathNameOpenFile(path, O_RDONLY | PG_BINARY);
-
-			/* No harm in resetting the offset even in case of failure */
-			file->curOffset = 0;
-
-			if (*fd < 0 && errno == ENOENT)
+			if (data_encrypted)
+				ReorderBufferTweakBase(txn, tweak_base);
+			*file = BufFileOpenTransient(path, O_RDONLY | PG_BINARY,
+										 tweak_base,
+										 ERROR);
+			if (*file == NULL)
 			{
-				*fd = -1;
+				Assert(errno == ENOENT);
 				(*segno)++;
 				continue;
 			}
-			else if (*fd < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not open file \"%s\": %m",
-								path)));
 		}
 
-		/*
-		 * Read the statically sized part of a change which has information
-		 * about the total size. If we couldn't read a record, we're at the
-		 * end of this file.
-		 */
-		ReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange));
-		readBytes = FileRead(file->vfd, rb->outbuf,
-							 sizeof(ReorderBufferDiskChange),
-							 file->curOffset, WAIT_EVENT_REORDER_BUFFER_READ);
-
-		/* eof */
-		if (readBytes == 0)
+		ReorderBufferRestoreChange(rb, txn, file);
+		if (*file)
+			restored++;
+		else
 		{
-			FileClose(*fd);
-			*fd = -1;
+			/* No data could be restored. */
 			(*segno)++;
 			continue;
 		}
-		else if (readBytes < 0)
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: %m")));
-		else if (readBytes != sizeof(ReorderBufferDiskChange))
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: read %d instead of %u bytes",
-							readBytes,
-							(uint32) sizeof(ReorderBufferDiskChange))));
-
-		file->curOffset += readBytes;
-
-		ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-
-		ReorderBufferSerializeReserve(rb,
-									  sizeof(ReorderBufferDiskChange) + ondisk->size);
-		ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-
-		readBytes = FileRead(file->vfd,
-							 rb->outbuf + sizeof(ReorderBufferDiskChange),
-							 ondisk->size - sizeof(ReorderBufferDiskChange),
-							 file->curOffset,
-							 WAIT_EVENT_REORDER_BUFFER_READ);
-
-		if (readBytes < 0)
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: %m")));
-		else if (readBytes != ondisk->size - sizeof(ReorderBufferDiskChange))
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: read %d instead of %u bytes",
-							readBytes,
-							(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))));
-
-		file->curOffset += readBytes;
-
-		/*
-		 * ok, read a full change from disk, now restore it into proper
-		 * in-memory format
-		 */
-		ReorderBufferRestoreChange(rb, txn, rb->outbuf);
-		restored++;
 	}
 
 	return restored;
@@ -2703,25 +2629,36 @@ ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
  * Convert change from its on-disk format to in-memory format and queue it onto
  * the TXN's ->changes list.
  *
- * Note: although "data" is declared char*, at entry it points to a
- * maxalign'd buffer, making it safe in most of this function to assume
- * that the pointed-to data is suitably aligned for direct access.
+ * If no data was found in the file, close it and set *file to NULL.
  */
 static void
 ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-						   char *data)
+						   TransientBufFile **file)
 {
-	ReorderBufferDiskChange *ondisk;
+	ReorderBufferDiskChange ondisk;
+	bool		no_data;
 	ReorderBufferChange *change;
 
-	ondisk = (ReorderBufferDiskChange *) data;
+	/*
+	 * Read the statically sized part of a change which has information about
+	 * the total size. If we couldn't read a record, we're at the end of this
+	 * file.
+	 */
+	ReorderBufferReadData(*file, &ondisk, sizeof(ReorderBufferDiskChange),
+						  &no_data);
+
+	/* eof */
+	if (no_data)
+	{
+		BufFileCloseTransient(*file);
+		*file = NULL;
+		return;
+	}
 
 	change = ReorderBufferGetChange(rb);
 
 	/* copy static part */
-	memcpy(change, &ondisk->change, sizeof(ReorderBufferChange));
-
-	data += sizeof(ReorderBufferDiskChange);
+	memcpy(change, &ondisk.change, sizeof(ReorderBufferChange));
 
 	/* restore individual stuff */
 	switch (change->action)
@@ -2732,50 +2669,10 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 		case REORDER_BUFFER_CHANGE_DELETE:
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:
 			if (change->data.tp.oldtuple)
-			{
-				uint32		tuplelen = ((HeapTuple) data)->t_len;
-
-				change->data.tp.oldtuple =
-					ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);
-
-				/* restore ->tuple */
-				memcpy(&change->data.tp.oldtuple->tuple, data,
-					   sizeof(HeapTupleData));
-				data += sizeof(HeapTupleData);
-
-				/* reset t_data pointer into the new tuplebuf */
-				change->data.tp.oldtuple->tuple.t_data =
-					ReorderBufferTupleBufData(change->data.tp.oldtuple);
-
-				/* restore tuple data itself */
-				memcpy(change->data.tp.oldtuple->tuple.t_data, data, tuplelen);
-				data += tuplelen;
-			}
+				change->data.tp.oldtuple = ReorderBufferRestoreTuple(rb, *file);
 
 			if (change->data.tp.newtuple)
-			{
-				/* here, data might not be suitably aligned! */
-				uint32		tuplelen;
-
-				memcpy(&tuplelen, data + offsetof(HeapTupleData, t_len),
-					   sizeof(uint32));
-
-				change->data.tp.newtuple =
-					ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);
-
-				/* restore ->tuple */
-				memcpy(&change->data.tp.newtuple->tuple, data,
-					   sizeof(HeapTupleData));
-				data += sizeof(HeapTupleData);
-
-				/* reset t_data pointer into the new tuplebuf */
-				change->data.tp.newtuple->tuple.t_data =
-					ReorderBufferTupleBufData(change->data.tp.newtuple);
-
-				/* restore tuple data itself */
-				memcpy(change->data.tp.newtuple->tuple.t_data, data, tuplelen);
-				data += tuplelen;
-			}
+				change->data.tp.newtuple = ReorderBufferRestoreTuple(rb, *file);
 
 			break;
 		case REORDER_BUFFER_CHANGE_MESSAGE:
@@ -2783,44 +2680,44 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 				Size		prefix_size;
 
 				/* read prefix */
-				memcpy(&prefix_size, data, sizeof(Size));
-				data += sizeof(Size);
+				ReorderBufferReadData(*file, &prefix_size, sizeof(Size), NULL);
 				change->data.msg.prefix = MemoryContextAlloc(rb->context,
 															 prefix_size);
-				memcpy(change->data.msg.prefix, data, prefix_size);
+				ReorderBufferReadData(*file, change->data.msg.prefix,
+									  prefix_size, NULL);
 				Assert(change->data.msg.prefix[prefix_size - 1] == '\0');
-				data += prefix_size;
 
 				/* read the message */
-				memcpy(&change->data.msg.message_size, data, sizeof(Size));
-				data += sizeof(Size);
+				ReorderBufferReadData(*file, &change->data.msg.message_size,
+									  sizeof(Size), NULL);
 				change->data.msg.message = MemoryContextAlloc(rb->context,
 															  change->data.msg.message_size);
-				memcpy(change->data.msg.message, data,
-					   change->data.msg.message_size);
-				data += change->data.msg.message_size;
+				ReorderBufferReadData(*file, change->data.msg.message,
+									  change->data.msg.message_size, NULL);
 
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:
 			{
-				Snapshot	oldsnap;
+				SnapshotData oldsnap;
 				Snapshot	newsnap;
 				Size		size;
 
-				oldsnap = (Snapshot) data;
+				ReorderBufferReadData(*file, &oldsnap, sizeof(SnapshotData), NULL);
 
 				size = sizeof(SnapshotData) +
-					sizeof(TransactionId) * oldsnap->xcnt +
-					sizeof(TransactionId) * (oldsnap->subxcnt + 0);
+					sizeof(TransactionId) * oldsnap.xcnt +
+					sizeof(TransactionId) * (oldsnap.subxcnt + 0);
 
 				change->data.snapshot = MemoryContextAllocZero(rb->context, size);
 
 				newsnap = change->data.snapshot;
 
-				memcpy(newsnap, data, size);
+				memcpy(newsnap, &oldsnap, sizeof(SnapshotData));
 				newsnap->xip = (TransactionId *)
 					(((char *) newsnap) + sizeof(SnapshotData));
+				ReorderBufferReadData(*file, newsnap->xip,
+									  size - sizeof(SnapshotData), NULL);
 				newsnap->subxip = newsnap->xip + newsnap->xcnt;
 				newsnap->copied = true;
 				break;
@@ -2832,7 +2729,9 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 
 				relids = ReorderBufferGetRelids(rb,
 												change->data.truncate.nrelids);
-				memcpy(relids, data, change->data.truncate.nrelids * sizeof(Oid));
+				ReorderBufferReadData(*file, relids,
+									  change->data.truncate.nrelids * sizeof(Oid),
+									  NULL);
 				change->data.truncate.relids = relids;
 
 				break;
@@ -2848,6 +2747,77 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 	txn->nentries_mem++;
 }
 
+/*
+ * Convert heap tuple from its on-disk format to in-memory format.
+ */
+static ReorderBufferTupleBuf *
+ReorderBufferRestoreTuple(ReorderBuffer *rb, TransientBufFile *file)
+{
+	HeapTupleData tupdata;
+	uint32		tuplelen;
+	ReorderBufferTupleBuf *result;
+
+	ReorderBufferReadData(file, &tupdata, sizeof(HeapTupleData), NULL);
+	tuplelen = tupdata.t_len;
+
+	result = ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);
+
+	/* restore ->tuple */
+	memcpy(&result->tuple, &tupdata, sizeof(HeapTupleData));
+
+	/* reset t_data pointer into the new tuplebuf */
+	result->tuple.t_data = ReorderBufferTupleBufData(result);
+
+	/* restore tuple data itself */
+	ReorderBufferReadData(file, result->tuple.t_data, tuplelen, NULL);
+
+	return result;
+}
+
+/*
+ * Wrapper for BufFileReadTransient() that raises ERROR if the expected amount
+ * of bytes was not read.
+ *
+ * If valid pointer is passed for no_data_p, set *no_data_p to indicate
+ * whether zero bytes was read. If NULL is passed, do not tolerate missing
+ * data.
+ */
+static void
+ReorderBufferReadData(TransientBufFile *file, void *ptr, size_t size,
+					  bool *no_data_p)
+{
+	int			readBytes;
+
+	/*
+	 * Caller should not request zero bytes. This assumption simplifies
+	 * setting of *no_data_p below.
+	 */
+	Assert(size > 0);
+
+	if ((readBytes = BufFileReadTransient(file, ptr, size)) != size)
+	{
+		if (no_data_p)
+			*no_data_p = readBytes == 0;
+
+		/*
+		 * It is o.k. to receive exactly zero bytes if caller passed valid
+		 * no_data_p.
+		 */
+		if (no_data_p && *no_data_p)
+			return;
+
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not read from reorderbuffer spill file: read %d instead of %u bytes",
+						readBytes, (uint32) size)));
+	}
+	else if (no_data_p)
+	{
+		/* Given that size is non-zero, readBytes must be non-zero too. */
+		*no_data_p = false;
+	}
+}
+
 /*
  * Remove all on-disk stored for the passed in transaction.
  */
diff --git a/src/backend/replication/repl_gram.y b/src/backend/replication/repl_gram.y
index fc28334808..1e9a8fa571 100644
--- a/src/backend/replication/repl_gram.y
+++ b/src/backend/replication/repl_gram.y
@@ -3,6 +3,7 @@
  *
  * repl_gram.y				- Parser for the replication commands
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -75,6 +76,7 @@ Node *replication_parse_result;
 %token K_WAL
 %token K_TABLESPACE_MAP
 %token K_NOVERIFY_CHECKSUMS
+%token K_DECRYPT
 %token K_TIMELINE
 %token K_PHYSICAL
 %token K_LOGICAL
@@ -92,6 +94,7 @@ Node *replication_parse_result;
 %type <list>	base_backup_opt_list
 %type <defelt>	base_backup_opt
 %type <uintval>	opt_timeline
+%type <boolval> opt_decrypt
 %type <list>	plugin_options plugin_opt_list
 %type <defelt>	plugin_opt_elem
 %type <node>	plugin_opt_arg
@@ -151,7 +154,7 @@ var_name:	IDENT	{ $$ = $1; }
 
 /*
  * BASE_BACKUP [LABEL '<label>'] [PROGRESS] [FAST] [WAL] [NOWAIT]
- * [MAX_RATE %d] [TABLESPACE_MAP] [NOVERIFY_CHECKSUMS]
+ * [MAX_RATE %d] [TABLESPACE_MAP] [NOVERIFY_CHECKSUMS] [DECRYPT]
  */
 base_backup:
 			K_BASE_BACKUP base_backup_opt_list
@@ -210,6 +213,11 @@ base_backup_opt:
 				  $$ = makeDefElem("noverify_checksums",
 								   (Node *)makeInteger(true), -1);
 				}
+			| K_DECRYPT
+				{
+				  $$ = makeDefElem("decrypt",
+								   (Node *)makeInteger(true), -1);
+				}
 			;
 
 create_replication_slot:
@@ -289,10 +297,10 @@ drop_replication_slot:
 			;
 
 /*
- * START_REPLICATION [SLOT slot] [PHYSICAL] %X/%X [TIMELINE %d]
+ * START_REPLICATION [SLOT slot] [PHYSICAL] %X/%X [TIMELINE %d] [DECRYPT]
  */
 start_replication:
-			K_START_REPLICATION opt_slot opt_physical RECPTR opt_timeline
+			K_START_REPLICATION opt_slot opt_physical RECPTR opt_timeline opt_decrypt
 				{
 					StartReplicationCmd *cmd;
 
@@ -301,6 +309,7 @@ start_replication:
 					cmd->slotname = $2;
 					cmd->startpoint = $4;
 					cmd->timeline = $5;
+					cmd->decrypt = $6;
 					$$ = (Node *) cmd;
 				}
 			;
@@ -367,6 +376,10 @@ opt_timeline:
 				| /* EMPTY */			{ $$ = 0; }
 			;
 
+opt_decrypt:
+			K_DECRYPT						{ $$ = true; }
+			| /* EMPTY */					{ $$ = false; }
+			;
 
 plugin_options:
 			'(' plugin_opt_list ')'			{ $$ = $2; }
diff --git a/src/backend/replication/repl_scanner.l b/src/backend/replication/repl_scanner.l
index 05bf1762ad..28d5ff3365 100644
--- a/src/backend/replication/repl_scanner.l
+++ b/src/backend/replication/repl_scanner.l
@@ -4,6 +4,7 @@
  * repl_scanner.l
  *	  a lexical scanner for the replication commands
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -118,6 +119,7 @@ MAX_RATE		{ return K_MAX_RATE; }
 WAL			{ return K_WAL; }
 TABLESPACE_MAP			{ return K_TABLESPACE_MAP; }
 NOVERIFY_CHECKSUMS	{ return K_NOVERIFY_CHECKSUMS; }
+DECRYPT	{ return K_DECRYPT; }
 TIMELINE			{ return K_TIMELINE; }
 START_REPLICATION	{ return K_START_REPLICATION; }
 CREATE_REPLICATION_SLOT		{ return K_CREATE_REPLICATION_SLOT; }
diff --git a/src/backend/replication/walreceiver.c b/src/backend/replication/walreceiver.c
index 441af76c0f..ef9f7eef88 100644
--- a/src/backend/replication/walreceiver.c
+++ b/src/backend/replication/walreceiver.c
@@ -33,6 +33,7 @@
  * specific parts are in the libpqwalreceiver module. It's loaded
  * dynamically to avoid linking the server with libpq.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *
  *
@@ -315,6 +316,15 @@ WalReceiverMain(void)
 		 */
 		primary_sysid = walrcv_identify_system(wrconn, &primaryTLI);
 
+		/*
+		 * If we (the slave) are not encrypted, ask master to decrypt the data
+		 * - it will just ignore the decryption if it's unencrypted too. If we
+		 * are encrypted, we expect the primary to be encrypted too, using the
+		 * same key - it'd be too tricky to ask the primary to (re)encrypt
+		 * data using particular key.
+		 */
+		options.proto.physical.decrypt = !data_encrypted;
+
 		snprintf(standby_sysid, sizeof(standby_sysid), UINT64_FORMAT,
 				 GetSystemIdentifier());
 		if (strcmp(primary_sysid, standby_sysid) != 0)
diff --git a/src/backend/replication/walsender.c b/src/backend/replication/walsender.c
index c2c0c7df43..ffd730f11d 100644
--- a/src/backend/replication/walsender.c
+++ b/src/backend/replication/walsender.c
@@ -37,6 +37,7 @@
  * record, wait for it to be replicated to the standby, and then exit.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -77,6 +78,7 @@
 #include "replication/walsender.h"
 #include "replication/walsender_private.h"
 #include "storage/condition_variable.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
 #include "storage/pmsignal.h"
@@ -257,7 +259,9 @@ static void LagTrackerWrite(XLogRecPtr lsn, TimestampTz local_flush_time);
 static TimeOffset LagTrackerRead(int head, XLogRecPtr lsn, TimestampTz now);
 static bool TransactionIdInRecentPast(TransactionId xid, uint32 epoch);
 
-static void XLogRead(char *buf, XLogRecPtr startptr, Size count);
+static int	XLogReadBuffer(char *buf, int nbytes, int startoff);
+static void XLogRead(char *buf, XLogRecPtr startptr, Size count,
+		 bool decrypt);
 
 
 /* Initialize walsender process before entering the main command loop */
@@ -535,6 +539,8 @@ SendTimeLineHistory(TimeLineHistoryCmd *cmd)
 	pq_endmessage(&buf);
 }
 
+static bool decrypt_stream = false;
+
 /*
  * Handle START_REPLICATION command.
  *
@@ -699,6 +705,20 @@ StartReplication(StartReplicationCmd *cmd)
 		/* Main loop of walsender */
 		replication_active = true;
 
+		if (cmd->decrypt)
+		{
+			if (data_encrypted)
+				decrypt_stream = true;
+			else
+			{
+				ereport(NOTICE,
+						(errmsg("decryption requested but the cluster is not encrypted")));
+				decrypt_stream = false;
+			}
+		}
+		else
+			decrypt_stream = false;
+
 		WalSndLoop(XLogSendPhysical);
 
 		replication_active = false;
@@ -792,7 +812,7 @@ logical_read_xlog_page(XLogReaderState *state, XLogRecPtr targetPagePtr, int req
 		count = flushptr - targetPagePtr;	/* part of the page available */
 
 	/* now actually read the data, we know it's there */
-	XLogRead(cur_page, targetPagePtr, XLOG_BLCKSZ);
+	XLogRead(cur_page, targetPagePtr, XLOG_BLCKSZ, data_encrypted);
 
 	return count;
 }
@@ -2387,19 +2407,53 @@ WalSndKill(int code, Datum arg)
 	SpinLockRelease(&walsnd->mutex);
 }
 
+static int
+XLogReadBuffer(char *buf, int nbytes, int startoff)
+{
+	int			readbytes;
+
+	/* Need to seek in the file? */
+	if (sendOff != startoff)
+	{
+		if (lseek(sendFile, (off_t) startoff, SEEK_SET) < 0)
+			ereport(ERROR,
+					(errcode_for_file_access(),
+					 errmsg("could not seek in log segment %s to offset %u: %m",
+							XLogFileNameP(curFileTimeLine, sendSegNo),
+							startoff)));
+		sendOff = startoff;
+	}
+
+	pgstat_report_wait_start(WAIT_EVENT_WAL_READ);
+	readbytes = read(sendFile, buf, nbytes);
+	pgstat_report_wait_end();
+	if (readbytes <= 0)
+	{
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not read from log segment %s, offset %u, length %lu: %m",
+						XLogFileNameP(curFileTimeLine, sendSegNo),
+						sendOff, (unsigned long) nbytes)));
+	}
+
+	return readbytes;
+}
+
 /*
- * Read 'count' bytes from WAL into 'buf', starting at location 'startptr'
+ * Read 'count' bytes from WAL into 'buf', starting at location
+ * 'startptr'. Decrypt the data if it's encrypted and if caller wants it
+ * decrypted.
  *
- * XXX probably this should be improved to suck data directly from the
- * WAL buffers when possible.
+ * XXX probably this should be improved to fetch data directly from the WAL
+ * buffers when possible.
  *
  * Will open, and keep open, one WAL segment stored in the global file
- * descriptor sendFile. This means if XLogRead is used once, there will
- * always be one descriptor left open until the process ends, but never
- * more than one.
+ * descriptor sendFile. This means if XLogRead is used once, there will always
+ * be one descriptor left open until the process ends, but never more than
+ * one.
  */
 static void
-XLogRead(char *buf, XLogRecPtr startptr, Size count)
+XLogRead(char *buf, XLogRecPtr startptr, Size count, bool decrypt)
 {
 	char	   *p;
 	XLogRecPtr	recptr;
@@ -2489,42 +2543,88 @@ retry:
 			sendOff = 0;
 		}
 
-		/* Need to seek in the file? */
-		if (sendOff != startoff)
+		/* Caller should not request decryption of unencrypted data. */
+		Assert(!(decrypt && !data_encrypted));
+
+		if (data_encrypted && decrypt)
 		{
-			if (lseek(sendFile, (off_t) startoff, SEEK_SET) < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not seek in log segment %s to offset %u: %m",
-								XLogFileNameP(curFileTimeLine, sendSegNo),
-								startoff)));
-			sendOff = startoff;
-		}
+			int			pageoff = startoff % XLOG_BLCKSZ;
+			uint32		pagebase = startoff - pageoff;
+			int			bufbytes,
+						bufend,
+						i;
+			char		tweak[TWEAK_SIZE];
 
-		/* How many bytes are within this segment? */
-		if (nbytes > (wal_segment_size - startoff))
-			segbytes = wal_segment_size - startoff;
-		else
-			segbytes = nbytes;
+			/*
+			 * Only accept as much data as what can fit into the buffer.
+			 */
+			if (nbytes > (ENCRYPT_BUF_XLOG_SIZE - pageoff))
+				bufbytes = ENCRYPT_BUF_XLOG_SIZE - pageoff;
+			else
+				bufbytes = nbytes;
+			bufend = pageoff + bufbytes;
 
-		pgstat_report_wait_start(WAIT_EVENT_WAL_READ);
-		readbytes = read(sendFile, p, segbytes);
-		pgstat_report_wait_end();
-		if (readbytes < 0)
-		{
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from log segment %s, offset %u, length %zu: %m",
-							XLogFileNameP(curFileTimeLine, sendSegNo),
-							sendOff, (Size) segbytes)));
+			/*
+			 * Read the data, including the leading part of the page which
+			 * caller is not interested in. The tweak we passed to
+			 * encrypt_block() for encryption was for the beginning of the
+			 * block, so it'd be hard to start decryption anywhere else.
+			 */
+			readbytes = 0;
+			while (readbytes < bufend)
+				readbytes += XLogReadBuffer(encrypt_buf_xlog + readbytes,
+											bufend - readbytes,
+											pagebase + readbytes);
+
+			/*
+			 * Decrypt the data one page at a time (the tweak is only valid
+			 * for particular page).
+			 */
+			for (i = 0; i < readbytes; i += XLOG_BLCKSZ)
+			{
+				Size		nencrypt;
+
+				XLogEncryptionTweak(tweak,
+									curFileTimeLine,
+									sendSegNo,
+									pagebase + i);
+
+				/*
+				 * If the last page is not complete, only decrypt the used
+				 * part.
+				 */
+				if ((bufend - i) < XLOG_BLCKSZ)
+					nencrypt = bufend - i;
+				else
+					nencrypt = XLOG_BLCKSZ;
+
+				decrypt_block(encrypt_buf_xlog + i,
+							  encrypt_buf_xlog + i,
+							  nencrypt,
+							  tweak,
+							  InvalidBlockNumber,
+							  EDK_PERMANENT);
+			}
+
+			/*
+			 * Caller does not care that we possibly had to read pageoff bytes
+			 * in addition (because we cannot decrypt trailing part of the
+			 * page alone). This overhead must not affect the accounting.
+			 */
+			readbytes = bufbytes;
+
+			/* Copy the data to the output buffer. */
+			memcpy(p, encrypt_buf_xlog + pageoff, bufbytes);
 		}
-		else if (readbytes == 0)
+		else
 		{
-			ereport(ERROR,
-					(errcode(ERRCODE_DATA_CORRUPTED),
-					 errmsg("could not read from log segment %s, offset %u: read %d of %zu",
-							XLogFileNameP(curFileTimeLine, sendSegNo),
-							sendOff, readbytes, (Size) segbytes)));
+			/* How many bytes are within this segment? */
+			if (nbytes > (wal_segment_size - startoff))
+				segbytes = wal_segment_size - startoff;
+			else
+				segbytes = nbytes;
+
+			readbytes = XLogReadBuffer(p, segbytes, startoff);
 		}
 
 		/* Update state for read */
@@ -2588,6 +2688,7 @@ XLogSendPhysical(void)
 	XLogRecPtr	startptr;
 	XLogRecPtr	endptr;
 	Size		nbytes;
+	TimeLineID	tli_req;
 
 	/* If requested switch the WAL sender to the stopping state. */
 	if (got_STOPPING)
@@ -2803,7 +2904,85 @@ XLogSendPhysical(void)
 	 * calls.
 	 */
 	enlargeStringInfo(&output_message, nbytes);
-	XLogRead(&output_message.data[output_message.len], startptr, nbytes);
+	tli_req = sendTimeLine;
+	XLogRead(&output_message.data[output_message.len], startptr, nbytes,
+			 decrypt_stream);
+	/*
+	 * As its comment explains, XLogRead() can open segment in a TLI newer
+	 * than the requested one. Since the TLI is used in the encryption IV,
+	 * we've got to decrypt the data and encrypt it while taking the new TLI
+	 * into account.
+	 */
+	if (data_encrypted && !decrypt_stream && tli_req != curFileTimeLine)
+	{
+		XLogRecPtr	reencr_ptr = startptr;
+		int	reencr_nbytes = nbytes;
+		int	skip = 0;
+		char	*data_ptr;
+
+		/*
+		 * The WALRead() call above shouldn't have crossed more than one
+		 * segment boundary.
+		 */
+		Assert(nbytes < wal_segment_size);
+
+		/*
+		 * If the segment boundary is crossed, only the data from the second
+		 * segment need the re-encryption.
+		 */
+		if (reencr_ptr / wal_segment_size !=
+			(reencr_ptr + nbytes) / wal_segment_size)
+		{
+			skip = wal_segment_size - XLogSegmentOffset(reencr_ptr,
+														wal_segment_size);
+			reencr_ptr += skip;
+			reencr_nbytes -= skip;
+		}
+
+		/*
+		 * WALRead() should have read something from the new segment after
+		 * having it opened.
+		 */
+		Assert(reencr_nbytes > 0);
+
+		data_ptr = &output_message.data[output_message.len] + skip;
+
+		/* Process one page at a time. */
+		while (reencr_nbytes > 0)
+		{
+			PGAlignedXLogBlock buffer;
+			char		tweak[TWEAK_SIZE];
+			int	page_off = reencr_ptr % XLOG_BLCKSZ;
+			int	seg_off = (reencr_ptr - page_off) % wal_segment_size;
+			int	this_page = Min(XLOG_BLCKSZ - page_off, reencr_nbytes);
+
+			memcpy(buffer.data + page_off, data_ptr, this_page);
+			/* For decryption, use the TLI of the file actually read. */
+			XLogEncryptionTweak(tweak, curFileTimeLine, sendSegNo, seg_off);
+			decrypt_block(buffer.data,
+						  buffer.data,
+						  XLOG_BLCKSZ,
+						  tweak,
+						  InvalidBlockNumber,
+						  EDK_PERMANENT);
+
+			/* For encryption, use the TLI the receiver expects. */
+			XLogEncryptionTweak(tweak, tli_req, sendSegNo, seg_off);
+			encrypt_block(buffer.data,
+						  buffer.data,
+						  XLOG_BLCKSZ,
+						  tweak,
+						  InvalidXLogRecPtr,
+						  InvalidBlockNumber,
+						  EDK_PERMANENT);
+			memcpy(data_ptr, buffer.data + page_off, this_page);
+
+			reencr_ptr += this_page;
+			data_ptr += this_page;
+			reencr_nbytes -= this_page;
+		}
+	}
+
 	output_message.len += nbytes;
 	output_message.data[output_message.len] = '\0';
 
diff --git a/src/backend/storage/buffer/bufmgr.c b/src/backend/storage/buffer/bufmgr.c
index 303f82aa23..9b6148f49d 100644
--- a/src/backend/storage/buffer/bufmgr.c
+++ b/src/backend/storage/buffer/bufmgr.c
@@ -3,6 +3,7 @@
  * bufmgr.c
  *	  buffer manager interface routines
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -879,6 +880,10 @@ ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
 		/* new buffers are zero-filled */
 		MemSet((char *) bufBlock, 0, BLCKSZ);
 		/* don't set checksum for all-zero page */
+		/*
+		 * Encryption: no need to set LSN (to become an IV) because
+		 * zero-filled page won't be encrypted.
+		 */
 		smgrextend(smgr, forkNum, blockNum, (char *) bufBlock, false);
 
 		/*
@@ -900,11 +905,27 @@ ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
 		{
 			instr_time	io_start,
 						io_time;
+			Page	bufBlockEncr = NULL;
+			Page	bufRead;
+
+			if (!data_encrypted)
+				bufRead = bufBlock;
+			else
+				bufRead = (Page) encrypt_buf.data;
 
 			if (track_io_timing)
 				INSTR_TIME_SET_CURRENT(io_start);
 
-			smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
+			smgrread(smgr, forkNum, blockNum, bufRead);
+
+			if (data_encrypted)
+			{
+				decrypt_page(bufRead,
+							 bufBlock,
+							 blockNum,
+							 relpersistence);
+				bufBlockEncr = bufRead;
+			}
 
 			if (track_io_timing)
 			{
@@ -916,7 +937,8 @@ ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
 
 			/* check for garbage data */
 			if (!PageIsVerifiedExtended((Page) bufBlock, blockNum,
-										PIV_LOG_WARNING | PIV_REPORT_STAT))
+										PIV_LOG_WARNING | PIV_REPORT_STAT,
+										bufBlockEncr))
 			{
 				if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)
 				{
@@ -1476,7 +1498,11 @@ MarkBufferDirty(Buffer buffer)
 
 	if (BufferIsLocal(buffer))
 	{
-		MarkLocalBufferDirty(buffer);
+		/*
+		 * The caller of MarkBufferDirty () is responsible for setting the
+		 * LSN.
+		 */
+		MarkLocalBufferDirty(buffer, false);
 		return;
 	}
 
@@ -2753,6 +2779,41 @@ FlushBuffer(BufferDesc *buf, SMgrRelation reln)
 	 */
 	bufBlock = BufHdrGetBlock(buf);
 
+	if (data_encrypted)
+	{
+		char	relpersistence;
+
+		if (buf_state & BM_PERMANENT)
+			relpersistence = RELPERSISTENCE_PERMANENT;
+		else
+			relpersistence = RELPERSISTENCE_UNLOGGED;
+
+		/*
+		 * If permanent relation happens not to have valid LSN, it's probably
+		 * a new page and so it's o.k. not to encrypt that. We cannot assign
+		 * regular LSN (by inserting a new XLOG_NOOP record) at this stage
+		 * anyway.
+		 */
+		if (!XLogRecPtrIsInvalid(recptr))
+		{
+			encrypt_page(bufBlock, encrypt_buf.data, recptr,
+						 buf->tag.blockNum, relpersistence);
+		}
+		else
+		{
+			/*
+			 * Make sure that the invalid LSN is written to disk. If we simply
+			 * wrote bufBlock, MarkBufferDirtyHint() could change the LSN
+			 * concurrently and thus decrypt_page() would eventually think
+			 * that the page is encrypted.
+			 */
+			memcpy(encrypt_buf.data, bufBlock, BLCKSZ);
+			PageSetLSN(encrypt_buf.data, recptr);
+		}
+
+		bufBlock = encrypt_buf.data;
+	}
+
 	/*
 	 * Update page checksum if desired.  Since we have only shared lock on the
 	 * buffer, other processes might be updating hint bits in it, so we must
@@ -2892,8 +2953,12 @@ BufferGetLSNAtomic(Buffer buffer)
 
 	/*
 	 * If we don't need locking for correctness, fastpath out.
+	 *
+	 * If data_encrypted, then MarkBufferDirtyHint() can change the LSN while
+	 * the caller has only share lock on the buffer, so the fastpath is not
+	 * usable.
 	 */
-	if (!XLogHintBitIsNeeded() || BufferIsLocal(buffer))
+	if (!(XLogHintBitIsNeeded() || data_encrypted) || BufferIsLocal(buffer))
 		return PageGetLSN(page);
 
 	/* Make sure we've got a real buffer, and that we hold a pin on it. */
@@ -3229,8 +3294,23 @@ FlushRelationBuffers(Relation rel)
 				errcallback.previous = error_context_stack;
 				error_context_stack = &errcallback;
 
-				PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
+				if (data_encrypted)
+				{
+					XLogRecPtr	lsn = PageGetLSN(localpage);
+
+					if (!XLogRecPtrIsInvalid(lsn))
+					{
+						encrypt_page((char *) localpage,
+									 encrypt_buf.data,
+									 lsn,
+									 bufHdr->tag.blockNum,
+									 rel->rd_rel->relpersistence);
+
+						localpage = encrypt_buf.data;
+					}
+				}
 
+				PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
 				smgrwrite(rel->rd_smgr,
 						  bufHdr->tag.forkNum,
 						  bufHdr->tag.blockNum,
@@ -3428,6 +3508,17 @@ IncrBufferRefCount(Buffer buffer)
  *	  buffer's content lock.
  * 3. This function does not guarantee that the buffer is always marked dirty
  *	  (due to a race condition), so it cannot be used for important changes.
+ *
+ * The function also handles generation of LSN when it's needed as the
+ * encryption IV. The problem is that the buffer can be written to disk
+ * anytime after this function has finished, so the function needs to
+ * guarantee an unique LSN to be set. Alternatively, caller can be required to
+ * set the LSN before he ever calls the function, but in such a case he'd have
+ * to predict whether the function will set the LSN too or not.
+ *
+ * Note that the encryption-specific LSN is not generated during
+ * recovery. Caller should set the LSN in such a case, *before* the actual
+ * call.
  */
 void
 MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
@@ -3440,7 +3531,26 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 
 	if (BufferIsLocal(buffer))
 	{
-		MarkLocalBufferDirty(buffer);
+		bool	set_lsn = false;
+
+		/* LSN is used as the encryption IV. */
+		if (data_encrypted)
+		{
+			/*
+			 * It's safer to return without marking the buffer dirty than to
+			 * go ahead without setting the LSN (a new LSN cannot be generated
+			 * during recovery anyway). The point is that the recovery can end
+			 * anytime after RecoveryInProgress() has returned true, so if we
+			 * only skip setting the LSN, then the buffer can be written to
+			 * disk w/o LSN, and therefore unencrypted.
+			 */
+			if (RecoveryInProgress())
+				return;
+
+			set_lsn = true;
+		}
+
+		MarkLocalBufferDirty(buffer, set_lsn);
 		return;
 	}
 
@@ -3468,6 +3578,7 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 		bool		dirtied = false;
 		bool		delayChkpt = false;
 		uint32		buf_state;
+		bool	need_fpi;
 
 		/*
 		 * If we need to protect hint bit updates from torn writes, WAL-log a
@@ -3478,8 +3589,9 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 		 * We don't check full_page_writes here because that logic is included
 		 * when we call XLogInsert() since the value changes dynamically.
 		 */
-		if (XLogHintBitIsNeeded() &&
-			(pg_atomic_read_u32(&bufHdr->state) & BM_PERMANENT))
+		need_fpi = XLogHintBitIsNeeded() &&
+			(pg_atomic_read_u32(&bufHdr->state) & BM_PERMANENT);
+		if (need_fpi || data_encrypted)
 		{
 			/*
 			 * If we're in recovery we cannot dirty a page because of a hint.
@@ -3513,11 +3625,23 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 			 * It's possible we may enter here without an xid, so it is
 			 * essential that CreateCheckpoint waits for virtual transactions
 			 * rather than full transactionids.
+			 *
+			 * Encryption alone should not be the reason for FPI.
+			 */
+			if (need_fpi)
+			{
+				Assert(!MyPgXact->delayChkpt);
+				MyPgXact->delayChkpt = true;
+				delayChkpt = true;
+				lsn = XLogSaveBufferForHint(buffer, buffer_std);
+			}
+
+			/*
+			 * Callers rely on us to generate LSN for the sake of encryption
+			 * IV.
 			 */
-			Assert(!MyPgXact->delayChkpt);
-			MyPgXact->delayChkpt = true;
-			delayChkpt = true;
-			lsn = XLogSaveBufferForHint(buffer, buffer_std);
+			if (XLogRecPtrIsInvalid(lsn) && data_encrypted)
+				lsn = get_lsn_for_encryption();
 		}
 
 		buf_state = LockBufHdr(bufHdr);
diff --git a/src/backend/storage/buffer/localbuf.c b/src/backend/storage/buffer/localbuf.c
index 391b6d6e16..d9dc63b59d 100644
--- a/src/backend/storage/buffer/localbuf.c
+++ b/src/backend/storage/buffer/localbuf.c
@@ -4,6 +4,7 @@
  *	  local buffer manager. Fast buffer manager for temporary tables,
  *	  which never need to be WAL-logged or checkpointed, etc.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994-5, Regents of the University of California
  *
@@ -16,10 +17,12 @@
 #include "postgres.h"
 
 #include "access/parallel.h"
+#include "access/xlog.h"
 #include "catalog/catalog.h"
 #include "executor/instrument.h"
 #include "storage/buf_internals.h"
 #include "storage/bufmgr.h"
+#include "storage/encryption.h"
 #include "utils/guc.h"
 #include "utils/memutils.h"
 #include "utils/resowner_private.h"
@@ -211,9 +214,23 @@ LocalBufferAlloc(SMgrRelation smgr, ForkNumber forkNum, BlockNumber blockNum,
 		/* Find smgr relation for buffer */
 		oreln = smgropen(bufHdr->tag.rnode, MyBackendId);
 
-		PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
-
 		/* And write... */
+		if (data_encrypted)
+		{
+			XLogRecPtr	lsn;
+
+			/* Generate fake LSN to become the encryption IV. */
+			lsn = get_lsn_for_encryption();
+
+			encrypt_page((char *) localpage,
+						 encrypt_buf.data,
+						 lsn,
+						 bufHdr->tag.blockNum,
+						 RELPERSISTENCE_TEMP);
+
+			localpage = encrypt_buf.data;
+		}
+		PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
 		smgrwrite(oreln,
 				  bufHdr->tag.forkNum,
 				  bufHdr->tag.blockNum,
@@ -277,7 +294,7 @@ LocalBufferAlloc(SMgrRelation smgr, ForkNumber forkNum, BlockNumber blockNum,
  *	  mark a local buffer dirty
  */
 void
-MarkLocalBufferDirty(Buffer buffer)
+MarkLocalBufferDirty(Buffer buffer, bool set_lsn)
 {
 	int			bufid;
 	BufferDesc *bufHdr;
@@ -295,6 +312,14 @@ MarkLocalBufferDirty(Buffer buffer)
 
 	bufHdr = GetLocalBufferDescriptor(bufid);
 
+	if (set_lsn)
+	{
+		Block	bufBlock = LocalBufHdrGetBlock(bufHdr);
+		XLogRecPtr	lsn = get_lsn_for_encryption();
+
+		PageSetLSN(bufBlock, lsn);
+	}
+
 	buf_state = pg_atomic_read_u32(&bufHdr->state);
 
 	if (!(buf_state & BM_DIRTY))
diff --git a/src/backend/storage/file/Makefile b/src/backend/storage/file/Makefile
index ca6a0e4f7d..9f277755fc 100644
--- a/src/backend/storage/file/Makefile
+++ b/src/backend/storage/file/Makefile
@@ -12,6 +12,6 @@ subdir = src/backend/storage/file
 top_builddir = ../../../..
 include $(top_builddir)/src/Makefile.global
 
-OBJS = fd.o buffile.o copydir.o reinit.o sharedfileset.o
+OBJS = fd.o buffile.o copydir.o reinit.o sharedfileset.o encryption.o
 
 include $(top_srcdir)/src/backend/common.mk
diff --git a/src/backend/storage/file/README.encryption b/src/backend/storage/file/README.encryption
new file mode 100644
index 0000000000..2853e78c85
--- /dev/null
+++ b/src/backend/storage/file/README.encryption
@@ -0,0 +1,172 @@
+src/backend/storage/file/README.encryption
+
+Transparent Cluster Encryption
+==============================
+
+When creating a new cluster (instance), user can choose to have his data
+encrypted on disk. If this feature is active, data is encrypted before it's
+written to disk and decrypted after it has been read. The data is always
+unencrypted in memory. The following characteristics should be considered by
+anyone who is interested in the feature:
+
+	1. The encryption is transparent from application's point of view.
+
+	2. A single key is used to encrypt the whole cluster.
+
+The full instance encryption feature helps to ensure data confidentiality,
+especially when user cannot rely on confidentiality at filesystem level. On
+the other hand, it does not ensure data integrity, i.e. it does not help to
+detect whether an adversary wrote his cipher data to the disk. The ciphers
+used here do not protect data integrity: we encrypt one pages (typically of
+size 8 kB) at a time, so the attacker can replace the whole page. However if
+the attacker only changes part of the page, this can be detected if data
+checksums feature is enabled. And specifically for WAL, each WAL record has
+its own checksum.
+
+Relations
+---------
+
+AES cipher in CTR mode [2] is used to encrypt relation files, one relation
+block (page) at a time. Since CTR is effectively a stream cipher, we can
+consider each page to be a separate stream.
+
+One particular advantage of the CTR mode is that initialization vector (IV) of
+given encryption blocks can be determined independently from other blocks, so
+both encryption and decryption of a single page can be performed by multiple
+CPUs in parallel.
+
+Page LSN is stored unencrypted, see the section on initialization vector
+(tweak) below.
+
+Page checksum is also unencrypted so that it can be computed after encryption,
+right before the page is written to disk.
+
+WAL
+---
+
+The specific problem of WAL is that record must not be changed once it has
+been flushed to disk. However if we used a block cipher, and if a new WAL
+record started in the same encryption block in which the previous record ends,
+that encryption block would become completely different after the next run of
+encryption of the containing page. Torn write of such a block (e.g. if page
+boundary crosses the encryption block) is likely to make decryption produce
+garbage, which will also appear in the already-flushed record.
+
+Therefore we encrypt WAL using a stream cipher, or rather block cipher in
+stream mode of operation. Stream cipher uses XOR operation to combine a "key
+stream" with the input stream, and it does not matter if the length of the
+input stream is aligned to any value. In particular, the CTR mode [2] was
+chosen because it allows for both read and write operations to be performed by
+multiple CPUs.
+
+The WAL is encrypted / decrypted one WAL page (typically 8 kB) at a time, so
+rather than a single stream, the encrypted WAL is actually a sequence of
+per-page streams.
+
+Since stream ciphers are susceptible to "reused key attack" [4], we must
+ensure that the unused part of the last WAL page (filled with zeroes) is
+never encrypted.
+
+Temporary files
+---------------
+
+BufFileWrite() and BufFileRead() functions (see buffile.c) hide the encryption
+/ decryption from caller. The encryption / decryption processes one buffer at
+a time so that the buffers can be retrieved independent from each other.
+
+If the encryption is enabled, the following requirements need to be taken into
+account:
+
+1. The file buffer cannot be positioned at arbitrary offset of the file. If
+the encryption routine starts at some position of the file, decryption must
+not start elsewhere because there's no way to determine which initialization
+vector was used internally for the corresponding encryption blocks during
+encryption. It makes sense to position the buffer at file offset, that is
+whole multiple of buffer size.
+
+2. Since temporary file or its part can be rewritten, we either need to derive
+a new IV for each write or to avoid using stream cipher (see [4]). The earlier
+is difficult because both temporary files and "auxiliary files" are
+implemented in the same module buffile.c (in order to eliminate code
+duplication) and because it's hard to generate an unique IV for each write
+into auxiliary file, see explanation below. Therefore we use the AES-CBC
+cipher [3] for temporary files.
+
+3. In general, the useful (written) data does not fill whole multiple of
+encryption blocks, but we must write the whole blocks for decryption to
+succeed (this is because we use block cipher, as explained above). That
+implies that we need to fill the unused part of the last block with zeroes and
+also remember the amount of useful bytes in the segment file.  (In fact we
+align the segment file size to file buffers instead of encryption blocks,
+which makes the implementation simpler.)
+
+Auxiliary files
+---------------
+
+To store other kinds of data encrypted than the ones above, developers are
+advised to use BufFileWriteTransient() and BufFileReadTransient() functions
+(also located in buffile.c). These are especially useful if some data
+structure should be written to an encrypted file and user does not want to
+care about encryption specific details.
+
+Since these files can be closed and reopened again, we need to derive the
+tweak w/o using any in-memory metadata - such metadata is essentially lost
+when the file is closed. If we stored any kind of metadata into the file, it'd
+make the implementation rather tricky. Howver w/o storing the metadata, we
+cannot easily derive a new tweak if some block gets rewritten. Therefore we
+use the AES-CBC cipher for auxiliary files: unlike stream cipher, this cipher
+is not vulnerable to "reused key attack" [4].
+
+Serialization of data changes during logical decoding (reorderbuffer.c) is the
+typical use case for this API. Another use case is encryption of statistics
+(pgstat.c).
+
+Initialization vector (IV), encryption tweak
+--------------------------------------------
+
+Besides the input data and the key, both block and stream cipher used for the
+postgres cluster encryption require an initialization vector. It should make
+analysis of the encrypted data more difficult. Also according to [1], the same
+data should be encrypted differently if located elsewhere on the disk. Term
+"encryption tweak" is more common in the context of disk encryption.
+
+When encrypting relations, each encryption unit (i.e. page) has an unique
+tweak, which consists of page LSN and block number. Since the tweak is needed
+for decryption, we leave the LSN unencrypted.
+
+WAL encryption tweak consists of timeline, segment number and offset at which
+the WAL page starts in the segment. The "reencryption" takes place when WAL
+page is copied from one timeline to another, typicially at the end of
+recovery.
+
+As for temporary files, PID of the owning backend, file / fileset number and
+block number (where block is of the same size as a relation page) within the
+file provide sufficient uniqueness, so we use these to generate the tweak.
+
+Auxiliary files can be used for different purposes, so each caller is
+responsible for the tweak initialization. See the source code for details.
+
+Replication
+-----------
+
+During streaming replication, the walsender process sends the WAL encrypted
+and walreceiver just writes it. Decryption is performed before the slave
+cluster tries to apply the changes. That implies that the same encryption key
+must be used both master and slave.
+
+As for logical replication, the only change introduced by this feature is that
+the WAL has to be decrypted before the contained data changes can be
+decoded. The data changes are transferred to the subscribing database /
+cluster unencrypted, so both master and slave can use different encryption
+keys.
+
+References
+----------
+
+[1] https://en.wikipedia.org/wiki/Disk_encryption_theory
+
+[2] https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)
+
+[3] https://en.wikipedia.org/wiki/Disk_encryption_theory#Cipher-block_chaining_(CBC)
+
+[4] https://en.wikipedia.org/wiki/Stream_cipher_attacks#Reused_key_attack
diff --git a/src/backend/storage/file/buffile.c b/src/backend/storage/file/buffile.c
index 1d548a02d6..15fe907cf4 100644
--- a/src/backend/storage/file/buffile.c
+++ b/src/backend/storage/file/buffile.c
@@ -3,6 +3,7 @@
  * buffile.c
  *	  Management of large buffered temporary files.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -48,15 +49,62 @@
 #include "storage/fd.h"
 #include "storage/buffile.h"
 #include "storage/buf_internals.h"
+#include "storage/encryption.h"
+#include "utils/datetime.h"
 #include "utils/resowner.h"
 
 /*
- * We break BufFiles into gigabyte-sized segments, regardless of RELSEG_SIZE.
- * The reason is that we'd like large BufFiles to be spread across multiple
- * tablespaces when available.
+ * The functions bellow actually use integer constants so that the size can be
+ * controlled by GUC. This is useful for development and regression tests.
  */
-#define MAX_PHYSICAL_FILESIZE	0x40000000
-#define BUFFILE_SEG_SIZE		(MAX_PHYSICAL_FILESIZE / BLCKSZ)
+int buffile_max_filesize	=  MAX_PHYSICAL_FILESIZE;
+int buffile_seg_blocks	=	BUFFILE_SEG_BLOCKS(MAX_PHYSICAL_FILESIZE);
+
+/*
+ * Fields that both BufFile and TransientBufFile structures need. It must be
+ * the first field of those structures.
+ */
+typedef struct BufFileCommon
+{
+	bool		dirty;			/* does buffer need to be written? */
+	int			pos;			/* next read/write position in buffer */
+	int			nbytes;			/* total # of valid bytes in buffer */
+
+	/*
+	 * "current pos" is position of start of buffer within the logical file.
+	 * Position as seen by user of BufFile is (curFile, curOffset + pos).
+	 */
+	int			curFile;		/* file index (0..n) part of current pos,
+								 * always zero for TransientBufFile */
+	off_t		curOffset;		/* offset part of current pos */
+
+	bool		readOnly;		/* has the file been set to read only? */
+
+	bool		append;			/* should new data be appended to the end? */
+
+	/*
+	 * If the file is encrypted, only the whole buffer can be loaded / dumped
+	 * --- see BufFileLoadBuffer() for more info --- whether it's space is
+	 * used up or not. Therefore we need to keep track of the actual on-disk
+	 * size buffer of each component file, as it would be if there was no
+	 * encryption.
+	 *
+	 * List would make coding simpler, however it would not be good for
+	 * performance. Random access is important here.
+	 */
+	off_t	   *useful;
+
+	/*
+	 * The "useful" array may need to be expanded independent from
+	 * extendBufFile() (i.e. earlier than the buffer gets dumped), so store
+	 * the number of elements separate from numFiles.
+	 *
+	 * Always 1 for TransientBufFile.
+	 */
+	int			nuseful;
+
+	PGAlignedBlock buffer;
+} BufFileCommon;
 
 /*
  * This data structure represents a buffered file that consists of one or
@@ -65,33 +113,62 @@
  */
 struct BufFile
 {
+	BufFileCommon common;		/* Common fields, see above. */
+
 	int			numFiles;		/* number of physical files in set */
-	/* all files except the last have length exactly MAX_PHYSICAL_FILESIZE */
+	/* all files except the last have length exactly buffile_max_filesize */
 	File	   *files;			/* palloc'd array with numFiles entries */
 
+	/*
+	 * Segment number is used to compute encryption tweak so we must remember
+	 * the original numbers of segments if the file is encrypted and if it was
+	 * passed as target to BufFileAppend() at least once. If this field is
+	 * NULL, ->curFile is used to compute the tweak.
+	 */
+	off_t	   *segnos;
+
 	bool		isInterXact;	/* keep open over transactions? */
-	bool		dirty;			/* does buffer need to be written? */
-	bool		readOnly;		/* has the file been set to read only? */
 
 	SharedFileSet *fileset;		/* space for segment files if shared */
 	const char *name;			/* name of this BufFile if shared */
 
+	/*
+	 * Per-PID identifier if the file is encrypted and not shared. Used for
+	 * tweak computation.
+	 */
+	uint32		number;
+
 	/*
 	 * resowner is the ResourceOwner to use for underlying temp files.  (We
 	 * don't need to remember the memory context we're using explicitly,
 	 * because after creation we only repalloc our arrays larger.)
 	 */
 	ResourceOwner resowner;
+};
 
-	/*
-	 * "current pos" is position of start of buffer within the logical file.
-	 * Position as seen by user of BufFile is (curFile, curOffset + pos).
-	 */
-	int			curFile;		/* file index (0..n) part of current pos */
-	off_t		curOffset;		/* offset part of current pos */
-	int			pos;			/* next read/write position in buffer */
-	int			nbytes;			/* total # of valid bytes in buffer */
-	PGAlignedBlock buffer;
+/*
+ * Buffered variant of a transient file. Unlike BufFile this is simpler in
+ * several ways: 1) it's not split into segments, 2) there's no need of seek,
+ * 3) there's no need to combine read and write access.
+ *
+ * XXX "Transient" refers to the fact that this kind of file was initially
+ * used to encrypt files that PG core accessed via OpenTransientFile /
+ * CloseTransientFile. However, since commit d2070380, PG core uses
+ * PathNameOpenFile in reorderbuffer.c., so it was changed here too. Should
+ * this structure and related functions be renamed?
+ */
+struct TransientBufFile
+{
+	/* Common fields, see above. */
+	BufFileCommon common;
+
+	/* The underlying file. */
+	File		vfd;
+	char		*path;
+
+	/* Path-dependent part of the encryption tweak. */
+	char	tweakBase[TWEAK_BASE_SIZE];
+	int		elevel;
 };
 
 static BufFile *makeBufFileCommon(int nfiles);
@@ -99,26 +176,61 @@ static BufFile *makeBufFile(File firstfile);
 static void extendBufFile(BufFile *file);
 static void BufFileLoadBuffer(BufFile *file);
 static void BufFileDumpBuffer(BufFile *file);
-static void BufFileFlush(BufFile *file);
+static void BufFileDumpBufferEncrypted(BufFile *file);
+static void BufFileFlush(BufFileCommon *file, bool is_transient);
 static File MakeNewSharedSegment(BufFile *file, int segment);
 
+static void BufFileTweak(char *tweak, BufFileCommon *file, bool is_transient);
+static void ensureUsefulArraySize(BufFileCommon *file, int required);
+static void BufFileAppendMetadata(BufFile *target, BufFile *source);
+
+static void BufFileLoadBufferTransient(TransientBufFile *file);
+static void BufFileDumpBufferTransient(TransientBufFile *file);
+
+static size_t BufFileReadCommon(BufFileCommon *file, void *ptr, size_t size,
+								bool is_transient);
+static size_t BufFileWriteCommon(BufFileCommon *file, void *ptr, size_t size,
+								 bool is_transient);
+static void BufFileUpdateUsefulLength(BufFileCommon *file, bool is_transient);
+
 /*
  * Create BufFile and perform the common initialization.
  */
 static BufFile *
 makeBufFileCommon(int nfiles)
 {
-	BufFile    *file = (BufFile *) palloc(sizeof(BufFile));
+	BufFile    *file = (BufFile *) palloc0(sizeof(BufFile));
+	BufFileCommon *fcommon = &file->common;
+
+	fcommon->dirty = false;
+	fcommon->curFile = 0;
+	fcommon->curOffset = 0L;
+	fcommon->pos = 0;
+	fcommon->nbytes = 0;
 
 	file->numFiles = nfiles;
 	file->isInterXact = false;
-	file->dirty = false;
 	file->resowner = CurrentResourceOwner;
-	file->curFile = 0;
-	file->curOffset = 0L;
-	file->pos = 0;
-	file->nbytes = 0;
 
+	if (data_encrypted)
+	{
+		fcommon->useful = (off_t *) palloc0(sizeof(off_t) * nfiles);
+		fcommon->nuseful = nfiles;
+
+		file->segnos = NULL;
+
+		/*
+		 * The unused (trailing) part of the buffer should not contain
+		 * undefined data: if we encrypt such a buffer and flush it to disk,
+		 * the encrypted form of that "undefined part" can get zeroed due to
+		 * seek and write beyond EOF. If such a buffer gets loaded and
+		 * decrypted, the change of the undefined part to zeroes can affect
+		 * the valid part if it does not end at block boundary. By setting the
+		 * whole buffer to zeroes we ensure that the unused part of the buffer
+		 * always contains zeroes.
+		 */
+		MemSet(fcommon->buffer.data, 0, BLCKSZ);
+	}
 	return file;
 }
 
@@ -133,7 +245,7 @@ makeBufFile(File firstfile)
 
 	file->files = (File *) palloc(sizeof(File));
 	file->files[0] = firstfile;
-	file->readOnly = false;
+	file->common.readOnly = false;
 	file->fileset = NULL;
 	file->name = NULL;
 
@@ -164,13 +276,26 @@ extendBufFile(BufFile *file)
 
 	file->files = (File *) repalloc(file->files,
 									(file->numFiles + 1) * sizeof(File));
+
+	if (data_encrypted)
+	{
+		ensureUsefulArraySize(&file->common, file->numFiles + 1);
+
+		if (file->segnos)
+		{
+			file->segnos = (off_t *) repalloc(file->segnos,
+											  (file->numFiles + 1) * sizeof(off_t));
+			file->segnos[file->numFiles] = file->numFiles;
+		}
+	}
+
 	file->files[file->numFiles] = pfile;
 	file->numFiles++;
 }
 
 /*
  * Create a BufFile for a new temporary file (which will expand to become
- * multiple temporary files if more than MAX_PHYSICAL_FILESIZE bytes are
+ * multiple temporary files if more than buffile_max_filesize bytes are
  * written to it).
  *
  * If interXact is true, the temp file will not be automatically deleted
@@ -186,6 +311,8 @@ BufFileCreateTemp(bool interXact)
 	BufFile    *file;
 	File		pfile;
 
+	static uint32 counter_temp = 0;
+
 	/*
 	 * Ensure that temp tablespaces are set up for OpenTemporaryFile to use.
 	 * Possibly the caller will have done this already, but it seems useful to
@@ -201,6 +328,10 @@ BufFileCreateTemp(bool interXact)
 	Assert(pfile >= 0);
 
 	file = makeBufFile(pfile);
+
+	file->number = counter_temp;
+	counter_temp = (counter_temp + 1) % INT_MAX;
+
 	file->isInterXact = interXact;
 
 	return file;
@@ -264,7 +395,7 @@ BufFileCreateShared(SharedFileSet *fileset, const char *name)
 	file->name = pstrdup(name);
 	file->files = (File *) palloc(sizeof(File));
 	file->files[0] = MakeNewSharedSegment(file, 0);
-	file->readOnly = false;
+	file->common.readOnly = false;
 
 	return file;
 }
@@ -304,6 +435,7 @@ BufFileOpenShared(SharedFileSet *fileset, const char *name)
 		files[nfiles] = SharedFileSetOpen(fileset, segment_name);
 		if (files[nfiles] <= 0)
 			break;
+
 		++nfiles;
 
 		CHECK_FOR_INTERRUPTS();
@@ -320,8 +452,52 @@ BufFileOpenShared(SharedFileSet *fileset, const char *name)
 						segment_name, name)));
 
 	file = makeBufFileCommon(nfiles);
+
+	/*
+	 * Shared encrypted segment should, at its end, contain information on the
+	 * number of useful bytes in the last buffer.
+	 */
+	if (data_encrypted)
+	{
+		off_t		pos;
+		int			i;
+
+		for (i = 0; i < nfiles; i++)
+		{
+			int			nbytes;
+			File		segment = files[i];
+
+			pos = FileSize(segment) - sizeof(off_t);
+
+			/*
+			 * The word must immediately follow the last buffer of the
+			 * segment.
+			 */
+			if (pos <= 0 || pos % BLCKSZ != 0)
+				ereport(ERROR,
+						(errcode_for_file_access(),
+						 errmsg("could not find padding info in BufFile \"%s\": %m",
+								name)));
+
+			nbytes = FileRead(segment, (char *) &file->common.useful[i],
+							  sizeof(off_t), pos, WAIT_EVENT_BUFFILE_READ);
+			if (nbytes != sizeof(off_t))
+				ereport(ERROR,
+						(errcode_for_file_access(),
+						 errmsg("could not read padding info from BufFile \"%s\": %m",
+								name)));
+			Assert(file->common.useful[i] > 0);
+
+			CHECK_FOR_INTERRUPTS();
+		}
+	}
+
 	file->files = files;
-	file->readOnly = true;		/* Can't write to files opened this way */
+
+	if (data_encrypted)
+		file->common.nuseful = nfiles;
+
+	file->common.readOnly = true;	/* Can't write to files opened this way */
 	file->fileset = fileset;
 	file->name = pstrdup(name);
 
@@ -376,10 +552,10 @@ BufFileExportShared(BufFile *file)
 	Assert(file->fileset != NULL);
 
 	/* It's probably a bug if someone calls this twice. */
-	Assert(!file->readOnly);
+	Assert(!file->common.readOnly);
 
-	BufFileFlush(file);
-	file->readOnly = true;
+	BufFileFlush(&file->common, false);
+	file->common.readOnly = true;
 }
 
 /*
@@ -393,12 +569,20 @@ BufFileClose(BufFile *file)
 	int			i;
 
 	/* flush any unwritten data */
-	BufFileFlush(file);
+	BufFileFlush(&file->common, false);
 	/* close and delete the underlying file(s) */
 	for (i = 0; i < file->numFiles; i++)
 		FileClose(file->files[i]);
 	/* release the buffer space */
 	pfree(file->files);
+
+	if (data_encrypted)
+	{
+		if (file->segnos)
+			pfree(file->segnos);
+		pfree(file->common.useful);
+	}
+
 	pfree(file);
 }
 
@@ -406,7 +590,7 @@ BufFileClose(BufFile *file)
  * BufFileLoadBuffer
  *
  * Load some data into buffer, if possible, starting from curOffset.
- * At call, must have dirty = false, pos and nbytes = 0.
+ * At call, must have dirty = false, nbytes = 0.
  * On exit, nbytes is number of bytes loaded.
  */
 static void
@@ -414,37 +598,104 @@ BufFileLoadBuffer(BufFile *file)
 {
 	File		thisfile;
 
+	/*
+	 * Only whole multiple of BLCKSZ can be encrypted / decrypted.
+	 */
+	Assert(file->common.curOffset % BLCKSZ == 0 || !data_encrypted);
+
 	/*
 	 * Advance to next component file if necessary and possible.
 	 */
-	if (file->curOffset >= MAX_PHYSICAL_FILESIZE &&
-		file->curFile + 1 < file->numFiles)
+	if (file->common.curOffset >= buffile_max_filesize &&
+		file->common.curFile + 1 < file->numFiles)
 	{
-		file->curFile++;
-		file->curOffset = 0L;
+		file->common.curFile++;
+		file->common.curOffset = 0L;
 	}
 
+	/*
+	 * See makeBufFileCommon().
+	 *
+	 * Actually here we only handle the case of FileRead() returning zero
+	 * bytes below. In contrast, if the buffer contains any data but it's not
+	 * full, it should already have the trailing zeroes (encrypted) on disk.
+	 * And as the encrypted buffer is always loaded in its entirety (i.e. EOF
+	 * should only appear at buffer boundary if the data is encrypted), all
+	 * unused bytes of the buffer should eventually be zeroes after
+	 * decryption.
+	 */
+	if (data_encrypted)
+		MemSet(file->common.buffer.data, 0, BLCKSZ);
+
 	/*
 	 * Read whatever we can get, up to a full bufferload.
 	 */
-	thisfile = file->files[file->curFile];
-	file->nbytes = FileRead(thisfile,
-							file->buffer.data,
-							sizeof(file->buffer),
-							file->curOffset,
-							WAIT_EVENT_BUFFILE_READ);
-	if (file->nbytes < 0)
+	thisfile = file->files[file->common.curFile];
+	file->common.nbytes = FileRead(thisfile,
+								   file->common.buffer.data,
+								   sizeof(file->common.buffer),
+								   file->common.curOffset,
+								   WAIT_EVENT_BUFFILE_READ);
+	if (file->common.nbytes < 0)
 	{
-		file->nbytes = 0;
+		file->common.nbytes = 0;
 		ereport(ERROR,
 				(errcode_for_file_access(),
 				 errmsg("could not read file \"%s\": %m",
 						FilePathName(thisfile))));
 	}
-
 	/* we choose not to advance curOffset here */
 
-	if (file->nbytes > 0)
+	if (data_encrypted && file->common.nbytes > 0)
+	{
+		char		tweak[TWEAK_SIZE];
+		int			nbytes = file->common.nbytes;
+
+		/*
+		 * The encrypted component file can only consist of whole number of
+		 * our encryption units. (Only the whole buffers are dumped / loaded.)
+		 * The only exception is that we're at the end of segment file and
+		 * found the word indicating the number of useful bytes in the
+		 * segment. This can only happen for shared file.
+		 */
+		if (nbytes % BLCKSZ != 0)
+		{
+			Assert(nbytes == sizeof(off_t) && file->fileset != NULL);
+
+			/*
+			 * This metadata his hidden to caller, so all he needs to know
+			 * that there's no real data at the end of the file.
+			 */
+			file->common.nbytes = 0;
+			return;
+		}
+
+		/* Decrypt the whole block at once. */
+		BufFileTweak(tweak, &file->common, false);
+		decrypt_block(file->common.buffer.data,
+					  file->common.buffer.data,
+					  BLCKSZ,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_BUFFILE);
+
+#ifdef	USE_ASSERT_CHECKING
+
+		/*
+		 * The unused part of the buffer which we've read from disk and
+		 * decrypted should only contain zeroes, as explained in front of the
+		 * MemSet() call.
+		 */
+		{
+			int			i;
+
+			for (i = file->common.nbytes; i < BLCKSZ; i++)
+				Assert(file->common.buffer.data[i] == 0);
+		}
+#endif							/* USE_ASSERT_CHECKING */
+	}
+
+	if (file->common.nbytes > 0)
 		pgBufferUsage.temp_blks_read++;
 }
 
@@ -466,47 +717,48 @@ BufFileDumpBuffer(BufFile *file)
 	 * Unlike BufFileLoadBuffer, we must dump the whole buffer even if it
 	 * crosses a component-file boundary; so we need a loop.
 	 */
-	while (wpos < file->nbytes)
+	while (wpos < file->common.nbytes)
 	{
 		off_t		availbytes;
 
 		/*
 		 * Advance to next component file if necessary and possible.
 		 */
-		if (file->curOffset >= MAX_PHYSICAL_FILESIZE)
+		if (file->common.curOffset >= buffile_max_filesize)
 		{
-			while (file->curFile + 1 >= file->numFiles)
+			while (file->common.curFile + 1 >= file->numFiles)
 				extendBufFile(file);
-			file->curFile++;
-			file->curOffset = 0L;
+			file->common.curFile++;
+			file->common.curOffset = 0L;
 		}
 
 		/*
 		 * Determine how much we need to write into this file.
 		 */
-		bytestowrite = file->nbytes - wpos;
-		availbytes = MAX_PHYSICAL_FILESIZE - file->curOffset;
+		bytestowrite = file->common.nbytes - wpos;
+		availbytes = buffile_max_filesize - file->common.curOffset;
 
 		if ((off_t) bytestowrite > availbytes)
 			bytestowrite = (int) availbytes;
 
-		thisfile = file->files[file->curFile];
+		thisfile = file->files[file->common.curFile];
 		bytestowrite = FileWrite(thisfile,
-								 file->buffer.data + wpos,
+								 file->common.buffer.data + wpos,
 								 bytestowrite,
-								 file->curOffset,
-								 WAIT_EVENT_BUFFILE_WRITE);
+								 file->common.curOffset,
+								 WAIT_EVENT_BUFFILE_WRITE,
+								 ERROR);
 		if (bytestowrite <= 0)
 			ereport(ERROR,
 					(errcode_for_file_access(),
 					 errmsg("could not write to file \"%s\": %m",
 							FilePathName(thisfile))));
-		file->curOffset += bytestowrite;
+		file->common.curOffset += bytestowrite;
 		wpos += bytestowrite;
 
 		pgBufferUsage.temp_blks_written++;
 	}
-	file->dirty = false;
+	file->common.dirty = false;
 
 	/*
 	 * At this point, curOffset has been advanced to the end of the buffer,
@@ -514,62 +766,195 @@ BufFileDumpBuffer(BufFile *file)
 	 * logical file position, ie, original value + pos, in case that is less
 	 * (as could happen due to a small backwards seek in a dirty buffer!)
 	 */
-	file->curOffset -= (file->nbytes - file->pos);
-	if (file->curOffset < 0)	/* handle possible segment crossing */
+	file->common.curOffset -= (file->common.nbytes - file->common.pos);
+	if (file->common.curOffset < 0) /* handle possible segment crossing */
 	{
-		file->curFile--;
-		Assert(file->curFile >= 0);
-		file->curOffset += MAX_PHYSICAL_FILESIZE;
+		file->common.curFile--;
+		Assert(file->common.curFile >= 0);
+		file->common.curOffset += buffile_max_filesize;
 	}
 
 	/*
 	 * Now we can set the buffer empty without changing the logical position
 	 */
-	file->pos = 0;
-	file->nbytes = 0;
+	file->common.pos = 0;
+	file->common.nbytes = 0;
 }
 
 /*
- * BufFileRead
+ * BufFileDumpBufferEncrypted
  *
- * Like fread() except we assume 1-byte element size and report I/O errors via
- * ereport().
+ * Encrypt buffer and dump it. The functionality is sufficiently different
+ * from BufFileDumpBuffer to be implemented as a separate function. The most
+ * notable difference is that no loop is needed here.
  */
-size_t
-BufFileRead(BufFile *file, void *ptr, size_t size)
+static void
+BufFileDumpBufferEncrypted(BufFile *file)
 {
-	size_t		nread = 0;
-	size_t		nthistime;
+	char		tweak[TWEAK_SIZE];
+	int			bytestowrite;
+	File		thisfile;
 
-	BufFileFlush(file);
+	/*
+	 * Caller's responsibility.
+	 */
+	Assert(file->common.pos <= file->common.nbytes);
 
-	while (size > 0)
+	/*
+	 * See comments in BufFileLoadBuffer();
+	 */
+	Assert(file->common.curOffset % BLCKSZ == 0);
+
+	/*
+	 * Advance to next component file if necessary and possible.
+	 */
+	if (file->common.curOffset >= buffile_max_filesize)
 	{
-		if (file->pos >= file->nbytes)
+		while (file->common.curFile + 1 >= file->numFiles)
+			extendBufFile(file);
+		file->common.curFile++;
+		file->common.curOffset = 0L;
+	}
+
+	/*
+	 * This condition plus the alignment of curOffset to BLCKSZ (checked
+	 * above) ensure that the encrypted buffer never crosses component file
+	 * boundary.
+	 */
+	Assert((buffile_max_filesize % BLCKSZ) == 0);
+
+	/*
+	 * Encrypted data is dumped all at once.
+	 *
+	 * Unlike BufFileDumpBuffer(), we don't have to check here how much bytes
+	 * is available in the segment. According to the assertions above,
+	 * currOffset should be lower than buffile_max_filesize by non-zero
+	 * multiple of BLCKSZ.
+	 */
+	bytestowrite = BLCKSZ;
+
+	/*
+	 * The amount of data encrypted must be a multiple of ENCRYPTION_BLOCK. We
+	 * meet this condition simply by encrypting the whole buffer.
+	 *
+	 * XXX Alternatively we could encrypt only as few encryption blocks that
+	 * encompass file->common.nbyte bytes, but then we'd have to care how many
+	 * blocks should be decrypted: decryption of the unencrypted trailing
+	 * zeroes produces garbage, which can be a problem if lseek() created
+	 * "holes" in the file. Such a hole should be read as a sequence of
+	 * zeroes.
+	 */
+	BufFileTweak(tweak, &file->common, false);
+
+	encrypt_block(file->common.buffer.data,
+				  encrypt_buf.data,
+				  BLCKSZ,
+				  tweak,
+				  InvalidXLogRecPtr,
+				  InvalidBlockNumber,
+				  EDK_BUFFILE);
+
+	thisfile = file->files[file->common.curFile];
+	bytestowrite = FileWrite(thisfile,
+							 encrypt_buf.data,
+							 bytestowrite,
+							 file->common.curOffset,
+							 WAIT_EVENT_BUFFILE_WRITE,
+							 ERROR);
+	if (bytestowrite <= 0 || bytestowrite != BLCKSZ)
+		return;				/* failed to write */
+
+	file->common.curOffset += bytestowrite;
+	pgBufferUsage.temp_blks_written++;
+
+	/*
+	 * The number of useful bytes needs to be written at the end of each
+	 * encrypted segment of a shared file so that the other backends know
+	 * how many bytes of the last buffer are useful.
+	 */
+	if (file->fileset != NULL)
+	{
+		off_t		useful;
+
+		/*
+		 * nuseful may be increased earlier than numFiles but not later, so
+		 * the corresponding entry should already exist in ->useful.
+		 */
+		Assert(file->common.curFile < file->common.nuseful);
+
+		/*
+		 * The number of useful bytes in the current segment file.
+		 */
+		useful = file->common.useful[file->common.curFile];
+
+		/*
+		 * Have we dumped the last buffer of the segment, i.e. the one that
+		 * can contain padding?
+		 */
+		if (file->common.curOffset >= useful)
 		{
-			/* Try to load more data into buffer. */
-			file->curOffset += file->pos;
-			file->pos = 0;
-			file->nbytes = 0;
-			BufFileLoadBuffer(file);
-			if (file->nbytes <= 0)
-				break;			/* no more data available */
+			int			bytes_extra;
+
+			/*
+			 * Write the number of useful bytes in the segment.
+			 *
+			 * Do not increase curOffset afterwards. Thus we ensure that the
+			 * next buffer appended will overwrite the "useful" value just
+			 * written, instead of being appended to it.
+			 */
+			bytes_extra = FileWrite(file->files[file->common.curFile],
+									(char *) &useful,
+									sizeof(useful),
+									file->common.curOffset,
+									WAIT_EVENT_BUFFILE_WRITE,
+									ERROR);
+			if (bytes_extra != sizeof(useful))
+				return;		/* failed to write */
 		}
+	}
+	file->common.dirty = false;
 
-		nthistime = file->nbytes - file->pos;
-		if (nthistime > size)
-			nthistime = size;
-		Assert(nthistime > 0);
+	if (file->common.pos >= BLCKSZ)
+	{
+		Assert(file->common.pos == BLCKSZ);
 
-		memcpy(ptr, file->buffer.data + file->pos, nthistime);
+		/*
+		 * curOffset points to the beginning of the next buffer, so just reset
+		 * pos and nbytes.
+		 */
+		file->common.pos = 0;
+		file->common.nbytes = 0;
 
-		file->pos += nthistime;
-		ptr = (void *) ((char *) ptr + nthistime);
-		size -= nthistime;
-		nread += nthistime;
+		/* See makeBufFile() */
+		MemSet(file->common.buffer.data, 0, BLCKSZ);
+	}
+	else
+	{
+		/*
+		 * Move curOffset to the beginning of the just-written buffer and
+		 * preserve pos.
+		 */
+		file->common.curOffset -= BLCKSZ;
+
+		/*
+		 * At least pos bytes should be written even if the first change since
+		 * now appears at pos == nbytes, but in fact the whole buffer will be
+		 * written regardless pos. This is the price we pay for the choosing
+		 * BLCKSZ as the I/O unit for encrypted data.
+		 */
+		file->common.nbytes = BLCKSZ;
 	}
+}
 
-	return nread;
+/*
+ * BufFileRead
+ *
+ * Like fread() except we assume 1-byte element size.
+ */
+size_t
+BufFileRead(BufFile *file, void *ptr, size_t size)
+{
+	return BufFileReadCommon(&file->common, ptr, size, false);
 }
 
 /*
@@ -581,44 +966,7 @@ BufFileRead(BufFile *file, void *ptr, size_t size)
 size_t
 BufFileWrite(BufFile *file, void *ptr, size_t size)
 {
-	size_t		nwritten = 0;
-	size_t		nthistime;
-
-	Assert(!file->readOnly);
-
-	while (size > 0)
-	{
-		if (file->pos >= BLCKSZ)
-		{
-			/* Buffer full, dump it out */
-			if (file->dirty)
-				BufFileDumpBuffer(file);
-			else
-			{
-				/* Hmm, went directly from reading to writing? */
-				file->curOffset += file->pos;
-				file->pos = 0;
-				file->nbytes = 0;
-			}
-		}
-
-		nthistime = BLCKSZ - file->pos;
-		if (nthistime > size)
-			nthistime = size;
-		Assert(nthistime > 0);
-
-		memcpy(file->buffer.data + file->pos, ptr, nthistime);
-
-		file->dirty = true;
-		file->pos += nthistime;
-		if (file->nbytes < file->pos)
-			file->nbytes = file->pos;
-		ptr = (void *) ((char *) ptr + nthistime);
-		size -= nthistime;
-		nwritten += nthistime;
-	}
-
-	return nwritten;
+	return BufFileWriteCommon(&file->common, ptr, size, false);
 }
 
 /*
@@ -627,12 +975,34 @@ BufFileWrite(BufFile *file, void *ptr, size_t size)
  * Like fflush(), except that I/O errors are reported with ereport().
  */
 static void
-BufFileFlush(BufFile *file)
+BufFileFlush(BufFileCommon *file, bool is_transient)
 {
-	if (file->dirty)
-		BufFileDumpBuffer(file);
+	if (!file->dirty)
+		return;
+
+	if (!is_transient)
+	{
+		if (!data_encrypted)
+			BufFileDumpBuffer((BufFile *) file);
+		else
+			BufFileDumpBufferEncrypted((BufFile *) file);
+
+		Assert(!file->dirty);
+	}
+	else
+	{
+		TransientBufFile *tf = (TransientBufFile *) file;
+
+		BufFileDumpBufferTransient(tf);
 
-	Assert(!file->dirty);
+		if (file->dirty)
+		{
+			/* Only reached if tf->elevel < ERROR */
+			ereport(tf->elevel,
+					(errcode_for_file_access(),
+					 errmsg("could not flush file \"%s\": %m", tf->path)));
+		}
+	}
 }
 
 /*
@@ -667,8 +1037,8 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 			 * fileno. Note that large offsets (> 1 gig) risk overflow in this
 			 * add, unless we have 64-bit off_t.
 			 */
-			newFile = file->curFile;
-			newOffset = (file->curOffset + file->pos) + offset;
+			newFile = file->common.curFile;
+			newOffset = (file->common.curOffset + file->common.pos) + offset;
 			break;
 #ifdef NOT_USED
 		case SEEK_END:
@@ -683,11 +1053,11 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 	{
 		if (--newFile < 0)
 			return EOF;
-		newOffset += MAX_PHYSICAL_FILESIZE;
+		newOffset += buffile_max_filesize;
 	}
-	if (newFile == file->curFile &&
-		newOffset >= file->curOffset &&
-		newOffset <= file->curOffset + file->nbytes)
+	if (newFile == file->common.curFile &&
+		newOffset >= file->common.curOffset &&
+		newOffset <= file->common.curOffset + file->common.nbytes)
 	{
 		/*
 		 * Seek is to a point within existing buffer; we can just adjust
@@ -695,11 +1065,11 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 		 * whether reading or writing, but buffer remains dirty if we were
 		 * writing.
 		 */
-		file->pos = (int) (newOffset - file->curOffset);
+		file->common.pos = (int) (newOffset - file->common.curOffset);
 		return 0;
 	}
 	/* Otherwise, must reposition buffer, so flush any dirty data */
-	BufFileFlush(file);
+	BufFileFlush(&file->common, false);
 
 	/*
 	 * At this point and no sooner, check for seek past last segment. The
@@ -711,33 +1081,67 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 	if (newFile == file->numFiles && newOffset == 0)
 	{
 		newFile--;
-		newOffset = MAX_PHYSICAL_FILESIZE;
+		newOffset = buffile_max_filesize;
 	}
-	while (newOffset > MAX_PHYSICAL_FILESIZE)
+	while (newOffset > buffile_max_filesize)
 	{
 		if (++newFile >= file->numFiles)
 			return EOF;
-		newOffset -= MAX_PHYSICAL_FILESIZE;
+		newOffset -= buffile_max_filesize;
 	}
 	if (newFile >= file->numFiles)
 		return EOF;
 	/* Seek is OK! */
-	file->curFile = newFile;
-	file->curOffset = newOffset;
-	file->pos = 0;
-	file->nbytes = 0;
-	return 0;
-}
+	file->common.curFile = newFile;
+	if (!data_encrypted)
+	{
+		file->common.curOffset = newOffset;
+		file->common.pos = 0;
+		file->common.nbytes = 0;
+	}
+	else
+	{
+		/*
+		 * Offset of an encrypted buffer must be a multiple of BLCKSZ.
+		 */
+		file->common.pos = newOffset % BLCKSZ;
+		file->common.curOffset = newOffset - file->common.pos;
 
-void
-BufFileTell(BufFile *file, int *fileno, off_t *offset)
-{
-	*fileno = file->curFile;
-	*offset = file->curOffset + file->pos;
-}
+		/*
+		 * BufFileLoadBuffer() will set nbytes iff it can read something.
+		 */
+		file->common.nbytes = 0;
 
-/*
- * BufFileSeekBlock --- block-oriented seek
+		/*
+		 * Load and decrypt the existing part of the buffer.
+		 */
+		BufFileLoadBuffer(file);
+		if (file->common.nbytes == 0)
+		{
+			/*
+			 * The data requested is not in the file, but this is not an
+			 * error.
+			 */
+			return 0;
+		}
+
+		/*
+		 * The whole buffer should have been loaded.
+		 */
+		Assert(file->common.nbytes == BLCKSZ);
+	}
+	return 0;
+}
+
+void
+BufFileTell(BufFile *file, int *fileno, off_t *offset)
+{
+	*fileno = file->common.curFile;
+	*offset = file->common.curOffset + file->common.pos;
+}
+
+/*
+ * BufFileSeekBlock --- block-oriented seek
  *
  * Performs absolute seek to the start of the n'th BLCKSZ-sized block of
  * the file.  Note that users of this interface will fail if their files
@@ -751,11 +1155,120 @@ int
 BufFileSeekBlock(BufFile *file, long blknum)
 {
 	return BufFileSeek(file,
-					   (int) (blknum / BUFFILE_SEG_SIZE),
-					   (off_t) (blknum % BUFFILE_SEG_SIZE) * BLCKSZ,
+					   (int) (blknum / buffile_seg_blocks),
+					   (off_t) (blknum % buffile_seg_blocks) * BLCKSZ,
 					   SEEK_SET);
 }
 
+static void
+BufFileTweak(char *tweak, BufFileCommon *file, bool is_transient)
+{
+	uint64		block;
+
+	/*
+	 * The unused bytes should always be defined.
+	 */
+	memset(tweak, 0, TWEAK_SIZE);
+
+	if (!is_transient)
+	{
+		BufFile    *tmpfile = (BufFile *) file;
+		pid_t		pid;
+		uint32		number;
+		int			curFile;
+		int		pid_bytes;
+		char	*c = tweak;
+
+/* Only this part of the PID fits into the tweak. */
+#define PID_BYTES_USABLE	4
+
+		if (tmpfile->fileset)
+		{
+			pid = tmpfile->fileset->creator_pid;
+			number = tmpfile->fileset->number;
+		}
+		else
+		{
+			pid = MyProcPid;
+			number = tmpfile->number;
+		}
+
+		curFile = file->curFile;
+
+		/*
+		 * If the file was produced by BufFileAppend(), we need the original
+		 * curFile, as it was used originally for encryption.
+		 */
+		if (tmpfile->segnos)
+			curFile = tmpfile->segnos[curFile];
+
+		block = curFile * buffile_seg_blocks + file->curOffset / BLCKSZ;
+
+		StaticAssertStmt(PID_BYTES_USABLE + sizeof(number) + sizeof(block)
+						 <= TWEAK_SIZE,
+						 "tweak components do not fit into TWEAK_SIZE");
+
+		/*
+		 * The tweak consists of PID of the owning backend (the leader backend
+		 * in the case of parallel query processing), number within the PID
+		 * and block number.
+		 *
+		 * There's only room for PID_BYTES_USABLE bytes of the PID. Use the
+		 * less significant part so that PID increment always causes tweak
+		 * change.
+		 */
+		pid_bytes = Min(sizeof(pid), PID_BYTES_USABLE);
+#ifdef WORDS_BIGENDIAN
+		memcpy(c, ((char *) &pid) + sizeof(pid) - pid_bytes, pid_bytes);
+#else
+		memcpy(c, &pid, pid_bytes);
+#endif
+		c += pid_bytes;
+		memcpy(c, &number, sizeof(number));
+		c += sizeof(number);
+		memcpy(c, &block, sizeof(block));
+	}
+	else
+	{
+		TransientBufFile *transfile = (TransientBufFile *) file;
+
+		StaticAssertStmt(TWEAK_BASE_SIZE + sizeof(block) <= TWEAK_SIZE,
+						 "tweak components do not fit into TWEAK_SIZE");
+
+		/* The path-dependent part. */
+		memcpy(tweak, transfile->tweakBase, TWEAK_BASE_SIZE);
+		tweak += TWEAK_BASE_SIZE;
+
+		/* The block-dependent part. */
+		block = file->curOffset / BLCKSZ;
+		*((uint64 *) tweak) = block;
+	}
+}
+
+/*
+ * Make sure that BufFile.useful array has the required size.
+ */
+static void
+ensureUsefulArraySize(BufFileCommon *file, int required)
+{
+	/*
+	 * Does the array already have enough space?
+	 */
+	if (required <= file->nuseful)
+		return;
+
+	/*
+	 * It shouldn't be possible to jump beyond the end of the last segment,
+	 * i.e. skip more than 1 segment.
+	 */
+	Assert(file->nuseful + 1 == required);
+
+	file->useful = (off_t *)
+		repalloc(file->useful, required * sizeof(off_t));
+	file->useful[file->nuseful] = 0L;
+	file->nuseful++;
+}
+
 #ifdef NOT_USED
 /*
  * BufFileTellBlock --- block-oriented tell
@@ -767,8 +1280,8 @@ BufFileTellBlock(BufFile *file)
 {
 	long		blknum;
 
-	blknum = (file->curOffset + file->pos) / BLCKSZ;
-	blknum += file->curFile * BUFFILE_SEG_SIZE;
+	blknum = (file->common.curOffset + file->common.pos) / BLCKSZ;
+	blknum += file->common.curFile * buffile_seg_blocks;
 	return blknum;
 }
 
@@ -787,16 +1300,34 @@ BufFileSize(BufFile *file)
 
 	Assert(file->fileset != NULL);
 
-	/* Get the size of the last physical file. */
-	lastFileSize = FileSize(file->files[file->numFiles - 1]);
-	if (lastFileSize < 0)
-		ereport(ERROR,
-				(errcode_for_file_access(),
-				 errmsg("could not determine size of temporary file \"%s\" from BufFile \"%s\": %m",
-						FilePathName(file->files[file->numFiles - 1]),
-						file->name)));
+	if (!data_encrypted)
+	{
+		/* Get the size of the last physical file. */
+		lastFileSize = FileSize(file->files[file->numFiles - 1]);
+		if (lastFileSize < 0)
+			ereport(ERROR,
+					(errcode_for_file_access(),
+					 errmsg("could not determine size of temporary file \"%s\" from BufFile \"%s\": %m",
+							FilePathName(file->files[file->numFiles - 1]),
+							file->name)));
+	}
+	else
+	{
+		/*
+		 * "useful" should be initialized even for shared file, see
+		 * BufFileOpenShared().
+		 */
+		Assert(file->common.useful != NULL &&
+			   file->common.nuseful >= file->numFiles);
+
+		/*
+		 * The number of useful bytes in the segment is what caller is
+		 * interested in.
+		 */
+		lastFileSize = file->common.useful[file->common.nuseful - 1];
+	}
 
-	return ((file->numFiles - 1) * (int64) MAX_PHYSICAL_FILESIZE) +
+	return ((file->numFiles - 1) * (int64) buffile_max_filesize) +
 		lastFileSize;
 }
 
@@ -809,11 +1340,10 @@ BufFileSize(BufFile *file)
  * called here first.  Resource owners for source and target must match,
  * too.
  *
- * This operation works by manipulating lists of segment files, so the
- * file content is always appended at a MAX_PHYSICAL_FILESIZE-aligned
- * boundary, typically creating empty holes before the boundary.  These
- * areas do not contain any interesting data, and cannot be read from by
- * caller.
+ * This operation works by manipulating lists of segment files, so the file
+ * content is always appended at a buffile_max_filesize-aligned boundary,
+ * typically creating empty holes before the boundary.  These areas do not
+ * contain any interesting data, and cannot be read from by caller.
  *
  * Returns the block number within target where the contents of source
  * begins.  Caller should apply this as an offset when working off block
@@ -822,13 +1352,13 @@ BufFileSize(BufFile *file)
 long
 BufFileAppend(BufFile *target, BufFile *source)
 {
-	long		startBlock = target->numFiles * BUFFILE_SEG_SIZE;
+	long		startBlock = target->numFiles * buffile_seg_blocks;
 	int			newNumFiles = target->numFiles + source->numFiles;
 	int			i;
 
 	Assert(target->fileset != NULL);
-	Assert(source->readOnly);
-	Assert(!source->dirty);
+	Assert(source->common.readOnly);
+	Assert(!source->common.dirty);
 	Assert(source->fileset != NULL);
 
 	if (target->resowner != source->resowner)
@@ -838,7 +1368,897 @@ BufFileAppend(BufFile *target, BufFile *source)
 		repalloc(target->files, sizeof(File) * newNumFiles);
 	for (i = target->numFiles; i < newNumFiles; i++)
 		target->files[i] = source->files[i - target->numFiles];
+
+	if (data_encrypted)
+		BufFileAppendMetadata(target, source);
+
 	target->numFiles = newNumFiles;
 
 	return startBlock;
 }
+
+/*
+ * Add encryption-specific metadata of the source file to the target.
+ */
+static void
+BufFileAppendMetadata(BufFile *target, BufFile *source)
+{
+	int			newNumFiles = target->numFiles + source->numFiles;
+	int			newNUseful = target->common.nuseful + source->common.nuseful;
+	int	i;
+
+	/*
+	 * XXX As the typical use case is that parallel workers expose file to the
+	 * leader, can we expect both target and source to have been exported,
+	 * i.e. flushed? In such a case "nuseful" would have to be equal to
+	 * "numFiles" for both input files and the code could get a bit
+	 * simpler. It seems that at least source should be flushed, as
+	 * source->readOnly is expected to be true above.
+	 */
+	target->common.useful = (off_t *)
+		repalloc(target->common.useful, sizeof(off_t) * newNUseful);
+
+	for (i = target->common.nuseful; i < newNUseful; i++)
+		target->common.useful[i] = source->common.useful[i - target->common.nuseful];
+	target->common.nuseful = newNUseful;
+
+	/*
+	 * File segments can appear at different position due to concatenation, so
+	 * make sure we remember the original positions for the sake of encryption
+	 * tweak.
+	 */
+	if (target->segnos == NULL)
+	{
+		/*
+		 * If the target does not have the array yet, allocate it for both
+		 * target and source and initialize the target part.
+		 */
+		target->segnos = (off_t *) palloc(newNumFiles * sizeof(off_t));
+		for (i = 0; i < target->numFiles; i++)
+			target->segnos[i] = i;
+	}
+	else
+	{
+		/*
+		 * Use the existing target part and add space for the source part.
+		 */
+		target->segnos = (off_t *) repalloc(target->segnos,
+											newNumFiles * sizeof(off_t));
+	}
+
+	/*
+	 * The source segment number either equals to (0-based) index of the
+	 * segment, or to an element of an already existing array.
+	 */
+	for (i = target->numFiles; i < newNumFiles; i++)
+	{
+		off_t		segno = i - target->numFiles;
+
+		if (source->segnos == NULL)
+			target->segnos[i] = segno;
+		else
+			target->segnos[i] = source->segnos[segno];
+	}
+}
+
+/*
+ * Open TransientBufFile at given path or create one if it does not
+ * exist. User will be allowed either to write to the file or to read from it,
+ * according to fileFlags, but not both.
+ *
+ * tweak_base should contain the first eight bytes of the encryption tweak
+ * that is common to all buffers of the file.
+ */
+TransientBufFile *
+BufFileOpenTransient(const char *path, int fileFlags,
+					 char tweak_base[TWEAK_BASE_SIZE],
+					 int elevel)
+{
+	bool		readOnly;
+	bool		append = false;
+	TransientBufFile *file;
+	BufFileCommon *fcommon;
+	File		vfd;
+	off_t		size;
+
+	/* Either read or write mode, but not both. */
+	Assert((fileFlags & O_RDWR) == 0);
+
+	/* Check whether user wants read or write access. */
+	readOnly = (fileFlags & O_WRONLY) == 0;
+
+	if (data_encrypted)
+	{
+		/*
+		 * In the encryption case, even if user will only be allowed to write,
+		 * internally we also need to read, see below.
+		 */
+		fileFlags &= ~O_WRONLY;
+		fileFlags |= O_RDWR;
+
+		/*
+		 * We can only emulate the append behavior by setting curOffset to
+		 * file size because if the underlying file was opened in append mode,
+		 * we could not rewrite the old value of file->common.useful[0] with
+		 * data.
+		 */
+		if (fileFlags & O_APPEND)
+		{
+			append = true;
+			fileFlags &= ~O_APPEND;
+		}
+	}
+
+	/*
+	 * Append mode for read access is not useful, so don't bother implementing
+	 * it.
+	 */
+	Assert(!(readOnly && append));
+
+	errno = 0;
+	vfd = PathNameOpenFile(path, fileFlags);
+	if (vfd < 0)
+	{
+		/*
+		 * If the file is not there, caller should be able to handle the
+		 * condition on his own.
+		 */
+		if (errno == ENOENT)
+			return NULL;
+
+		ereport(elevel,
+				(errcode_for_file_access(),
+				 errmsg("could not open file \"%s\": %m", path)));
+		return NULL;
+	}
+
+	file = (TransientBufFile *) palloc0(sizeof(TransientBufFile));
+	fcommon = &file->common;
+	fcommon->dirty = false;
+	fcommon->pos = 0;
+	fcommon->nbytes = 0;
+	fcommon->readOnly = readOnly;
+	fcommon->append = append;
+	fcommon->curFile = 0;
+	fcommon->useful = (off_t *) palloc0(sizeof(off_t));
+	fcommon->nuseful = 1;
+	file->vfd = vfd;
+	file->path = pstrdup(path);
+	file->elevel = elevel;
+
+	if (data_encrypted)
+		memcpy(file->tweakBase, tweak_base, TWEAK_BASE_SIZE);
+
+	size = FileSize(file->vfd);
+	if (size < 0)
+	{
+		ereport(file->elevel,
+				(errcode_for_file_access(),
+				 errmsg("could not initialize TransientBufFile for file \"%s\": %m",
+						path)));
+		return NULL;
+	}
+
+	if (fcommon->append)
+	{
+		/* Position the buffer at the end of the file. */
+		fcommon->curOffset = size;
+	}
+	else
+		fcommon->curOffset = 0L;
+
+	/*
+	 * Encrypted transient file should, at its end, contain information on the
+	 * number of useful bytes in the last buffer.
+	 */
+	if (data_encrypted)
+	{
+		off_t		pos = size;
+		int			nbytes;
+
+		/* No metadata in an empty file. */
+		if (pos == 0)
+			return file;
+
+		pos -= sizeof(off_t);
+
+		/*
+		 * The word must immediately follow the last buffer of the segment.
+		 */
+		if (pos < 0 || pos % BLCKSZ != 0)
+		{
+			ereport(elevel,
+					(errcode_for_file_access(),
+					 errmsg("could not find padding info in TransientBufFile \"%s\": %m",
+							path)));
+			pfree(fcommon->useful);
+			pfree(file);
+			return NULL;
+		}
+
+		errno = 0;
+		nbytes = FileRead(file->vfd,
+						  (char *) &fcommon->useful[0],
+						  sizeof(off_t),
+						  pos,
+						  WAIT_EVENT_BUFFILE_READ);
+		if (nbytes != sizeof(off_t))
+		{
+			/* Like above. */
+			ereport(elevel,
+					(errcode_for_file_access(),
+					 errmsg("could not read padding info from TransientBufFile \"%s\": %m",
+							path)));
+			pfree(fcommon->useful);
+			pfree(file);
+			return NULL;
+		}
+		Assert(fcommon->useful[0] > 0);
+
+		if (fcommon->append)
+		{
+			off_t		useful = fcommon->useful[0];
+
+			/*
+			 * If new buffer should be added, make sure it will end up
+			 * immediately after the last complete one, and also that the next
+			 * write position follows the last valid byte.
+			 */
+			fcommon->pos = useful % BLCKSZ;
+			fcommon->curOffset = useful - fcommon->pos;
+
+			/* Load the existing contents of the buffer. */
+			BufFileLoadBufferTransient(file);
+			if (file->common.nbytes < 0)
+				return NULL;
+		}
+	}
+
+	return file;
+}
+
+/*
+ * Close a TransientBufFile.
+ */
+void
+BufFileCloseTransient(TransientBufFile *file)
+{
+	/* Flush any unwritten data. */
+	if (!file->common.readOnly &&
+		file->common.dirty && file->common.nbytes > 0)
+	{
+		BufFileDumpBufferTransient(file);
+
+		if (file->common.dirty)
+		{
+			/* Raise WARNING deliberately, even if file->elevel is ERROR. */
+			ereport(WARNING,
+					(errcode_for_file_access(),
+					 errmsg("could not flush file \"%s\": %m", file->path)));
+		}
+	}
+
+	FileClose(file->vfd);
+
+	if (data_encrypted)
+		pfree(file->common.useful);
+	pfree(file->path);
+	pfree(file);
+}
+
+File
+BufFileTransientGetVfd(TransientBufFile *file)
+{
+	return file->vfd;
+}
+
+/*
+ * Load some data into buffer, if possible, starting from file->offset.  At
+ * call, must have dirty = false, pos and nbytes = 0.  On exit, nbytes is
+ * number of bytes loaded.
+ */
+static void
+BufFileLoadBufferTransient(TransientBufFile *file)
+{
+	Assert(!file->common.dirty);
+
+	/* See comments in BufFileLoadBuffer(). */
+	if (data_encrypted)
+		MemSet(file->common.buffer.data, 0, BLCKSZ);
+retry:
+
+	/*
+	 * Read whatever we can get, up to a full bufferload.
+	 */
+	errno = 0;
+	file->common.nbytes = FileRead(file->vfd,
+								   file->common.buffer.data,
+								   sizeof(file->common.buffer),
+								   file->common.curOffset,
+								   WAIT_EVENT_BUFFILE_READ);
+
+	if (file->common.nbytes < 0)
+	{
+		/*
+		 * See comments in FileRead()
+		 */
+#ifdef WIN32
+		DWORD		error = GetLastError();
+
+		switch (error)
+		{
+			case ERROR_NO_SYSTEM_RESOURCES:
+				pg_usleep(1000L);
+				errno = EINTR;
+				break;
+			default:
+				_dosmaperr(error);
+				break;
+		}
+#endif
+
+		/* OK to retry if interrupted */
+		if (errno == EINTR)
+			goto retry;
+
+		return;
+	}
+	/* we choose not to advance offset here */
+
+	if (data_encrypted && file->common.nbytes > 0)
+	{
+		char		tweak[TWEAK_SIZE];
+		int			nbytes = file->common.nbytes;
+
+		/*
+		 * The encrypted file can only consist of whole number of our
+		 * encryption units. (Only the whole buffers are dumped / loaded.) The
+		 * only exception is that we're at the end of segment file and found
+		 * the word indicating the number of useful bytes in the segment. This
+		 * can only happen for shared file.
+		 */
+		if (nbytes % BLCKSZ != 0)
+		{
+			Assert(nbytes == sizeof(off_t));
+
+			/*
+			 * This metadata his hidden to caller, so all he needs to know
+			 * that there's no real data at the end of the file.
+			 */
+			file->common.nbytes = 0;
+			return;
+		}
+
+		/* Decrypt the whole block at once. */
+		BufFileTweak(tweak, &file->common, true);
+		decrypt_block(file->common.buffer.data,
+					  file->common.buffer.data,
+					  BLCKSZ,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_BUFFILE);
+
+#ifdef	USE_ASSERT_CHECKING
+
+		/*
+		 * The unused part of the buffer which we've read from disk and
+		 * decrypted should only contain zeroes, as explained in front of the
+		 * MemSet() call.
+		 */
+		{
+			int			i;
+
+			for (i = file->common.nbytes; i < BLCKSZ; i++)
+				Assert(file->common.buffer.data[i] == 0);
+		}
+#endif							/* USE_ASSERT_CHECKING */
+	}
+}
+
+/*
+ * Write contents of a transient file buffer to disk.
+ */
+static void
+BufFileDumpBufferTransient(TransientBufFile *file)
+{
+	int			bytestowrite,
+				nwritten;
+	char	   *write_ptr;
+
+	/* This function should only be needed during write access ... */
+	Assert(!file->common.readOnly);
+
+	/* ... and if there's some work to do. */
+	Assert(file->common.dirty);
+	Assert(file->common.nbytes > 0);
+
+	if (!data_encrypted)
+	{
+		write_ptr = file->common.buffer.data;
+		bytestowrite = file->common.nbytes;
+	}
+	else
+	{
+		char		tweak[TWEAK_SIZE];
+
+		/*
+		 * Encrypt the whole buffer, see comments in BufFileDumpBuffer().
+		 */
+		BufFileTweak(tweak, &file->common, true);
+		encrypt_block(file->common.buffer.data,
+					  encrypt_buf.data,
+					  BLCKSZ,
+					  tweak,
+					  InvalidXLogRecPtr,
+					  InvalidBlockNumber,
+					  EDK_BUFFILE);
+		write_ptr = encrypt_buf.data;
+		bytestowrite = BLCKSZ;
+	}
+retry:
+	errno = 0;
+	nwritten = FileWrite(file->vfd,
+						 write_ptr,
+						 bytestowrite,
+						 file->common.curOffset,
+						 WAIT_EVENT_BUFFILE_WRITE,
+						 file->elevel);
+
+	/* if write didn't set errno, assume problem is no disk space */
+	if (nwritten != bytestowrite && errno == 0)
+		errno = ENOSPC;
+
+	if (nwritten < 0)
+	{
+		/*
+		 * See comments in FileRead()
+		 */
+#ifdef WIN32
+		DWORD		error = GetLastError();
+
+		switch (error)
+		{
+			case ERROR_NO_SYSTEM_RESOURCES:
+				pg_usleep(1000L);
+				errno = EINTR;
+				break;
+			default:
+				_dosmaperr(error);
+				break;
+		}
+#endif
+
+		/* OK to retry if interrupted */
+		if (errno == EINTR)
+			goto retry;
+
+		return;					/* failed to write */
+	}
+
+	file->common.curOffset += nwritten;
+
+	if (data_encrypted)
+	{
+		off_t		useful;
+
+		/*
+		 * The number of useful bytes in file.
+		 */
+		useful = file->common.useful[0];
+
+		/*
+		 * Have we dumped the last buffer of the segment, i.e. the one that
+		 * can contain padding?
+		 */
+		if (file->common.curOffset >= useful)
+		{
+			int			bytes_extra;
+
+			/*
+			 * Write the number of useful bytes in the file
+			 *
+			 * Do not increase curOffset afterwards. Thus we ensure that the
+			 * next buffer appended will overwrite the "useful" value just
+			 * written, instead of being appended to it.
+			 */
+			bytes_extra = FileWrite(file->vfd,
+									(char *) &useful,
+									sizeof(useful),
+									file->common.curOffset,
+									WAIT_EVENT_BUFFILE_WRITE,
+									file->elevel);
+			if (bytes_extra != sizeof(useful))
+				return;			/* failed to write */
+		}
+	}
+
+	file->common.dirty = false;
+
+	file->common.pos = 0;
+	file->common.nbytes = 0;
+}
+
+/*
+ * Like BufFileRead() except it receives pointer to TransientBufFile.
+ */
+size_t
+BufFileReadTransient(TransientBufFile *file, void *ptr, size_t size)
+{
+	return BufFileReadCommon(&file->common, ptr, size, true);
+}
+
+/*
+ * Like BufFileWrite() except it receives pointer to TransientBufFile.
+ */
+size_t
+BufFileWriteTransient(TransientBufFile *file, void *ptr, size_t size)
+{
+	return BufFileWriteCommon(&file->common, ptr, size, true);
+}
+
+/*
+ * BufFileReadCommon
+ *
+ * Functionality needed by both BufFileRead() and BufFileReadTransient().
+ */
+static size_t
+BufFileReadCommon(BufFileCommon *file, void *ptr, size_t size,
+				  bool is_transient)
+{
+	size_t		nread = 0;
+	size_t		nthistime;
+
+	if (file->dirty)
+	{
+		/*
+		 * Transient file currently does not allow both read and write access,
+		 * so this function should not see dirty buffer.
+		 */
+		Assert(!is_transient);
+
+		BufFileFlush(file, is_transient);
+
+		if (file->dirty)
+		{
+			TransientBufFile	*tf = (TransientBufFile *) file;
+
+			/*
+			 * BufFileFlush() should have thrown ERROR should have been raised
+			 * for !is_transient.
+			 */
+			Assert(is_transient);
+
+			/* Only reached if tf->elevel < ERROR */
+			ereport(tf->elevel,
+					(errcode_for_file_access(),
+					 errmsg("could not flush file \"%s\": %m", tf->path)));
+			return nread;
+		}
+	}
+
+	while (size > 0)
+	{
+		if (file->pos >= file->nbytes)
+		{
+			/*
+			 * Neither read nor write nor seek should leave pos greater than
+			 * nbytes, regardless the data is encrypted or not. pos can only
+			 * be greater if nbytes is zero --- this situation can be caused
+			 * by BufFileSeek().
+			 */
+			Assert(file->pos == file->nbytes || file->nbytes == 0);
+
+			/*
+			 * The Assert() above implies that pos is a whole multiple of
+			 * BLCKSZ, so curOffset has meet the same encryption-specific
+			 * requirement too.
+			 */
+			Assert(file->curOffset % BLCKSZ == 0 || !data_encrypted);
+
+			file->nbytes = 0;
+			/* Try to load more data into buffer. */
+			if (!data_encrypted || file->pos % BLCKSZ == 0)
+			{
+				file->curOffset += file->pos;
+				file->pos = 0;
+
+				if (!is_transient)
+					BufFileLoadBuffer((BufFile *) file);
+				else
+				{
+					BufFileLoadBufferTransient((TransientBufFile *) file);
+					/* Only reached if elevel < ERROR. */
+					if (file->nbytes < 0)
+						break;
+				}
+
+				if (file->nbytes <= 0)
+					break;		/* no more data available */
+			}
+			else
+			{
+				int			nbytes_orig = file->nbytes;
+
+				/*
+				 * Given that BLCKSZ is the I/O unit for encrypted data (see
+				 * comments in BufFileDumpBuffer), we cannot add pos to
+				 * curOffset because that would make it point outside block
+				 * boundary. The only thing we can do is to reload the whole
+				 * buffer and see if more data is eventually there than the
+				 * previous load has fetched.
+				 */
+				if (!is_transient)
+					BufFileLoadBuffer((BufFile *) file);
+				else
+				{
+					BufFileLoadBufferTransient((TransientBufFile *) file);
+					/* Only reached if elevel < ERROR. */
+					if (file->nbytes < 0)
+						break;
+				}
+
+				Assert(file->nbytes >= nbytes_orig);
+				if (file->nbytes == nbytes_orig)
+					break;		/* no more data available */
+			}
+		}
+
+		nthistime = file->nbytes - file->pos;
+
+		/*
+		 * The buffer can contain trailing zeroes because BLCKSZ is the I/O
+		 * unit for encrypted data. These are not available for reading.
+		 */
+		if (data_encrypted)
+		{
+			off_t		useful = file->useful[file->curFile];
+
+			/*
+			 * The criterion is whether the useful data ends within the
+			 * currently loaded buffer.
+			 */
+			if (useful < file->curOffset + BLCKSZ)
+			{
+				int			avail;
+
+				/*
+				 * Compute the number of bytes available in the current
+				 * buffer.
+				 */
+				avail = useful - file->curOffset;
+				Assert(avail >= 0);
+
+				/*
+				 * An empty buffer can exist, e.g. after a seek to the end of
+				 * the last component file.
+				 */
+				if (avail == 0)
+					break;
+
+				/*
+				 * Seek beyond the current EOF, which was not followed by
+				 * write, could have resulted in position outside the useful
+				 * data
+				 */
+				if (file->pos > avail)
+					break;
+
+				nthistime = avail - file->pos;
+				Assert(nthistime >= 0);
+
+				/*
+				 * Have we reached the end of the valid data?
+				 */
+				if (nthistime == 0)
+					break;
+			}
+		}
+
+		if (nthistime > size)
+			nthistime = size;
+		Assert(nthistime > 0);
+
+		memcpy(ptr, file->buffer.data + file->pos, nthistime);
+
+		file->pos += nthistime;
+		ptr = (void *) ((char *) ptr + nthistime);
+		size -= nthistime;
+		nread += nthistime;
+	}
+
+	return nread;
+}
+
+/*
+ * BufFileWriteCommon
+ *
+ * Functionality needed by both BufFileWrite() and BufFileWriteTransient().
+ */
+static size_t
+BufFileWriteCommon(BufFileCommon *file, void *ptr, size_t size,
+				   bool is_transient)
+{
+	size_t		nwritten = 0;
+	size_t		nthistime;
+
+	Assert(!file->readOnly);
+
+	while (size > 0)
+	{
+		if (file->pos >= BLCKSZ)
+		{
+			/* Buffer full, dump it out */
+			if (file->dirty)
+			{
+				if (!is_transient)
+				{
+					if (!data_encrypted)
+						BufFileDumpBuffer((BufFile *)file);
+					else
+					{
+#ifdef USE_ASSERT_CHECKING
+						int	fileno = file->curFile;
+#endif
+						int	off = file->curOffset;
+
+						BufFileDumpBufferEncrypted((BufFile *) file);
+
+						/*
+						 * If overwriting, load the next buffer first. Since
+						 * (unlike the unencrypted case) we only dump the
+						 * whole buffers so w/o the load the next dump could
+						 * overwrite even the part of the file that should
+						 * stay unchanged.
+						 */
+						if (!file->append && file->curOffset != off)
+						{
+							/*
+							 * curOffset must have advanced to the next block,
+							 * possibly in the next segment file.
+							 */
+							Assert(file->curOffset == (off + BLCKSZ) ||
+								   ((file->curFile == (fileno + 1)) &&
+									file->curOffset == BLCKSZ));
+
+							BufFileLoadBuffer((BufFile *) file);
+						}
+					}
+				}
+				else
+					BufFileDumpBufferTransient((TransientBufFile *) file);
+
+				if (file->dirty)
+					break;		/* I/O error */
+			}
+			else
+			{
+				Assert(!is_transient);
+
+				/*
+				 * Hmm, went directly from reading to writing?
+				 *
+				 * As pos should be exactly BLCKSZ, there is nothing special
+				 * to do about data_encrypted, except for zeroing the buffer.
+				 */
+				Assert(file->pos == BLCKSZ);
+
+				file->curOffset += file->pos;
+				file->pos = 0;
+				file->nbytes = 0;
+
+				/* See makeBufFile() */
+				if (data_encrypted)
+					MemSet(file->buffer.data, 0, BLCKSZ);
+			}
+
+			/*
+			 * If curOffset changed above, it should still meet the assumption
+			 * that buffer is the I/O unit for encrypted data.
+			 */
+			Assert(file->curOffset % BLCKSZ == 0 || !data_encrypted);
+		}
+
+		nthistime = BLCKSZ - file->pos;
+		if (nthistime > size)
+			nthistime = size;
+		Assert(nthistime > 0);
+
+		memcpy(file->buffer.data + file->pos, ptr, nthistime);
+
+		file->dirty = true;
+		file->pos += nthistime;
+		if (file->nbytes < file->pos)
+			file->nbytes = file->pos;
+
+		/*
+		 * Remember how many bytes of the file are valid - the rest is
+		 * padding.
+		 */
+		if (data_encrypted)
+			BufFileUpdateUsefulLength(file, is_transient);
+
+		ptr = (void *) ((char *) ptr + nthistime);
+		size -= nthistime;
+		nwritten += nthistime;
+	}
+
+	return nwritten;
+}
+
+/*
+ * Update information about the effective length of the file.
+ */
+static void
+BufFileUpdateUsefulLength(BufFileCommon *file, bool is_transient)
+{
+	off_t		new_useful;
+	int			fileno;
+
+	if (is_transient)
+
+	{
+		/*
+		 * Transient file is a single file on the disk, so the whole thing is
+		 * pretty simple.
+		 */
+		fileno = 0;
+
+		new_useful = file->curOffset + file->pos;
+		if (new_useful > file->useful[fileno])
+			file->useful[fileno] = new_useful;
+	}
+	else
+	{
+		fileno = file->curFile;
+
+		/*
+		 * curFile does not necessarily correspond to the offset: it can still
+		 * have the initial value if BufFileSeek() skipped the previous file
+		 * w/o dumping anything of it. While curFile will be fixed during the
+		 * next dump, we need valid fileno now.
+		 */
+		if (file->curOffset >= buffile_max_filesize)
+		{
+			/*
+			 * Even BufFileSeek() should not allow curOffset to become more
+			 * than buffile_max_filesize (if caller passes higher offset,
+			 * curFile gets increased instead).
+			 */
+			Assert(file->curOffset == buffile_max_filesize);
+
+			fileno++;
+		}
+
+		/*
+		 * fileno can now point to a segment that does not exist on disk yet.
+		 */
+		ensureUsefulArraySize(file, fileno + 1);
+
+		/*
+		 * Update the number of useful bytes in the underlying component file
+		 * if we've added any useful data.
+		 */
+		new_useful = file->curOffset;
+
+		/*
+		 * Make sure the offset is relative to the correct component file
+		 * (segment). If the write just crossed segment boundary, curOffset
+		 * can still point at the end of the previous segment, and so
+		 * new_useful is also relative to the start of that previous
+		 * segment. Make sure it's relative to the current (fileno) segment.
+		 */
+		if (file->curOffset % buffile_max_filesize == 0)
+			new_useful %= buffile_max_filesize;
+
+		/* Finalize the offset. */
+		new_useful += file->pos;
+
+		/*
+		 * Adjust the number of useful bytes in the file if needed.  This has
+		 * to happen immediately, independent from BufFileDumpBuffer(), so
+		 * that BufFileRead() works correctly anytime.
+		 */
+		if (new_useful > file->useful[fileno])
+			file->useful[fileno] = new_useful;
+	}
+}
diff --git a/src/backend/storage/file/encryption.c b/src/backend/storage/file/encryption.c
new file mode 100644
index 0000000000..3d799e9258
--- /dev/null
+++ b/src/backend/storage/file/encryption.c
@@ -0,0 +1,665 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.c
+ *	  This code handles encryption and decryption of data.
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ *
+ * See src/backend/storage/file/README.encryption for explanation of the
+ * design.
+ *
+ * IDENTIFICATION
+ *	  src/backend/storage/file/encryption.c
+ *
+ * NOTES
+ *		This file is compiled as both front-end and backend code, so the
+ *		FRONTEND macro must be used to distinguish the case if we need to
+ *		report error or if server-defined variable / function seems useful.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+#include "fmgr.h"
+
+#include <sys/stat.h>
+
+#include "access/xlog.h"
+#include "access/xlogdefs.h"
+#include "common/fe_memutils.h"
+#include "common/sha2.h"
+#include "common/string.h"
+#include "catalog/pg_class.h"
+#include "catalog/pg_control.h"
+#include "storage/bufpage.h"
+#include "storage/encryption.h"
+#include "utils/fmgrprotos.h"
+
+#ifndef FRONTEND
+#include "port.h"
+#include "storage/shmem.h"
+#include "storage/fd.h"
+#include "utils/memutils.h"
+#endif							/* FRONTEND */
+
+#ifdef USE_ENCRYPTION
+#include <openssl/conf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/opensslv.h>
+
+EVP_CIPHER_CTX *ctx_encrypt, *ctx_decrypt,
+	*ctx_encrypt_buffile, *ctx_decrypt_buffile;
+#endif							/* USE_ENCRYPTION */
+
+#ifndef FRONTEND
+ShmemEncryptionKey *encryption_key_shmem = NULL;
+#endif							/* FRONTEND */
+
+bool		data_encrypted = false;
+
+char encryption_verification[ENCRYPTION_SAMPLE_SIZE];
+
+bool	encryption_setup_done = false;
+
+PGAlignedBlock encrypt_buf;
+char	   *encrypt_buf_xlog = NULL;
+
+#ifdef USE_ENCRYPTION
+static void init_encryption_context(EVP_CIPHER_CTX **ctx_p, bool encrypt,
+									bool buffile);
+static void evp_error(void);
+#endif	/* USE_ENCRYPTION */
+
+#ifndef FRONTEND
+/*
+ * Report space needed for our shared memory area
+ */
+Size
+EncryptionShmemSize(void)
+{
+	return sizeof(ShmemEncryptionKey);
+}
+
+/*
+ * Initialize our shared memory area
+ */
+void
+EncryptionShmemInit(void)
+{
+	bool	found;
+
+	encryption_key_shmem = ShmemInitStruct("Cluster Encryption Key",
+										   EncryptionShmemSize(),
+										   &found);
+	if (!IsUnderPostmaster)
+	{
+		Assert(!found);
+
+		encryption_key_shmem->received = false;
+		encryption_key_shmem->empty = false;
+	}
+	else
+		Assert(found);
+}
+
+/*
+ * Read encryption key in hexadecimal form from stdin and store it in
+ * encryption_key variable.
+ */
+void
+read_encryption_key(read_encryption_key_cb read_char)
+{
+#ifdef USE_ENCRYPTION
+	char	buf[ENCRYPTION_KEY_CHARS];
+	int		read_len, c;
+
+	read_len = 0;
+	while ((c = (*read_char)()) != EOF && c != '\n')
+	{
+		if (read_len >= ENCRYPTION_KEY_CHARS)
+			ereport(FATAL, (errmsg("Encryption key is too long")));
+
+		buf[read_len++] = c;
+	}
+
+	if (read_len < ENCRYPTION_KEY_CHARS)
+		ereport(FATAL, (errmsg("Encryption key is too short")));
+
+	/* Turn the hexadecimal representation into an array of bytes. */
+	encryption_key_from_string(buf);
+
+#else  /* !USE_ENCRYPTION */
+	/*
+	 * If no encryption implementation is linked and caller requests
+	 * encryption, we should error out here and thus cause the calling process
+	 * to fail (preferably postmaster, so the child processes don't make the
+	 * same mistake).
+	 */
+	ereport(FATAL, (errmsg(ENCRYPTION_NOT_SUPPORTED_MSG)));
+#endif	/* USE_ENCRYPTION */
+}
+#endif							/* !FRONTEND */
+
+
+/*
+ * Initialize encryption subsystem for use. Must be called before any
+ * encryptable data is read from or written to data directory.
+ */
+void
+setup_encryption(void)
+{
+#ifdef USE_ENCRYPTION
+	/*
+	 * Setup OpenSSL.
+	 *
+	 * None of these functions should return a value or raise error.
+	 */
+	ERR_load_crypto_strings();
+	OpenSSL_add_all_algorithms();
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+	OPENSSL_config(NULL);
+#endif
+
+	init_encryption_context(&ctx_encrypt, true, false);
+	init_encryption_context(&ctx_decrypt, false, false);
+	init_encryption_context(&ctx_encrypt_buffile, true, true);
+	init_encryption_context(&ctx_decrypt_buffile, false, true);
+
+	/*
+	 * We need multiple pages here, so allocate the memory dynamically instead
+	 * of using PGAlignedBlock. That also ensures it'll be MAXALIGNed, which
+	 * is useful because the buffer will be used for I/O.
+	 *
+	 * Use TopMemoryContext because on server side this code is run by
+	 * postmaster and postmaster context gets freed after fork().
+	 */
+#ifndef FRONTEND
+	encrypt_buf_xlog = (char *) MemoryContextAlloc(TopMemoryContext,
+												   ENCRYPT_BUF_XLOG_SIZE);
+#else
+	encrypt_buf_xlog = (char *) palloc(ENCRYPT_BUF_XLOG_SIZE);
+#endif
+
+	encryption_setup_done = true;
+#else  /* !USE_ENCRYPTION */
+#ifndef FRONTEND
+	/*
+	 * If no encryption implementation is linked and caller requests
+	 * encryption, we should error out here and thus cause the calling process
+	 * to fail (preferably postmaster, so the child processes don't make the
+	 * same mistake).
+	 */
+	ereport(FATAL, (errmsg(ENCRYPTION_NOT_SUPPORTED_MSG)));
+#else
+	/* Front-end shouldn't actually get here, but be careful. */
+	fprintf(stderr, "%s\n", ENCRYPTION_NOT_SUPPORTED_MSG);
+	exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+#endif							/* USE_ENCRYPTION */
+}
+
+/*
+ * Encrypts a fixed value into *buf to verify that encryption key is correct.
+ * Caller provided buf needs to be able to hold at least ENCRYPTION_SAMPLE_SIZE
+ * bytes.
+ */
+void
+sample_encryption(char *buf)
+{
+	char		tweak[TWEAK_SIZE];
+	int			i;
+
+	for (i = 0; i < TWEAK_SIZE; i++)
+		tweak[i] = i;
+
+	encrypt_block("postgresqlcrypt", buf, ENCRYPTION_SAMPLE_SIZE, tweak,
+				  InvalidXLogRecPtr, InvalidBlockNumber, EDK_PERMANENT);
+}
+
+/*
+ * Encrypts one block of data with a specified tweak value. May only be called
+ * when encryption_enabled is true.
+ *
+ * Input and output buffer may point to the same location.
+ *
+ * "size" must be a (non-zero) multiple of ENCRYPTION_BLOCK.
+ *
+ * "tweak" value must be an array of at least TWEAK_SIZE bytes. If NULL is
+ * passed, we suppose that the input data starts with PageHeaderData. In this
+ * case page LSN is not encrypted because we use it as an encryption
+ * initialization vector (IV), and will need that for decryption. Therefore,
+ * if tweak==NULL, valid LSN must be passed. In such a case, page checksum
+ * stays unencrypted too because it should be computed later out of the
+ * encrypted data (the encrypted data is what we actually store to disk).
+ *
+ * "block" is number of relation block to be added to the tweak if we
+ * construct it here. Ignored if a valid tweak is passed.
+ *
+ * All-zero blocks are not encrypted to correctly handle relation extension,
+ * and also to simplify handling of holes created by seek past EOF and
+ * consequent write (see buffile.c). And specifically for relation pages, the
+ * problem is that empty page does not have valid LSN.
+ */
+void
+encrypt_block(const char *input, char *output, Size size, char *tweak,
+			  XLogRecPtr lsn, BlockNumber block,
+			  EncryptedDataKind data_kind)
+{
+#ifdef USE_ENCRYPTION
+	EVP_CIPHER_CTX *ctx;
+	int			out_size;
+	char	tweak_loc[TWEAK_SIZE];
+
+	Assert(data_encrypted);
+
+	/*
+	 * If caller passed no tweak, we assume this is relation page and LSN
+	 * should be used.
+	 */
+	if (tweak == NULL)
+	{
+		size_t	unencr_size;
+		char	*c = tweak_loc;
+
+		Assert(block != InvalidBlockNumber);
+		Assert(!XLogRecPtrIsInvalid(lsn));
+
+		memset(c, 0, TWEAK_SIZE);
+
+		/*
+		 * The CTR mode counter is big endian (see crypto/modes/ctr128.c in
+		 * OpenSSL) and the lower part is used by OpenSSL internally.
+		 * Initialize the upper eight bytes and leave the lower eight to
+		 * OpenSSL - as the counter is increased once per 16 bytes of input,
+		 * and as we hardly ever encrypt more than BLCKSZ bytes at a time,
+		 * it's not possible for the lower part to overflow into the upper
+		 * one.
+		 *
+		 * Note that we copy the lsn from the argument, not from the input
+		 * buffer. Since "input" can be a shared buffer locked only in shared
+		 * mode, MarkBufferDirtyHint() can update the LSN while we're copying
+		 * it. Thus the LSN we use in the tweak could be different from the
+		 * one we write to "output" below, and it would be impossible to
+		 * decrypt the page.
+		 */
+		PageSetLSN(c, lsn);
+		c += sizeof(PageXLogRecPtr);
+
+		/*
+		 * Add the block number, in case a single WAL record affects two (or
+		 * more?) pages. Likewise, different endian-ness of the block number
+		 * does not affect its uniqueness.
+		 */
+		memcpy(c, &block, sizeof(BlockNumber));
+
+		/*
+		 * In case the "fake LSN" assigned to page of temporary / unlogged
+		 * relation is equal to an existing regular LSN of any permanent
+		 * relation, we need to ensure that the IV is still different. Do so
+		 * by setting one bit of the next available byte of the IV. There
+		 * should still be enough space for the internal counter of the crypto
+		 * library, even if page size is 32 kB - in that case we need 11 bits
+		 * (2^15 / 2^4 = 2^11), but 7 bytes are still left.
+		 */
+		if (data_kind == EDK_TEMP)
+		{
+			c += sizeof(BlockNumber);
+			*c |= 0x1 << 7;
+		}
+
+		tweak = tweak_loc;
+
+		/*
+		 * Copy the LSN to the output. Again, use the argument, not the
+		 * input buffer.
+		 */
+		if (input != output)
+			PageSetLSN(output, lsn);
+
+		/* Do not encrypt the LSN and checksum. */
+		unencr_size = offsetof(PageHeaderData, pd_flags);
+		input += unencr_size;
+		output += unencr_size;
+		size -= unencr_size;
+	}
+	/*
+	 * Empty page is not worth encryption, and encryption of zeroes wouldn't
+	 * even be secure.
+	 */
+	else if (IsAllZero(input, size))
+	{
+		if (input != output)
+			memset(output, 0, size);
+		return;
+	}
+
+	ctx = data_kind != EDK_BUFFILE ? ctx_encrypt : ctx_encrypt_buffile;
+
+	/* The remaining initialization. */
+	if (EVP_EncryptInit_ex(ctx, NULL, NULL, encryption_key,
+						   (unsigned char *) tweak) != 1)
+		evp_error();
+
+	/* Do the actual encryption. */
+	if (EVP_EncryptUpdate(ctx, (unsigned char *) output,
+						  &out_size, (unsigned char *) input, size) != 1)
+		evp_error();
+
+	/*
+	 * The EVP documentation seems to allow that not all data is encrypted
+	 * at the same time, but the low level code does encrypt everything.
+	 */
+	if (out_size != size)
+	{
+#ifndef FRONTEND
+		ereport(ERROR, (errmsg("Some data left unencrypted")));
+#else
+		/* Front-end shouldn't actually get here, but be careful. */
+		fprintf(stderr, "Some data left unencrypted\n");
+		exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+	}
+#else  /* !USE_ENCRYPTION */
+	/* data_encrypted should not be set */
+	Assert(false);
+#endif							/* USE_ENCRYPTION */
+}
+
+/*
+ * Decrypts one block of data with a specified tweak value. May only be called
+ * when encryption_enabled is true.
+ *
+ * Input and output buffer may point to the same location.
+ *
+ * For detailed comments see encrypt_block().
+ *
+ * Unlike encrypt_block(), we don't expect page LSN to change during
+ * decryption, so we can read it from the input buffer.
+ */
+void
+decrypt_block(const char *input, char *output, Size size, char *tweak,
+			  BlockNumber block, EncryptedDataKind data_kind)
+{
+#ifdef USE_ENCRYPTION
+	EVP_CIPHER_CTX *ctx;
+	int			out_size;
+	char	tweak_loc[TWEAK_SIZE];
+
+	Assert(data_encrypted);
+
+	if (tweak == NULL)
+	{
+		size_t	lsn_size, unencr_size;
+		char	*c = tweak_loc;
+
+		Assert(block != InvalidBlockNumber);
+
+		/*
+		 * LSN is used as encryption IV, so page with invalid LSN shouldn't
+		 * have been encrypted.
+		 */
+		if (XLogRecPtrIsInvalid(PageGetLSN(input)))
+		{
+			if (input != output)
+				memcpy(output, input, size);
+			return;
+		}
+
+		lsn_size = sizeof(PageXLogRecPtr);
+
+		memset(c, 0, TWEAK_SIZE);
+		memcpy(c, input, lsn_size);
+		c += lsn_size;
+		memcpy(c, &block, sizeof(BlockNumber));
+		if (data_kind == EDK_TEMP)
+		{
+			c += sizeof(BlockNumber);
+			*c |= 0x1 << 7;
+		}
+
+		tweak = tweak_loc;
+
+		if (input != output)
+			memcpy(output, input, lsn_size);
+
+		/* Do not encrypt the LSN and checksum. */
+		unencr_size = offsetof(PageHeaderData, pd_flags);
+		input += unencr_size;
+		output += unencr_size;
+		size -= unencr_size;
+	}
+	else if (IsAllZero(input, size))
+	{
+		if (input != output)
+			memset(output, 0, size);
+		return;
+	}
+
+	ctx = data_kind != EDK_BUFFILE ? ctx_encrypt : ctx_encrypt_buffile;
+
+	/* The remaining initialization. */
+	if (EVP_DecryptInit_ex(ctx, NULL, NULL, encryption_key,
+						   (unsigned char *) tweak) != 1)
+		evp_error();
+
+	/* Do the actual encryption. */
+	if (EVP_DecryptUpdate(ctx, (unsigned char *) output,
+						  &out_size, (unsigned char *) input, size) != 1)
+		evp_error();
+
+	if (out_size != size)
+	{
+#ifndef FRONTEND
+		ereport(ERROR, (errmsg("Some data left undecrypted")));
+#else
+		/* Front-end shouldn't actually get here, but be careful. */
+		fprintf(stderr, "Some data left undecrypted\n");
+		exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+	}
+#else  /* !USE_ENCRYPTION */
+	/* data_encrypted should not be set */
+	Assert(false);
+#endif							/* USE_ENCRYPTION */
+}
+
+#ifdef USE_ENCRYPTION
+/*
+ * Initialize the OpenSSL context for passed cipher.
+ *
+ * On server side this happens during postmaster startup, so other processes
+ * inherit the initialized context via fork(). There's no reason to this again
+ * and again in encrypt_block() / decrypt_block(), also because we should not
+ * handle out-of-memory conditions encountered by OpenSSL in another way than
+ * ereport(FATAL). The OOM is much less likely to happen during postmaster
+ * startup, and even if it happens, troubleshooting should be easier than if
+ * it happened during normal operation.
+ *
+ * XXX Do we need to call EVP_CIPHER_CTX_cleanup() (via on_proc_exit callback
+ * for server processes and other way for front-ends)? Not sure it's
+ * necessary, as the initialization does not involve any shared resources
+ * (e.g. files).
+ */
+static void
+init_encryption_context(EVP_CIPHER_CTX **ctx_p, bool encrypt, bool buffile)
+{
+	EVP_CIPHER_CTX *ctx;
+	const EVP_CIPHER *cipher;
+
+	/*
+	 * Currently we use CBC mode for buffile.c because CTR imposes much more
+	 * stringent requirements on IV (i.e. the same IV must not be used
+	 * repeatedly.)
+	 */
+	cipher = !buffile ? EVP_aes_128_ctr() : EVP_aes_128_cbc();
+
+	if ((*ctx_p = EVP_CIPHER_CTX_new()) == NULL)
+		evp_error();
+	ctx = *ctx_p;
+
+	if (encrypt)
+	{
+		if (EVP_EncryptInit_ex(ctx, cipher, NULL, NULL, NULL) != 1)
+			evp_error();
+	}
+	else
+	{
+		if (EVP_DecryptInit_ex(ctx, cipher, NULL, NULL, NULL) != 1)
+			evp_error();
+	}
+
+	/* CTR mode is effectively a stream cipher. */
+	Assert((!buffile && EVP_CIPHER_CTX_block_size(ctx) == 1) ||
+		   (buffile && EVP_CIPHER_CTX_block_size(ctx) == 16));
+
+	/*
+	 * No padding is needed. For relation pages the input block size should
+	 * already be a multiple of ENCRYPTION_BLOCK, while for WAL we want to
+	 * avoid encryption of the unused (zeroed) part of the page, see
+	 * backend/storage/file/README.encryption.
+	 *
+	 * XXX Is this setting worth when we don't call EVP_EncryptFinal_ex()
+	 * anyway? (Given the block_size==1, EVP_EncryptFinal_ex() wouldn't do
+	 * anything.)
+	 */
+	EVP_CIPHER_CTX_set_padding(ctx, 0);
+
+	Assert(EVP_CIPHER_CTX_iv_length(ctx) == TWEAK_SIZE);
+	Assert(EVP_CIPHER_CTX_key_length(ctx) == ENCRYPTION_KEY_LENGTH);
+}
+
+#endif							/* USE_ENCRYPTION */
+
+#ifdef USE_ENCRYPTION
+/*
+ * Error callback for openssl.
+ */
+static void
+evp_error(void)
+{
+	ERR_print_errors_fp(stderr);
+#ifndef FRONTEND
+
+	/*
+	 * FATAL is the appropriate level because backend can hardly fix anything
+	 * if encryption / decryption has failed.
+	 *
+	 * XXX Do we yet need EVP_CIPHER_CTX_cleanup() here?
+	 */
+	elog(FATAL, "OpenSSL encountered error during encryption or decryption.");
+#else
+	fprintf(stderr,
+			"OpenSSL encountered error during encryption or decryption.");
+	exit(EXIT_FAILURE);
+#endif							/* FRONTEND */
+}
+#endif /* USE_ENCRYPTION */
+
+/*
+ * Xlog is encrypted page at a time. Each xlog page gets a unique tweak via
+ * timeline, segment and offset.
+ *
+ * The function is located here rather than some of the xlog*.c modules so
+ * that front-end applications can easily use it too.
+ */
+void
+XLogEncryptionTweak(char *tweak, TimeLineID timeline, XLogSegNo segment,
+					uint32 offset)
+{
+	memset(tweak, 0, TWEAK_SIZE);
+	memcpy(tweak, &timeline, sizeof(timeline));
+	tweak += sizeof(timeline);
+	memcpy(tweak, &segment, sizeof(XLogSegNo));
+	tweak += sizeof(XLogSegNo);
+	memcpy(tweak, &offset, sizeof(offset));
+}
+
+/*
+ * md files are encrypted block at a time. Tweak will alias higher numbered
+ * forks for huge tables.
+ */
+void
+mdtweak(char *tweak, RelFileNode *relnode, ForkNumber forknum, BlockNumber blocknum)
+{
+	uint32		fork_and_block = (forknum << 24) ^ blocknum;
+
+	memcpy(tweak, relnode, sizeof(RelFileNode));
+	memcpy(tweak + sizeof(RelFileNode), &fork_and_block, 4);
+}
+
+#ifndef FRONTEND
+/*
+ * Generate non-fake LSN.
+ *
+ * XLOG_NOOP is the easiest way to generate a valid LSN. Fake LSN
+ * is not suitable for permanent relation because it'd be hard to
+ * guarantee that it's not equal to any (existing or future)
+ * regular LSN.
+ *
+ * This approach introduces some overhead (no WAL would be written
+ * w/o encryption) but such a small record per page doesn't seem
+ * terrible.
+ */
+XLogRecPtr
+get_lsn_for_encryption(void)
+{
+	char	xlr_data = '\0';
+	XLogRecPtr	lsn;
+
+	XLogBeginInsert();
+	/* At least 1 byte is required. */
+	XLogRegisterData(&xlr_data, 1);
+	lsn = XLogInsert(RM_XLOG_ID, XLOG_NOOP);
+	return lsn;
+}
+
+/*
+ * Assign fake LSN to a page.
+ */
+void
+set_page_lsn_for_encryption(Page page)
+{
+	XLogRecPtr	lsn;
+
+	if (!data_encrypted)
+		return;
+
+	lsn = get_lsn_for_encryption();
+	PageSetLSN(page, lsn);
+}
+
+/*
+ * Assign the same fake LSN to two different pages.
+ */
+void
+set_page_lsn_for_encryption2(Page page1, Page page2)
+{
+	XLogRecPtr	lsn;
+
+	if (!data_encrypted)
+		return;
+
+	lsn = get_lsn_for_encryption();
+	PageSetLSN(page1, lsn);
+	PageSetLSN(page2, lsn);
+}
+
+/*
+ * Assign the same fake LSN to three different pages.
+ */
+void
+set_page_lsn_for_encryption3(Page page1, Page page2, Page page3)
+{
+	XLogRecPtr	lsn;
+
+	if (!data_encrypted)
+		return;
+
+	lsn = get_lsn_for_encryption();
+	PageSetLSN(page1, lsn);
+	PageSetLSN(page2, lsn);
+	PageSetLSN(page3, lsn);
+}
+#endif	/* !FRONTEND */
diff --git a/src/backend/storage/file/fd.c b/src/backend/storage/file/fd.c
index 5614b8b916..d51bf71c8e 100644
--- a/src/backend/storage/file/fd.c
+++ b/src/backend/storage/file/fd.c
@@ -1355,9 +1355,16 @@ PathNameOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode)
 	 */
 	fnamecopy = strdup(fileName);
 	if (fnamecopy == NULL)
-		ereport(ERROR,
+	{
+		/*
+		 * Some callers (especially BufFileOpenTransient() in the TDE fork)
+		 * might dislike ERROR here.
+		 */
+		ereport(WARNING,
 				(errcode(ERRCODE_OUT_OF_MEMORY),
 				 errmsg("out of memory")));
+		return -1;
+	}
 
 	file = AllocateVfd();
 	vfdP = &VfdCache[file];
@@ -1804,6 +1811,15 @@ FileClose(File file)
 	FreeVfd(file);
 }
 
+/*
+ * The FileIsNotOpen macro for external callers.
+ */
+extern bool
+FileIsClosed(File file)
+{
+	return FileIsNotOpen(file);
+}
+
 /*
  * FilePrefetch - initiate asynchronous read of a given range of the file.
  *
@@ -1922,7 +1938,7 @@ retry:
 
 int
 FileWrite(File file, char *buffer, int amount, off_t offset,
-		  uint32 wait_event_info)
+		  uint32 wait_event_info, int elevel)
 {
 	int			returnCode;
 	Vfd		   *vfdP;
@@ -1958,10 +1974,15 @@ FileWrite(File file, char *buffer, int amount, off_t offset,
 
 			newTotal += past_write - vfdP->fileSize;
 			if (newTotal > (uint64) temp_file_limit * (uint64) 1024)
-				ereport(ERROR,
+			{
+				ereport(elevel,
 						(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),
 						 errmsg("temporary file size exceeds temp_file_limit (%dkB)",
 								temp_file_limit)));
+
+				/* Only reached if elevel < ERROR */
+				return -1;
+			}
 		}
 	}
 
diff --git a/src/backend/storage/freespace/freespace.c b/src/backend/storage/freespace/freespace.c
index c17b3f49dd..249331640b 100644
--- a/src/backend/storage/freespace/freespace.c
+++ b/src/backend/storage/freespace/freespace.c
@@ -4,6 +4,7 @@
  *	  POSTGRES free space map for quickly finding free space in relations
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -110,7 +111,7 @@ static int	fsm_set_and_search(Relation rel, FSMAddress addr, uint16 slot,
 static BlockNumber fsm_search(Relation rel, uint8 min_cat);
 static uint8 fsm_vacuum_page(Relation rel, FSMAddress addr,
 							 BlockNumber start, BlockNumber end,
-							 bool *eof);
+							 bool *eof, XLogRecPtr recptr);
 
 
 /******** Public API ********/
@@ -196,7 +197,7 @@ RecordPageWithFreeSpace(Relation rel, BlockNumber heapBlk, Size spaceAvail)
  */
 void
 XLogRecordPageWithFreeSpace(RelFileNode rnode, BlockNumber heapBlk,
-							Size spaceAvail)
+							Size spaceAvail, XLogRecPtr recptr)
 {
 	int			new_cat = fsm_space_avail_to_cat(spaceAvail);
 	FSMAddress	addr;
@@ -218,7 +219,20 @@ XLogRecordPageWithFreeSpace(RelFileNode rnode, BlockNumber heapBlk,
 		PageInit(page, BLCKSZ, 0);
 
 	if (fsm_set_avail(page, slot, new_cat))
+	{
+		/*
+		 * During recovery, MarkBufferDirtyHint() cannot set the LSN even in
+		 * the encryption case because it cannot insert WAL. Therefore we set
+		 * the LSN explicitly.
+		 */
+		if (data_encrypted)
+		{
+			Assert(!XLogRecPtrIsInvalid(recptr));
+			PageSetLSN(page, recptr);
+		}
+
 		MarkBufferDirtyHint(buf, false);
+	}
 	UnlockReleaseBuffer(buf);
 }
 
@@ -254,15 +268,21 @@ GetRecordedFreeSpace(Relation rel, BlockNumber heapBlk)
  * before they access the FSM again.
  *
  * nblocks is the new size of the heap.
+ *
+ * Valid recptr is passed iff called during WAL replay, see
+ * visibilitymap_set() for details.
  */
 void
-FreeSpaceMapTruncateRel(Relation rel, BlockNumber nblocks)
+FreeSpaceMapTruncateRel(Relation rel, BlockNumber nblocks,
+						XLogRecPtr recptr)
 {
 	BlockNumber new_nfsmblocks;
 	FSMAddress	first_removed_address;
 	uint16		first_removed_slot;
 	Buffer		buf;
 
+	Assert(InRecovery || XLogRecPtrIsInvalid(recptr));
+
 	RelationOpenSmgr(rel);
 
 	/*
@@ -304,6 +324,19 @@ FreeSpaceMapTruncateRel(Relation rel, BlockNumber nblocks)
 		MarkBufferDirty(buf);
 		if (!InRecovery && RelationNeedsWAL(rel) && XLogHintBitIsNeeded())
 			log_newpage_buffer(buf, false);
+		else if (data_encrypted)
+		{
+			if (XLogRecPtrIsInvalid(recptr))
+				set_page_lsn_for_encryption(BufferGetPage(buf));
+			else
+			{
+				/*
+				 * Once the page is dirty, the LSN must be set even during
+				 * recovery because it's used as the encryption IV.
+				 */
+				PageSetLSN(BufferGetPage(buf), recptr);
+			}
+		}
 
 		END_CRIT_SECTION();
 
@@ -336,7 +369,7 @@ FreeSpaceMapTruncateRel(Relation rel, BlockNumber nblocks)
 	 * important because the just-truncated pages were likely marked as
 	 * all-free, and would be preferentially selected.
 	 */
-	FreeSpaceMapVacuumRange(rel, nblocks, InvalidBlockNumber);
+	FreeSpaceMapVacuumRange(rel, nblocks, InvalidBlockNumber, recptr);
 }
 
 /*
@@ -353,7 +386,7 @@ FreeSpaceMapVacuum(Relation rel)
 	/* Recursively scan the tree, starting at the root */
 	(void) fsm_vacuum_page(rel, FSM_ROOT_ADDRESS,
 						   (BlockNumber) 0, InvalidBlockNumber,
-						   &dummy);
+						   &dummy, InvalidXLogRecPtr);
 }
 
 /*
@@ -363,15 +396,20 @@ FreeSpaceMapVacuum(Relation rel)
  * have new free-space information, so update only the upper-level slots
  * covering that block range.  end == InvalidBlockNumber is equivalent to
  * "all the rest of the relation".
+ *
+ * Valid recptr is passed when the function is called during WAL replay, see
+ * visibilitymap_set() for explanation.
  */
 void
-FreeSpaceMapVacuumRange(Relation rel, BlockNumber start, BlockNumber end)
+FreeSpaceMapVacuumRange(Relation rel, BlockNumber start, BlockNumber end,
+						XLogRecPtr recptr)
 {
 	bool		dummy;
 
 	/* Recursively scan the tree, starting at the root */
 	if (end > start)
-		(void) fsm_vacuum_page(rel, FSM_ROOT_ADDRESS, start, end, &dummy);
+		(void) fsm_vacuum_page(rel, FSM_ROOT_ADDRESS, start, end, &dummy,
+							   recptr);
 }
 
 /******** Internal routines ********/
@@ -647,6 +685,12 @@ fsm_extend(Relation rel, BlockNumber fsm_nblocks)
 
 	while (fsm_nblocks_now < fsm_nblocks)
 	{
+		/*
+		 * Encryption: invalid LSN means that the page should not be
+		 * encrypted. This is o.k. as the page is still empty.
+		 */
+		Assert(XLogRecPtrIsInvalid(PageGetLSN(pg.data)));
+
 		PageSetChecksumInplace((Page) pg.data, fsm_nblocks_now);
 
 		smgrextend(rel->rd_smgr, FSM_FORKNUM, fsm_nblocks_now,
@@ -680,6 +724,12 @@ fsm_set_and_search(Relation rel, FSMAddress addr, uint16 slot,
 
 	page = BufferGetPage(buf);
 
+	/*
+	 * No need to care about enforcing LSN for encryption IV -
+	 * MarkBufferDirtyHint() will take care.
+	 */
+	Assert(!InRecovery);
+
 	if (fsm_set_avail(page, slot, newValue))
 		MarkBufferDirtyHint(buf, false);
 
@@ -800,7 +850,7 @@ fsm_search(Relation rel, uint8 min_cat)
 static uint8
 fsm_vacuum_page(Relation rel, FSMAddress addr,
 				BlockNumber start, BlockNumber end,
-				bool *eof_p)
+				bool *eof_p, XLogRecPtr recptr)
 {
 	Buffer		buf;
 	Page		page;
@@ -832,6 +882,7 @@ fsm_vacuum_page(Relation rel, FSMAddress addr,
 					start_slot,
 					end_slot;
 		bool		eof = false;
+		bool		set_encr_iv = false;
 
 		/*
 		 * Compute the range of slots we need to update on this page, given
@@ -874,7 +925,7 @@ fsm_vacuum_page(Relation rel, FSMAddress addr,
 			if (!eof)
 				child_avail = fsm_vacuum_page(rel, fsm_get_child(addr, slot),
 											  start, end,
-											  &eof);
+											  &eof, recptr);
 			else
 				child_avail = 0;
 
@@ -883,10 +934,34 @@ fsm_vacuum_page(Relation rel, FSMAddress addr,
 			{
 				LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE);
 				fsm_set_avail(page, slot, child_avail);
-				MarkBufferDirtyHint(buf, false);
+				if (!data_encrypted)
+					MarkBufferDirtyHint(buf, false);
+				else
+					set_encr_iv = true;
 				LockBuffer(buf, BUFFER_LOCK_UNLOCK);
 			}
 		}
+
+		/*
+		 * If using the LSN as the encryption IV, make sure the same IV is
+		 * used only once. Otherwise there's a chance that different data will
+		 * be encrypted with the same IV.
+		 */
+		if (set_encr_iv)
+		{
+			LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE);
+
+			/*
+			 * During recovery, MarkBufferDirtyHint() cannot set the LSN even
+			 * in the encryption case because it cannot insert WAL. Therefore
+			 * we set the LSN explicitly.
+			 */
+			if (!XLogRecPtrIsInvalid(recptr))
+				PageSetLSN(page, recptr);
+
+			MarkBufferDirtyHint(buf, false);
+			LockBuffer(buf, BUFFER_LOCK_UNLOCK);
+		}
 	}
 
 	/* Now get the maximum value on the page, to return to caller */
diff --git a/src/backend/storage/freespace/fsmpage.c b/src/backend/storage/freespace/fsmpage.c
index cf7f03f12d..b841425b12 100644
--- a/src/backend/storage/freespace/fsmpage.c
+++ b/src/backend/storage/freespace/fsmpage.c
@@ -22,6 +22,7 @@
  */
 #include "postgres.h"
 
+#include "access/xlog.h"
 #include "storage/bufmgr.h"
 #include "storage/fsm_internals.h"
 
@@ -284,6 +285,13 @@ restart:
 				exclusive_lock_held = true;
 			}
 			fsm_rebuild_page(page);
+
+			/*
+			 * No need to care about enforcing LSN for encryption IV -
+			 * MarkBufferDirtyHint() will take care.
+			 */
+			Assert(!InRecovery);
+
 			MarkBufferDirtyHint(buf, false);
 			goto restart;
 		}
diff --git a/src/backend/storage/ipc/dsm.c b/src/backend/storage/ipc/dsm.c
index 2b5bd8dbd0..d49200c777 100644
--- a/src/backend/storage/ipc/dsm.c
+++ b/src/backend/storage/ipc/dsm.c
@@ -36,6 +36,7 @@
 #include "lib/ilist.h"
 #include "miscadmin.h"
 #include "storage/dsm.h"
+#include "storage/encryption.h"
 #include "storage/ipc.h"
 #include "storage/lwlock.h"
 #include "storage/pg_shmem.h"
@@ -145,6 +146,19 @@ dsm_postmaster_startup(PGShmemHeader *shim)
 
 	Assert(!IsUnderPostmaster);
 
+	/*
+	 * If the instance is encrypted, check the dynamic shared memory type
+	 * before shared memory initialization starts. The problem is that the
+	 * data in the shared memory is not encrypted, and due to the mmap type it
+	 * can end up on disk.
+	 */
+#ifdef USE_ENCRYPTION
+	if (data_encrypted &&
+		dynamic_shared_memory_type == DSM_IMPL_MMAP)
+		ereport(FATAL,
+				(errmsg("dynamic_shared_memory_type cannot be \"mmap\" when the instance is encrypted")));
+#endif /* USE_ENCRYPTION */
+
 	/*
 	 * If we're using the mmap implementations, clean up any leftovers.
 	 * Cleanup isn't needed on Windows, and happens earlier in startup for
diff --git a/src/backend/storage/ipc/ipci.c b/src/backend/storage/ipc/ipci.c
index d7d733530f..6315bb798b 100644
--- a/src/backend/storage/ipc/ipci.c
+++ b/src/backend/storage/ipc/ipci.c
@@ -3,6 +3,7 @@
  * ipci.c
  *	  POSTGRES inter-process communication initialization code.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -147,6 +148,7 @@ CreateSharedMemoryAndSemaphores(int port)
 		size = add_size(size, BTreeShmemSize());
 		size = add_size(size, SyncScanShmemSize());
 		size = add_size(size, AsyncShmemSize());
+		size = add_size(size, EncryptionShmemSize());
 #ifdef EXEC_BACKEND
 		size = add_size(size, ShmemBackendArraySize());
 #endif
@@ -263,6 +265,7 @@ CreateSharedMemoryAndSemaphores(int port)
 	BTreeShmemInit();
 	SyncScanShmemInit();
 	AsyncShmemInit();
+	EncryptionShmemInit();
 
 #ifdef EXEC_BACKEND
 
diff --git a/src/backend/storage/page/bufpage.c b/src/backend/storage/page/bufpage.c
index 7500b9d0b5..ccd5a18bbf 100644
--- a/src/backend/storage/page/bufpage.c
+++ b/src/backend/storage/page/bufpage.c
@@ -3,6 +3,7 @@
  * bufpage.c
  *	  POSTGRES standard buffer page code.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -17,6 +18,7 @@
 #include "access/htup_details.h"
 #include "access/itup.h"
 #include "access/xlog.h"
+#include "common/string.h"
 #include "pgstat.h"
 #include "storage/checksum.h"
 #include "utils/memdebug.h"
@@ -60,18 +62,6 @@ PageInit(Page page, Size pageSize, Size specialSize)
 }
 
 
-/*
- * PageIsVerified
- *		Utility wrapper for PageIsVerifiedExtended().
- */
-bool
-PageIsVerified(Page page, BlockNumber blkno)
-{
-	return PageIsVerifiedExtended(page, blkno,
-								  PIV_LOG_WARNING | PIV_REPORT_STAT);
-}
-
-
 /*
  * PageIsVerifiedExtended
  *		Check that the page header and checksum (if any) appear valid.
@@ -90,6 +80,10 @@ PageIsVerified(Page page, BlockNumber blkno)
  * treat such a page as empty and without free space.  Eventually, VACUUM
  * will clean up such a page and make it usable.
  *
+ * If "page_encr" is passed, it points to encrypted page and "page" is its
+ * plain form. The point is that checksum needs to be verified before
+ * decryption, but other fields must be checked after that.
+ *
  * If flag PIV_LOG_WARNING is set, a WARNING is logged in the event of
  * a checksum failure.
  *
@@ -97,14 +91,11 @@ PageIsVerified(Page page, BlockNumber blkno)
  * to pgstat.
  */
 bool
-PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags)
+PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags, Page page_encr)
 {
 	PageHeader	p = (PageHeader) page;
-	size_t	   *pagebytes;
-	int			i;
 	bool		checksum_failure = false;
 	bool		header_sane = false;
-	bool		all_zeroes = false;
 	uint16		checksum = 0;
 
 	/*
@@ -114,10 +105,25 @@ PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags)
 	{
 		if (DataChecksumsEnabled())
 		{
+			Page page_save = NULL;
+
+			if (page_encr)
+			{
+				page_save = page;
+				page = page_encr;
+				p = (PageHeader) page;
+			}
+
 			checksum = pg_checksum_page((char *) page, blkno);
 
 			if (checksum != p->pd_checksum)
 				checksum_failure = true;
+
+			if (page_save)
+			{
+				page = page_save;
+				p = (PageHeader) page;
+			}
 		}
 
 		/*
@@ -137,26 +143,8 @@ PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags)
 			return true;
 	}
 
-	/*
-	 * Check all-zeroes case. Luckily BLCKSZ is guaranteed to always be a
-	 * multiple of size_t - and it's much faster to compare memory using the
-	 * native word size.
-	 */
-	StaticAssertStmt(BLCKSZ == (BLCKSZ / sizeof(size_t)) * sizeof(size_t),
-					 "BLCKSZ has to be a multiple of sizeof(size_t)");
-
-	all_zeroes = true;
-	pagebytes = (size_t *) page;
-	for (i = 0; i < (BLCKSZ / sizeof(size_t)); i++)
-	{
-		if (pagebytes[i] != 0)
-		{
-			all_zeroes = false;
-			break;
-		}
-	}
-
-	if (all_zeroes)
+	/* Check all-zeroes case */
+	if (IsAllZero((char *) page, BLCKSZ))
 		return true;
 
 	/*
@@ -1190,8 +1178,18 @@ PageSetChecksumCopy(Page page, BlockNumber blkno)
 {
 	static char *pageCopy = NULL;
 
-	/* If we don't need a checksum, just return the passed-in data */
-	if (PageIsNew(page) || !DataChecksumsEnabled())
+	/*
+	 * If we don't need a checksum, just return the passed-in data.
+	 *
+	 * Note that encrypted page is checksumed even if it's empty. We cannot
+	 * use PageIsNew() for them safely (because the field it checks can become
+	 * zero due to encryption), and it's not always easy / efficient to
+	 * decrypt the page just to see if it's empty. One particular problem is
+	 * that the pg_checksums utility cannot decrypt the pages because it does
+	 * not know whether relation is unlogged (unlogged relations have special
+	 * encryption IV).
+	 */
+	if ((!data_encrypted && PageIsNew(page)) || !DataChecksumsEnabled())
 		return (char *) page;
 
 	/*
@@ -1217,8 +1215,13 @@ PageSetChecksumCopy(Page page, BlockNumber blkno)
 void
 PageSetChecksumInplace(Page page, BlockNumber blkno)
 {
-	/* If we don't need a checksum, just return */
-	if (PageIsNew(page) || !DataChecksumsEnabled())
+	/*
+	 * If we don't need a checksum, just return.
+	 *
+	 * Note that encrypted page is checksumed even if it's empty, see
+	 * PageSetChecksumCopy() for explanation.
+	 */
+	if ((!data_encrypted && PageIsNew(page)) || !DataChecksumsEnabled())
 		return;
 
 	((PageHeader) page)->pd_checksum = pg_checksum_page((char *) page, blkno);
diff --git a/src/backend/storage/smgr/md.c b/src/backend/storage/smgr/md.c
index 0c0e26b522..f4503853de 100644
--- a/src/backend/storage/smgr/md.c
+++ b/src/backend/storage/smgr/md.c
@@ -440,7 +440,8 @@ mdextend(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,
 
 	Assert(seekpos < (off_t) BLCKSZ * RELSEG_SIZE);
 
-	if ((nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_EXTEND)) != BLCKSZ)
+	if ((nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos,
+							WAIT_EVENT_DATA_FILE_EXTEND, ERROR)) != BLCKSZ)
 	{
 		if (nbytes < 0)
 			ereport(ERROR,
@@ -702,7 +703,8 @@ mdwrite(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,
 
 	Assert(seekpos < (off_t) BLCKSZ * RELSEG_SIZE);
 
-	nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_WRITE);
+	nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos,
+					   WAIT_EVENT_DATA_FILE_WRITE, ERROR);
 
 	TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE(forknum, blocknum,
 										reln->smgr_rnode.node.spcNode,
diff --git a/src/backend/tcop/postgres.c b/src/backend/tcop/postgres.c
index 1af5817383..8d001af178 100644
--- a/src/backend/tcop/postgres.c
+++ b/src/backend/tcop/postgres.c
@@ -3,6 +3,7 @@
  * postgres.c
  *	  POSTGRES C Backend Interface
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -62,6 +63,7 @@
 #include "replication/walsender.h"
 #include "rewrite/rewriteHandler.h"
 #include "storage/bufmgr.h"
+#include "storage/encryption.h"
 #include "storage/ipc.h"
 #include "storage/proc.h"
 #include "storage/procsignal.h"
@@ -3887,6 +3889,35 @@ PostgresMain(int argc, char *argv[],
 	/* We need to allow SIGINT, etc during the initial transaction */
 	PG_SETMASK(&UnBlockSig);
 
+	/*
+	 * Standalone backend operating on an encrypted cluster needs encryption
+	 * key.
+	 */
+	if (!IsUnderPostmaster && data_encrypted)
+	{
+		char	sample[ENCRYPTION_SAMPLE_SIZE];
+
+		/* Display a prompt for user to enter the encryption key. */
+		printf("key> ");
+		fflush(stdout);
+
+		/*
+		 * Read the key from stdin. Pass interactive_getc() as the callback so
+		 * that the reading is interruptible.
+		 */
+		read_encryption_key(interactive_getc);
+
+		setup_encryption();
+
+		/* Verify the key. */
+		sample_encryption(sample);
+		if (memcmp(encryption_verification, sample, ENCRYPTION_SAMPLE_SIZE))
+			ereport(FATAL,
+					(errmsg("invalid encryption key"),
+					 errdetail("The passed encryption key does not match"
+							   " database encryption key.")));
+	}
+
 	/*
 	 * General initialization.
 	 *
diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c
index 2ec82406dd..0678172c9c 100644
--- a/src/backend/utils/misc/guc.c
+++ b/src/backend/utils/misc/guc.c
@@ -6,6 +6,7 @@
  * See src/backend/utils/misc/README for more information.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Copyright (c) 2000-2019, PostgreSQL Global Development Group
  * Written by Peter Eisentraut <peter_e@gmx.net>.
  *
@@ -71,8 +72,10 @@
 #include "replication/syncrep.h"
 #include "replication/walreceiver.h"
 #include "replication/walsender.h"
+#include "storage/buffile.h"
 #include "storage/bufmgr.h"
 #include "storage/dsm_impl.h"
+#include "storage/encryption.h"
 #include "storage/standby.h"
 #include "storage/fd.h"
 #include "storage/large_object.h"
@@ -188,6 +191,8 @@ static const char *show_tcp_keepalives_idle(void);
 static const char *show_tcp_keepalives_interval(void);
 static const char *show_tcp_keepalives_count(void);
 static const char *show_tcp_user_timeout(void);
+static bool check_buffile_max_filesize(int *newval, void **extra, GucSource source);
+static void assign_buffile_max_filesize(int newval, void *extra);
 static bool check_maxconnections(int *newval, void **extra, GucSource source);
 static bool check_max_worker_processes(int *newval, void **extra, GucSource source);
 static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);
@@ -217,6 +222,10 @@ static void assign_recovery_target_lsn(const char *newval, void *extra);
 static bool check_primary_slot_name(char **newval, void **extra, GucSource source);
 static bool check_default_with_oids(bool *newval, void **extra, GucSource source);
 
+#ifdef USE_ENCRYPTION
+static const char *show_encryption_key_command(void);
+#endif
+
 /* Private functions in guc-file.l that need to be called from guc.c */
 static ConfigVariable *ProcessConfigFileInternal(GucContext context,
 												 bool applySettings, int elevel);
@@ -1846,6 +1855,17 @@ static struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 
+	{
+		{"data_encryption", PGC_INTERNAL, PRESET_OPTIONS,
+			gettext_noop("Shows whether data encryption is turned on for this cluster."),
+			NULL,
+			GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE
+		},
+		&data_encrypted,
+		false,
+		NULL, NULL, NULL
+	},
+
 	{
 		{"syslog_sequence_numbers", PGC_SIGHUP, LOGGING_WHERE,
 			gettext_noop("Add sequence number to syslog messages to avoid duplicate suppression."),
@@ -3206,6 +3226,18 @@ static struct config_int ConfigureNamesInt[] =
 		NULL, assign_tcp_user_timeout, show_tcp_user_timeout
 	},
 
+	{
+		/* Not for general use */
+		{"buffile_max_filesize", PGC_SUSET, DEVELOPER_OPTIONS,
+			gettext_noop("Maximum size of BufFile segment."),
+			gettext_noop("This makes testing of some corner cases easier, especially when read or write crosses segment boundary."),
+			GUC_NOT_IN_SAMPLE | GUC_UNIT_BYTE
+		},
+		&buffile_max_filesize,
+		MAX_PHYSICAL_FILESIZE, BLCKSZ, MAX_PHYSICAL_FILESIZE,
+		check_buffile_max_filesize, assign_buffile_max_filesize, NULL
+	},
+
 	/* End-of-list marker */
 	{
 		{NULL, 0, 0, NULL, NULL}, NULL, 0, 0, 0, NULL, NULL, NULL
@@ -4211,6 +4243,19 @@ static struct config_string ConfigureNamesString[] =
 		NULL, NULL, NULL
 	},
 
+#ifdef USE_ENCRYPTION
+	{
+		{"encryption_key_command", PGC_POSTMASTER, 0,
+			gettext_noop("Sets the shell command that will be called to fetch database encryption key."),
+			NULL,
+			GUC_NO_SHOW_ALL | GUC_SUPERUSER_ONLY
+		},
+		&encryption_key_command,
+		NULL,
+		NULL, NULL, show_encryption_key_command
+	},
+#endif
+
 	/* End-of-list marker */
 	{
 		{NULL, 0, 0, NULL, NULL}, NULL, NULL, NULL, NULL, NULL
@@ -11335,6 +11380,23 @@ show_tcp_user_timeout(void)
 	return nbuf;
 }
 
+static bool
+check_buffile_max_filesize(int *newval, void **extra, GucSource source)
+{
+	if (*newval % BLCKSZ != 0)
+	{
+		GUC_check_errdetail("The value must be whole multiple of BLCKSZ.");
+		return false;
+	}
+	return true;
+}
+
+static void
+assign_buffile_max_filesize(int newval, void *extra)
+{
+	buffile_seg_blocks = BUFFILE_SEG_BLOCKS(newval);
+}
+
 static bool
 check_maxconnections(int *newval, void **extra, GucSource source)
 {
@@ -11792,4 +11854,15 @@ check_default_with_oids(bool *newval, void **extra, GucSource source)
 	return true;
 }
 
+#ifdef USE_ENCRYPTION
+static const char *
+show_encryption_key_command(void)
+{
+	if (encryption_key_command)
+		return encryption_key_command;
+	else
+		return "(disabled)";
+}
+#endif
+
 #include "guc-file.c"
diff --git a/src/backend/utils/misc/postgresql.conf.sample b/src/backend/utils/misc/postgresql.conf.sample
index 796ab06755..c0f5d00f70 100644
--- a/src/backend/utils/misc/postgresql.conf.sample
+++ b/src/backend/utils/misc/postgresql.conf.sample
@@ -112,6 +112,9 @@
 #ssl_passphrase_command = ''
 #ssl_passphrase_command_supports_reload = off
 
+# - Encryption -
+
+#encryption_key_command = ''
 
 #------------------------------------------------------------------------------
 # RESOURCE USAGE (except WAL)
diff --git a/src/bin/Makefile b/src/bin/Makefile
index 903e58121f..71a07f7b42 100644
--- a/src/bin/Makefile
+++ b/src/bin/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin (client programs)
 #
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
 # Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -22,6 +23,7 @@ SUBDIRS = \
 	pg_controldata \
 	pg_ctl \
 	pg_dump \
+	pg_keytool \
 	pg_resetwal \
 	pg_rewind \
 	pg_test_fsync \
diff --git a/src/bin/initdb/.gitignore b/src/bin/initdb/.gitignore
index 71a899ffb8..0f33b5c67d 100644
--- a/src/bin/initdb/.gitignore
+++ b/src/bin/initdb/.gitignore
@@ -1,5 +1,6 @@
 /encnames.c
 /localtime.c
+/encryption.c
 
 /initdb
 
diff --git a/src/bin/initdb/Makefile b/src/bin/initdb/Makefile
index 7c404430a9..dd4fe06917 100644
--- a/src/bin/initdb/Makefile
+++ b/src/bin/initdb/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/initdb
 #
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
 # Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -26,7 +27,7 @@ ifneq (,$(with_system_tzdata))
 override CPPFLAGS += '-DSYSTEMTZDIR="$(with_system_tzdata)"'
 endif
 
-OBJS=	initdb.o findtimezone.o localtime.o encnames.o $(WIN32RES)
+OBJS=	initdb.o findtimezone.o localtime.o encnames.o encryption.o $(WIN32RES)
 
 all: initdb
 
@@ -45,6 +46,9 @@ encnames.c: % : $(top_srcdir)/src/backend/utils/mb/%
 localtime.c: % : $(top_srcdir)/src/timezone/%
 	rm -f $@ && $(LN_S) $< .
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) initdb$(X) '$(DESTDIR)$(bindir)/initdb$(X)'
 
@@ -55,7 +59,7 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/initdb$(X)'
 
 clean distclean maintainer-clean:
-	rm -f initdb$(X) $(OBJS) encnames.c localtime.c
+	rm -f initdb$(X) $(OBJS) encnames.c localtime.c encryption.c
 	rm -rf tmp_check
 
 # ensure that changes in datadir propagate into object file
diff --git a/src/bin/initdb/initdb.c b/src/bin/initdb/initdb.c
index 2da587c376..feb2f24f65 100644
--- a/src/bin/initdb/initdb.c
+++ b/src/bin/initdb/initdb.c
@@ -38,6 +38,7 @@
  *
  * This code is released under the terms of the PostgreSQL License.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -68,11 +69,13 @@
 #include "common/logging.h"
 #include "common/restricted_token.h"
 #include "common/username.h"
+#include "fe_utils/encryption.h"
 #include "fe_utils/string_utils.h"
 #include "getaddrinfo.h"
 #include "getopt_long.h"
 #include "mb/pg_wchar.h"
 #include "miscadmin.h"
+#include "storage/encryption.h"
 
 
 /* Ideally this would be in a .h file, but it hardly seems worth the trouble */
@@ -171,6 +174,8 @@ static bool output_failed = false;
 static int	output_errno = 0;
 static char *pgdata_native;
 
+extern unsigned char encryption_key[ENCRYPTION_KEY_LENGTH];
+
 /* defaults */
 static int	n_connections = 10;
 static int	n_buffers = 50;
@@ -239,6 +244,7 @@ static char **filter_lines_with_token(char **lines, const char *token);
 static char **readfile(const char *path);
 static void writefile(char *path, char **lines);
 static FILE *popen_check(const char *command, const char *mode);
+static void send_encryption_key(FILE *f);
 static char *get_id(void);
 static int	get_encoding_id(const char *encoding_name);
 static void set_input(char **dest, const char *filename);
@@ -583,6 +589,22 @@ popen_check(const char *command, const char *mode)
 	return cmdfd;
 }
 
+/*
+ * Send encryption key in hexadecimal format to the file stream passed.
+ *
+ * The backend processes could actually receive binary data but that would
+ * make startup of postgres in single-user mode less convenient.
+ */
+static void
+send_encryption_key(FILE *f)
+{
+	int	i;
+
+	for (i = 0; i < ENCRYPTION_KEY_LENGTH; i++)
+		fprintf(f, "%.2x", encryption_key[i]);
+	fputc('\n', f);
+}
+
 /*
  * clean up any files we created on failure
  * if we created the data directory remove it too
@@ -1233,6 +1255,18 @@ setup_config(void)
 
 	snprintf(path, sizeof(path), "%s/postgresql.conf", pg_data);
 
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		snprintf(repltok, sizeof(repltok), "encryption_key_command = '%s'",
+				 escape_quotes(encryption_key_command));
+		conflines = replace_token(conflines, "#encryption_key_command = ''", repltok);
+	}
+#else
+		/* encryption_key_command should not be set */
+		Assert(false);
+#endif
+
 	writefile(path, conflines);
 	if (chmod(path, pg_file_create_mode) != 0)
 	{
@@ -1377,6 +1411,7 @@ bootstrap_template1(void)
 	char	  **bki_lines;
 	char		headerline[MAXPGPATH];
 	char		buf[64];
+	char *encr_opt_str = NULL;
 
 	printf(_("running bootstrap script ... "));
 	fflush(stdout);
@@ -1444,17 +1479,37 @@ bootstrap_template1(void)
 	/* Also ensure backend isn't confused by this environment var: */
 	unsetenv("PGCLIENTENCODING");
 
+	/* Prepare the -K option for the backend. */
+	if (encryption_key_command)
+	{
+		size_t		len;
+
+		len = 3;
+		encr_opt_str = (char *) pg_malloc(len);
+		snprintf(encr_opt_str, len, "-K");
+	}
+	else
+	{
+		encr_opt_str = (char *) pg_malloc(1);
+		encr_opt_str[0] = '\0';
+	}
+
 	snprintf(cmd, sizeof(cmd),
-			 "\"%s\" --boot -x1 -X %u %s %s %s",
+			 "\"%s\" --boot -x1 -X %u %s %s %s %s",
 			 backend_exec,
 			 wal_segment_size_mb * (1024 * 1024),
 			 data_checksums ? "-k" : "",
+			 encr_opt_str,
 			 boot_options,
 			 debug ? "-d 5" : "");
 
 
 	PG_CMD_OPEN;
 
+	/* If the cluster is encrypted, first send the encryption key. */
+	if (encryption_key_command)
+		send_encryption_key(cmdfd);
+
 	for (line = bki_lines; *line != NULL; line++)
 	{
 		PG_CMD_PUTS(*line);
@@ -2376,6 +2431,10 @@ usage(const char *progname)
 	printf(_("\nLess commonly used options:\n"));
 	printf(_("  -d, --debug               generate lots of debugging output\n"));
 	printf(_("  -k, --data-checksums      use data page checksums\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command\n"
+			 "                            command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -L DIRECTORY              where to find the input files\n"));
 	printf(_("  -n, --no-clean            do not clean up after errors\n"));
 	printf(_("  -N, --no-sync             do not wait for changes to be written safely to disk\n"));
@@ -2955,6 +3014,40 @@ initialize_data_directory(void)
 	/* Top level PG_VERSION is checked by bootstrapper, so make it first */
 	write_version_file(NULL);
 
+	/*
+	 * If the cluster will be encrypted, write the KDF file so that encryption
+	 * key can be derived from password.
+	 */
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * XXX Since execution of encryption_key_command produce the key (as
+		 * opposed to password), we don't know if the command received the key
+		 * itself or a password. If DBA provided initdb with a key, he will
+		 * never use password in the future (there was no KDF so far so the
+		 * key could not be derived from password, and the password can hardly
+		 * be derived from the key), so the KDF file may be useless. We don't
+		 * have enough information to recognize this special case, so just
+		 * initialize and write the KDF unconditionally.
+		 */
+		init_kdf();
+		write_kdf_file(pg_data);
+
+		/*
+		 * The key command is allowed to use pg_keytool, which in turn needs
+		 * the KDF parameters. The KDF parameters are now available so we can
+		 * run the command.
+		 */
+		run_encryption_key_command(pg_data);
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/* Select suitable configuration settings */
 	set_null_conf();
 	test_config_settings();
@@ -2984,6 +3077,10 @@ initialize_data_directory(void)
 
 	PG_CMD_OPEN;
 
+	/* If the cluster is encrypted, first send the encryption key. */
+	if (encryption_key_command)
+		send_encryption_key(cmdfd);
+
 	setup_auth(cmdfd);
 
 	setup_depend(cmdfd);
@@ -3052,6 +3149,9 @@ main(int argc, char *argv[])
 		{"waldir", required_argument, NULL, 'X'},
 		{"wal-segsize", required_argument, NULL, 12},
 		{"data-checksums", no_argument, NULL, 'k'},
+#ifdef	USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#endif							/* USE_ENCRYPTION */
 		{"allow-group-access", no_argument, NULL, 'g'},
 		{NULL, 0, NULL, 0}
 	};
@@ -3094,7 +3194,7 @@ main(int argc, char *argv[])
 
 	/* process command-line options */
 
-	while ((c = getopt_long(argc, argv, "A:dD:E:gkL:nNsST:U:WX:", long_options, &option_index)) != -1)
+	while ((c = getopt_long(argc, argv, "A:dD:E:gkK:L:nNsST:U:WX:", long_options, &option_index)) != -1)
 	{
 		switch (c)
 		{
@@ -3146,6 +3246,11 @@ main(int argc, char *argv[])
 			case 'k':
 				data_checksums = true;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'L':
 				share_path = pg_strdup(optarg);
 				break;
@@ -3316,6 +3421,24 @@ main(int argc, char *argv[])
 	if (pwprompt || pwfilename)
 		get_su_pwd();
 
+	/*
+	 * Try to retrieve the command from environment variable. We do this
+	 * primarily to create encrypted clusters during automated tests. XXX Not
+	 * sure the variable should be documented. If we do, then pg_ctl should
+	 * probably accept it too.
+	 */
+	if (encryption_key_command == NULL)
+	{
+		encryption_key_command = getenv("PGENCRKEYCMD");
+		if (encryption_key_command && strlen(encryption_key_command) == 0)
+			encryption_key_command = NULL;
+	}
+
+	if (encryption_key_command)
+		printf(_("Data encryption is enabled.\n"));
+	else
+		printf(_("Data encryption is disabled.\n"));
+
 	printf("\n");
 
 	initialize_data_directory();
diff --git a/src/bin/pg_basebackup/pg_basebackup.c b/src/bin/pg_basebackup/pg_basebackup.c
index 792c81e788..2c0f342717 100644
--- a/src/bin/pg_basebackup/pg_basebackup.c
+++ b/src/bin/pg_basebackup/pg_basebackup.c
@@ -4,6 +4,7 @@
  *
  * Author: Magnus Hagander <magnus@hagander.net>
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -29,6 +30,7 @@
 #include "access/xlog_internal.h"
 #include "common/file_perm.h"
 #include "common/file_utils.h"
+#include "common/encryption.h"
 #include "common/logging.h"
 #include "common/string.h"
 #include "fe_utils/string_utils.h"
@@ -99,6 +101,7 @@ static bool writerecoveryconf = false;
 static bool do_sync = true;
 static int	standby_message_timeout = 10 * 1000;	/* 10 sec = default */
 static pg_time_t last_progress_report = 0;
+static bool decrypt = false;
 static int32 maxrate = 0;		/* no limit by default */
 static char *replication_slot = NULL;
 static bool temp_replication_slot = true;
@@ -350,6 +353,9 @@ usage(void)
 	printf(_("      --waldir=WALDIR    location for the write-ahead log directory\n"));
 	printf(_("  -X, --wal-method=none|fetch|stream\n"
 			 "                         include required WAL files with specified method\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -y, --decrypt          receive the data decrypted\n"));
+#endif	/* USE_ENCRYPTION */
 	printf(_("  -z, --gzip             compress tar output\n"));
 	printf(_("  -Z, --compress=0-9     compress tar output with given compression level\n"));
 	printf(_("\nGeneral options:\n"));
@@ -499,6 +505,7 @@ LogStreamerMain(logstreamer_param *param)
 	stream.synchronous = false;
 	/* fsync happens at the end of pg_basebackup for all data */
 	stream.do_sync = false;
+	stream.decrypt = decrypt;
 	stream.mark_done = true;
 	stream.partial_suffix = NULL;
 	stream.replication_slot = replication_slot;
@@ -1901,8 +1908,12 @@ BaseBackup(void)
 			fprintf(stderr, "\n");
 	}
 
+	/*
+	 * If user requested decryption, we blindly pass the DECRYPT option and
+	 * let server ignore it if the cluster is not encrypted.
+	 */
 	basebkp =
-		psprintf("BASE_BACKUP LABEL '%s' %s %s %s %s %s %s %s",
+		psprintf("BASE_BACKUP LABEL '%s' %s %s %s %s %s %s %s %s",
 				 escaped_label,
 				 showprogress ? "PROGRESS" : "",
 				 includewal == FETCH_WAL ? "WAL" : "",
@@ -1910,7 +1921,8 @@ BaseBackup(void)
 				 includewal == NO_WAL ? "" : "NOWAIT",
 				 maxrate_clause ? maxrate_clause : "",
 				 format == 't' ? "TABLESPACE_MAP" : "",
-				 verify_checksums ? "" : "NOVERIFY_CHECKSUMS");
+				 verify_checksums ? "" : "NOVERIFY_CHECKSUMS",
+				 decrypt ? "DECRYPT" : "");
 
 	if (PQsendQuery(conn, basebkp) == 0)
 	{
@@ -2208,6 +2220,9 @@ main(int argc, char **argv)
 		{"slot", required_argument, NULL, 'S'},
 		{"tablespace-mapping", required_argument, NULL, 'T'},
 		{"wal-method", required_argument, NULL, 'X'},
+#ifdef	USE_ENCRYPTION
+		{"decrypt", no_argument, NULL, 'y'},
+#endif							/* USE_ENCRYPTION */
 		{"gzip", no_argument, NULL, 'z'},
 		{"compress", required_argument, NULL, 'Z'},
 		{"label", required_argument, NULL, 'l'},
@@ -2252,7 +2267,7 @@ main(int argc, char **argv)
 
 	atexit(cleanup_directories_atexit);
 
-	while ((c = getopt_long(argc, argv, "CD:F:r:RS:T:X:l:nNzZ:d:c:h:p:U:s:wWkvP",
+	while ((c = getopt_long(argc, argv, "CD:F:r:RS:T:X:l:nNyzZ:d:c:h:p:U:s:wWkvP",
 							long_options, &option_index)) != -1)
 	{
 		switch (c)
@@ -2319,6 +2334,11 @@ main(int argc, char **argv)
 					exit(1);
 				}
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'y':
+				decrypt = true;
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 1:
 				xlog_dir = pg_strdup(optarg);
 				break;
diff --git a/src/bin/pg_basebackup/pg_receivewal.c b/src/bin/pg_basebackup/pg_receivewal.c
index 1bb689dd7c..26bb9f52fa 100644
--- a/src/bin/pg_basebackup/pg_receivewal.c
+++ b/src/bin/pg_basebackup/pg_receivewal.c
@@ -5,6 +5,7 @@
  *
  * Author: Magnus Hagander <magnus@hagander.net>
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -43,6 +44,7 @@ static bool do_create_slot = false;
 static bool slot_exists_ok = false;
 static bool do_drop_slot = false;
 static bool do_sync = true;
+static bool decrypt = false;
 static bool synchronous = false;
 static char *replication_slot = NULL;
 static XLogRecPtr endpos = InvalidXLogRecPtr;
@@ -92,6 +94,9 @@ usage(void)
 	printf(_("      --synchronous      flush write-ahead log immediately after writing\n"));
 	printf(_("  -v, --verbose          output verbose messages\n"));
 	printf(_("  -V, --version          output version information, then exit\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -y, --decrypt          receive the data decrypted\n"));
+#endif	/* USE_ENCRYPTION */
 	printf(_("  -Z, --compress=0-9     compress logs with given compression level\n"));
 	printf(_("  -?, --help             show this help, then exit\n"));
 	printf(_("\nConnection options:\n"));
@@ -429,6 +434,7 @@ StreamLog(void)
 	stream.standby_message_timeout = standby_message_timeout;
 	stream.synchronous = synchronous;
 	stream.do_sync = do_sync;
+	stream.decrypt = decrypt;
 	stream.mark_done = false;
 	stream.walmethod = CreateWalDirectoryMethod(basedir, compresslevel,
 												stream.do_sync);
@@ -518,7 +524,7 @@ main(int argc, char **argv)
 		}
 	}
 
-	while ((c = getopt_long(argc, argv, "D:d:E:h:p:U:s:S:nwWvZ:",
+	while ((c = getopt_long(argc, argv, "D:d:E:h:p:U:s:S:nwWvyZ:",
 							long_options, &option_index)) != -1)
 	{
 		switch (c)
@@ -574,6 +580,11 @@ main(int argc, char **argv)
 			case 'v':
 				verbose++;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'y':
+				decrypt = true;
+				break;
+#endif	/* USE_ENCRYPTION */
 			case 'Z':
 				compresslevel = atoi(optarg);
 				if (compresslevel < 0 || compresslevel > 9)
diff --git a/src/bin/pg_basebackup/receivelog.c b/src/bin/pg_basebackup/receivelog.c
index 8dfce7d1ca..a95611eecc 100644
--- a/src/bin/pg_basebackup/receivelog.c
+++ b/src/bin/pg_basebackup/receivelog.c
@@ -5,6 +5,7 @@
  *
  * Author: Magnus Hagander <magnus@hagander.net>
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -457,6 +458,7 @@ ReceiveXlogStream(PGconn *conn, StreamCtl *stream)
 	char		slotcmd[128];
 	PGresult   *res;
 	XLogRecPtr	stoppos;
+	char	*decrypt_cmd = "";
 
 	/*
 	 * The caller should've checked the server version already, but doesn't do
@@ -524,6 +526,13 @@ ReceiveXlogStream(PGconn *conn, StreamCtl *stream)
 		PQclear(res);
 	}
 
+	/*
+	 * If user requested decryption, we blindly pass the DECRYPT option and
+	 * let server ignore it if the cluster is not encrypted.
+	 */
+	if (stream->decrypt)
+		decrypt_cmd = "DECRYPT";
+
 	/*
 	 * initialize flush position to starting point, it's the caller's
 	 * responsibility that that's sane.
@@ -577,10 +586,11 @@ ReceiveXlogStream(PGconn *conn, StreamCtl *stream)
 			return true;
 
 		/* Initiate the replication stream at specified location */
-		snprintf(query, sizeof(query), "START_REPLICATION %s%X/%X TIMELINE %u",
+		snprintf(query, sizeof(query), "START_REPLICATION %s%X/%X TIMELINE %u %s",
 				 slotcmd,
 				 (uint32) (stream->startpos >> 32), (uint32) stream->startpos,
-				 stream->timeline);
+				 stream->timeline,
+				 decrypt_cmd);
 		res = PQexec(conn, query);
 		if (PQresultStatus(res) != PGRES_COPY_BOTH)
 		{
diff --git a/src/bin/pg_basebackup/receivelog.h b/src/bin/pg_basebackup/receivelog.h
index b6e2743f55..ee6a2cdf93 100644
--- a/src/bin/pg_basebackup/receivelog.h
+++ b/src/bin/pg_basebackup/receivelog.h
@@ -2,6 +2,7 @@
  *
  * receivelog.h
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -38,6 +39,7 @@ typedef struct StreamCtl
 	bool		mark_done;		/* Mark segment as done in generated archive */
 	bool		do_sync;		/* Flush to disk to ensure consistent state of
 								 * data */
+	bool		decrypt;		/* Decrypt the stream if it's encrypted. */
 
 	stream_stop_callback stream_stop;	/* Stop streaming when returns true */
 
diff --git a/src/bin/pg_checksums/pg_checksums.c b/src/bin/pg_checksums/pg_checksums.c
index 2a749266ad..bdf5eb0631 100644
--- a/src/bin/pg_checksums/pg_checksums.c
+++ b/src/bin/pg_checksums/pg_checksums.c
@@ -4,6 +4,7 @@
  *	  Checks, enables or disables page level checksums for an offline
  *	  cluster
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -115,6 +116,9 @@ static const struct exclude_list_item skip[] = {
 	{"PG_VERSION", false},
 #ifdef EXEC_BACKEND
 	{"config_exec_params", true},
+#endif
+#ifdef USE_ENCRYPTION
+	{"kdf_params", false},
 #endif
 	{NULL, false}
 };
@@ -236,8 +240,11 @@ scan_file(const char *fn, BlockNumber segmentno)
 		 */
 		current_size += r;
 
-		/* New pages have no checksum yet */
-		if (PageIsNew(header))
+		/*
+		 * New pages have no checksum yet, unless it's encrypted - see
+		 * PageSetChecksumCopy() for explanation.
+		 */
+		if (ControlFile->data_cipher == PG_CIPHER_NONE && PageIsNew(header))
 			continue;
 
 		csum = pg_checksum_page(buf.data, blockno + segmentno * RELSEG_SIZE);
diff --git a/src/bin/pg_controldata/pg_controldata.c b/src/bin/pg_controldata/pg_controldata.c
index d955b97c0b..5109b931a7 100644
--- a/src/bin/pg_controldata/pg_controldata.c
+++ b/src/bin/pg_controldata/pg_controldata.c
@@ -3,6 +3,7 @@
  *
  * reads the data from $PGDATA/global/pg_control
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * copyright (c) Oliver Elphick <olly@lfix.co.uk>, 2001;
  * licence: BSD
  *
@@ -18,6 +19,7 @@
 
 #include "postgres.h"
 
+#include <arpa/inet.h>
 #include <time.h>
 
 #include "access/transam.h"
@@ -344,5 +346,14 @@ main(int argc, char *argv[])
 		   ControlFile->data_checksum_version);
 	printf(_("Mock authentication nonce:            %s\n"),
 		   mock_auth_nonce_str);
+	printf(_("Data encryption:                      %s\n"),
+		   ControlFile->data_cipher > PG_CIPHER_NONE ? _("on") : _("off"));
+	if (ControlFile->data_cipher > PG_CIPHER_NONE)
+		printf(_("Data encryption fingerprint:          %08X%08X%08X%08X\n"),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[0]),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[1]),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[2]),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[3])
+			);
 	return 0;
 }
diff --git a/src/bin/pg_ctl/Makefile b/src/bin/pg_ctl/Makefile
index 83cbf97ed8..ed949a0973 100644
--- a/src/bin/pg_ctl/Makefile
+++ b/src/bin/pg_ctl/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/pg_ctl
 #
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
 # Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -20,9 +21,9 @@ include $(top_builddir)/src/Makefile.global
 # but let's not pull that in on platforms where we don't need it.
 ifeq ($(PORTNAME), win32)
 override CPPFLAGS := -I$(libpq_srcdir) $(CPPFLAGS)
-LDFLAGS_INTERNAL += $(libpq_pgport)
 SUBMAKE_LIBPQ := submake-libpq
 endif
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 
 OBJS=	pg_ctl.o $(WIN32RES)
 
diff --git a/src/bin/pg_ctl/pg_ctl.c b/src/bin/pg_ctl/pg_ctl.c
index a6f2140e3a..d7a168dbe0 100644
--- a/src/bin/pg_ctl/pg_ctl.c
+++ b/src/bin/pg_ctl/pg_ctl.c
@@ -2,6 +2,7 @@
  *
  * pg_ctl --- start/stops/restarts the PostgreSQL server
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  *
  * src/bin/pg_ctl/pg_ctl.c
@@ -25,8 +26,10 @@
 
 #include "catalog/pg_control.h"
 #include "common/controldata_utils.h"
+#include "common/encryption.h"
 #include "common/file_perm.h"
 #include "common/logging.h"
+#include "fe_utils/encryption.h"
 #include "getopt_long.h"
 #include "utils/pidfile.h"
 
@@ -106,6 +109,21 @@ static char logrotate_file[MAXPGPATH];
 
 static volatile pgpid_t postmasterPID = -1;
 
+/*
+ * Define encryption_key locally rather that linking to storage/encryption.c
+ * only because of this one variable.
+ */
+extern unsigned char encryption_key[ENCRYPTION_KEY_LENGTH];
+#ifndef HAVE_UNIX_SOCKETS
+/*
+ * Port at which postmaster listens for encryption key message.
+ *
+ * This is only useful for pg_upgrade which starts the cluster on a port
+ * different from that in configuration file.
+ */
+static char *encr_key_port = NULL;
+#endif
+
 #ifdef WIN32
 static DWORD pgctl_start_type = SERVICE_AUTO_START;
 static SERVICE_STATUS status;
@@ -133,6 +151,11 @@ static void do_logrotate(void);
 static void do_kill(pgpid_t pid);
 static void print_msg(const char *msg);
 static void adjust_data_dir(void);
+static char *get_config_variable(const char *var_name, size_t res_size);
+#ifdef USE_ENCRYPTION
+static char *get_first_csv_item(char *csv_list);
+static void get_postmaster_address(char **host_p, char **port_str_p);
+#endif	/* USE_ENCRYPTION */
 
 #ifdef WIN32
 #if (_MSC_VER >= 1800)
@@ -901,11 +924,27 @@ find_other_exec_or_die(const char *argv0, const char *target, const char *versio
 static void
 do_init(void)
 {
-	char	   *cmd;
+	char		*cmd;
+	char *encr_opt_str;
+
+	/* Prepare the -K option for initdb. */
+	if (encryption_key_command)
+	{
+		size_t		len;
+
+		len = strlen(encryption_key_command) + 7;
+		encr_opt_str = (char *) pg_malloc(len);
+		snprintf(encr_opt_str, len, " -K \"%s\"",
+				 encryption_key_command);
+	}
+	else
+	{
+		encr_opt_str = (char *) pg_malloc(1);
+		encr_opt_str[0] = '\0';
+	}
 
 	if (exec_path == NULL)
 		exec_path = find_other_exec_or_die(argv0, "initdb", "initdb (PostgreSQL) " PG_VERSION "\n");
-
 	if (pgdata_opt == NULL)
 		pgdata_opt = "";
 
@@ -913,11 +952,11 @@ do_init(void)
 		post_opts = "";
 
 	if (!silent_mode)
-		cmd = psprintf("\"%s\" %s%s",
-					   exec_path, pgdata_opt, post_opts);
+		cmd = psprintf("\"%s\" %s%s%s",
+					   exec_path, pgdata_opt, post_opts, encr_opt_str);
 	else
-		cmd = psprintf("\"%s\" %s%s > \"%s\"",
-					   exec_path, pgdata_opt, post_opts, DEVNULL);
+		cmd = psprintf("\"%s\" %s%s%s > \"%s\"",
+					   exec_path, pgdata_opt, post_opts, encr_opt_str, DEVNULL);
 
 	if (system(cmd) != 0)
 	{
@@ -931,6 +970,9 @@ do_start(void)
 {
 	pgpid_t		old_pid = 0;
 	pgpid_t		pm_pid;
+#ifdef USE_ENCRYPTION
+	SendKeyArgs	sk_args;
+#endif	/* USE_ENCRYPTION */
 
 	if (ctl_command != RESTART_COMMAND)
 	{
@@ -970,7 +1012,95 @@ do_start(void)
 	}
 #endif
 
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * If encryption key is needed, retrieve it before trying to start
+		 * postmaster.
+		 */
+		run_encryption_key_command(pg_data);
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	pm_pid = start_postmaster();
+#ifdef WIN32
+	sk_args.pmProcess = postmasterProcess;
+#endif
+
+#ifdef USE_ENCRYPTION
+	sk_args.pm_pid = pm_pid;
+	sk_args.pm_exited = false;
+	if (encryption_key_command)
+	{
+		char	*keycmd_conf_file;
+
+		sk_args.encryption_key = encryption_key;
+
+		/* Is the key command also configured in postgresql.conf ? */
+		keycmd_conf_file = get_config_variable("encryption_key_command",
+											   MAXPGPATH);
+
+		if (keycmd_conf_file)
+			print_msg(_("ignoring the -K option due to presence of encryption_key_command in configuration file\n"));
+	}
+	else
+	{
+		/*
+		 * An empty key message should be sent if no key command was
+		 * passed. It's more user friendly to let startup fail immediately
+		 * than to let postmaster wait until MAX_WAIT_FOR_KEY_SECS has elapsed
+		 * and then fail.
+		 */
+		sk_args.encryption_key = NULL;
+	}
+
+	get_postmaster_address(&sk_args.host, &sk_args.port);
+#ifndef HAVE_UNIX_SOCKETS
+	if (encr_key_port)
+		sk_args.port = encr_key_port;
+#endif
+	sk_args.error_msg = NULL;
+
+	/*
+	 * Send the key to the postmaster, or an empty message if we have no
+	 * key. The latter means that postmaster should have tried to get the key
+	 * using a command that it might find in postgresql.conf, so we shouldn't
+	 * send it again.
+	 */
+	if (!send_key_to_postmaster(&sk_args))
+	{
+		/*
+		 * Skip the waiting below if we are sure that postmaster is no longer
+		 * alive. (It wouldn't work anyway if we called waitpid() for an
+		 * already exited process again.)
+		 */
+		if (sk_args.pm_exited)
+		{
+			if (do_wait)
+				print_msg(_(" stopped waiting\n"));
+			write_stderr(_("%s: could not start server\n"
+						   "Examine the log output.\n"),
+						 progname);
+			exit(1);
+		}
+
+		/*
+		 * Some other problem in the communication between pg_ctl and the
+		 * postmaster. If postmaster does not receive the key, it will fail to
+		 * start and report the missing encryption key in the server log.
+		 *
+		 * Formerly we used to report an error here, but the error message was
+		 * rather confusing. We could emit a debug message, but there's
+		 * nothing like a debug logging in pg_ctl.
+		 */
+	}
+#endif	/* USE_ENCRYPTION */
 
 	if (do_wait)
 	{
@@ -2091,10 +2221,10 @@ do_help(void)
 	printf(_("%s is a utility to initialize, start, stop, or control a PostgreSQL server.\n\n"), progname);
 	printf(_("Usage:\n"));
 	printf(_("  %s init[db]   [-D DATADIR] [-s] [-o OPTIONS]\n"), progname);
-	printf(_("  %s start      [-D DATADIR] [-l FILENAME] [-W] [-t SECS] [-s]\n"
+	printf(_("  %s start      [-D DATADIR] [-l FILENAME] [-W] [-t SECS] [-K KEY-CMD] [-s]\n"
 			 "                    [-o OPTIONS] [-p PATH] [-c]\n"), progname);
 	printf(_("  %s stop       [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]\n"), progname);
-	printf(_("  %s restart    [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]\n"
+	printf(_("  %s restart    [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-K KEY-CMD] [-s]\n"
 			 "                    [-o OPTIONS] [-c]\n"), progname);
 	printf(_("  %s reload     [-D DATADIR] [-s]\n"), progname);
 	printf(_("  %s status     [-D DATADIR]\n"), progname);
@@ -2112,6 +2242,10 @@ do_help(void)
 #ifdef WIN32
 	printf(_("  -e SOURCE              event source for logging when running as a service\n"));
 #endif
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command\n"
+			 "                         command that returns encryption key\n\n"));
+#endif	/* USE_ENCRYPTION */
 	printf(_("  -s, --silent           only print errors, no informational messages\n"));
 	printf(_("  -t, --timeout=SECS     seconds to wait when using -w option\n"));
 	printf(_("  -V, --version          output version information, then exit\n"));
@@ -2239,28 +2373,45 @@ set_starttype(char *starttypeopt)
 static void
 adjust_data_dir(void)
 {
-	char		filename[MAXPGPATH];
-	char	   *my_exec_path,
-			   *cmd;
-	FILE	   *fd;
+	char	*conf_path;
+	char	*filename;
+	FILE	*fd;
 
 	/* do nothing if we're working without knowledge of data dir */
 	if (pg_config == NULL)
 		return;
 
-	/* If there is no postgresql.conf, it can't be a config-only dir */
-	snprintf(filename, sizeof(filename), "%s/postgresql.conf", pg_config);
-	if ((fd = fopen(filename, "r")) == NULL)
+	/* If PG_VERSION exists, it can't be a config-only dir */
+	conf_path = psprintf("%s/PG_VERSION", pg_config);
+	if ((fd = fopen(conf_path, "r")) != NULL)
 		return;
-	fclose(fd);
 
-	/* If PG_VERSION exists, it can't be a config-only dir */
-	snprintf(filename, sizeof(filename), "%s/PG_VERSION", pg_config);
-	if ((fd = fopen(filename, "r")) != NULL)
+	filename = get_config_variable("data_directory", MAXPGPATH);
+
+	if (filename)
 	{
-		fclose(fd);
-		return;
+		free(pg_data);
+		pg_data = filename;
+		canonicalize_path(pg_data);
 	}
+}
+
+/*
+ * Retrieve value of configuration variable from configuration file.
+ */
+static char *
+get_config_variable(const char *var_name, size_t res_size)
+{
+	char		filename[MAXPGPATH];
+	char		*my_exec_path, *cmd;
+	char	*result;
+	FILE	   *fd;
+
+	/* If there is no postgresql.conf, the data dir is not useful. */
+	snprintf(filename, sizeof(filename), "%s/postgresql.conf", pg_config);
+	if ((fd = fopen(filename, "r")) == NULL)
+		return NULL;
+	fclose(fd);
 
 	/* Must be a configuration directory, so find the data directory */
 
@@ -2271,29 +2422,98 @@ adjust_data_dir(void)
 		my_exec_path = pg_strdup(exec_path);
 
 	/* it's important for -C to be the first option, see main.c */
-	cmd = psprintf("\"%s\" -C data_directory %s%s",
+	cmd = psprintf("\"%s\" -C %s %s%s",
 				   my_exec_path,
+				   var_name,
 				   pgdata_opt ? pgdata_opt : "",
 				   post_opts ? post_opts : "");
 
+	result = pg_malloc(res_size);
 	fd = popen(cmd, "r");
-	if (fd == NULL || fgets(filename, sizeof(filename), fd) == NULL)
+	if (fd == NULL || fgets(result, res_size, fd) == NULL)
 	{
-		write_stderr(_("%s: could not determine the data directory using command \"%s\"\n"), progname, cmd);
+		write_stderr(_("%s: could not determine the value of \"%s\" \"%s\"\n"),
+					 progname, var_name, cmd);
+		free(result);
 		exit(1);
 	}
 	pclose(fd);
 	free(my_exec_path);
 
 	/* Remove trailing newline */
-	if (strchr(filename, '\n') != NULL)
-		*strchr(filename, '\n') = '\0';
+	if (strchr(result, '\n') != NULL)
+		*strchr(result, '\n') = '\0';
+
+	if (strlen(result) == 0)
+	{
+		pg_free(result);
+		result = NULL;
+	}
 
-	free(pg_data);
-	pg_data = pg_strdup(filename);
-	canonicalize_path(pg_data);
+	return result;
 }
 
+#ifdef USE_ENCRYPTION
+/*
+ * Get the first item of comma-separated list or NULL if there's no valid
+ * item.
+ */
+static char *
+get_first_csv_item(char *csv_list)
+{
+	char	*start, *end, *result;
+
+	start = csv_list;
+	/* First, skip the leading space. */
+	while (isspace(*start))
+		start++;
+	if (*start == '\0')
+		return NULL;
+
+	end = start;
+	while (*end != '\0' && *end != ',' && !isspace(*end))
+		end++;
+	if (end == start)
+		return NULL;
+
+	result = pg_strdup(start);
+
+	/* Trim the string if needed. */
+	if (*end != '\0')
+		result[end - start] = '\0';
+
+	return result;
+}
+
+/*
+ * Retrieve host name and port to which the encryption key should be sent.
+ */
+static void
+get_postmaster_address(char **host_p, char **port_str_p)
+{
+	char	*socket_dirs;
+
+	/* First, try to connect via the unix socket. */
+	socket_dirs = get_config_variable("unix_socket_directories",
+									  MAXPGPATH);
+	if (socket_dirs)
+	{
+		/* If there are multiple sockets, use the first one. */
+		*host_p = get_first_csv_item(socket_dirs);
+	}
+	else
+	{
+		/* Let libpq use the default value.*/
+		*host_p = NULL;
+	}
+
+	/*
+	 * The maximum length of the port number is 5 characters for the port
+	 * number (65535 at maximum) + '\n' + terminating '\0'.
+	 */
+	*port_str_p = get_config_variable("port", 7);
+}
+#endif	/* USE_ENCRYPTION */
 
 static DBState
 get_control_dbstate(void)
@@ -2326,6 +2546,12 @@ main(int argc, char **argv)
 		{"options", required_argument, NULL, 'o'},
 		{"silent", no_argument, NULL, 's'},
 		{"timeout", required_argument, NULL, 't'},
+#ifdef USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#ifndef HAVE_UNIX_SOCKETS
+		{"encryption-key-port", required_argument, NULL, 1},
+#endif	/* HAVE_UNIX_SOCKETS */
+#endif	/* USE_ENCRYPTION */
 		{"core-files", no_argument, NULL, 'c'},
 		{"wait", no_argument, NULL, 'w'},
 		{"no-wait", no_argument, NULL, 'W'},
@@ -2396,7 +2622,7 @@ main(int argc, char **argv)
 	/* process command-line options */
 	while (optind < argc)
 	{
-		while ((c = getopt_long(argc, argv, "cD:e:l:m:N:o:p:P:sS:t:U:wW",
+		while ((c = getopt_long(argc, argv, "cD:e:K:l:m:N:o:p:P:sS:t:U:wW",
 								long_options, &option_index)) != -1)
 		{
 			switch (c)
@@ -2422,6 +2648,11 @@ main(int argc, char **argv)
 				case 'e':
 					event_source = pg_strdup(optarg);
 					break;
+#ifdef USE_ENCRYPTION
+				case 'K':
+					encryption_key_command = pg_strdup(optarg);
+					break;
+#endif	/* USE_ENCRYPTION */
 				case 'l':
 					log_file = pg_strdup(optarg);
 					break;
@@ -2481,6 +2712,11 @@ main(int argc, char **argv)
 				case 'c':
 					allow_core_files = true;
 					break;
+#ifndef HAVE_UNIX_SOCKETS
+				case 1:
+					encr_key_port = pg_strdup(optarg);
+					break;
+#endif
 				default:
 					/* getopt_long already issued a suitable error message */
 					do_advice();
@@ -2598,6 +2834,11 @@ main(int argc, char **argv)
 			umask(pg_mode_mask);
 	}
 
+	if (encryption_key_command && ctl_command !=
+		START_COMMAND && ctl_command != RESTART_COMMAND &&
+		ctl_command != INIT_COMMAND)
+		write_stderr(_("%s: ignoring the -K option, it's only useful for start or restart commands\n"), progname);
+
 	switch (ctl_command)
 	{
 		case INIT_COMMAND:
diff --git a/src/bin/pg_keytool/.gitignore b/src/bin/pg_keytool/.gitignore
new file mode 100644
index 0000000000..249876a6ed
--- /dev/null
+++ b/src/bin/pg_keytool/.gitignore
@@ -0,0 +1 @@
+/pg_keytool
diff --git a/src/bin/pg_keytool/Makefile b/src/bin/pg_keytool/Makefile
new file mode 100644
index 0000000000..0509854118
--- /dev/null
+++ b/src/bin/pg_keytool/Makefile
@@ -0,0 +1,39 @@
+#-------------------------------------------------------------------------
+#
+# Makefile for src/bin/pg_keytool
+#
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+#
+# src/bin/pg_keytool/Makefile
+#
+#-------------------------------------------------------------------------
+
+PGFILEDESC = "pg_keytool - handle cluster encryption key"
+PGAPPICON=win32
+
+subdir = src/bin/pg_keytool
+top_builddir = ../../..
+include $(top_builddir)/src/Makefile.global
+
+OBJS = pg_keytool.o $(RMGRDESCOBJS) $(WIN32RES)
+
+override CPPFLAGS := -I$(libpq_srcdir) $(CPPFLAGS)
+override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
+
+all: pg_keytool
+
+pg_keytool: $(OBJS) | submake-libpgport
+	$(CC) $(CFLAGS) $^ $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@$(X)
+
+install: all installdirs
+	$(INSTALL_PROGRAM) pg_keytool$(X) '$(DESTDIR)$(bindir)/pg_keytool$(X)'
+
+installdirs:
+	$(MKDIR_P) '$(DESTDIR)$(bindir)'
+
+uninstall:
+	rm -f '$(DESTDIR)$(bindir)/pg_keytool$(X)'
+
+clean distclean maintainer-clean:
+	rm -f pg_keytool$(X) $(OBJS) encryption.c
diff --git a/src/bin/pg_keytool/pg_keytool.c b/src/bin/pg_keytool/pg_keytool.c
new file mode 100644
index 0000000000..c5ac9a47be
--- /dev/null
+++ b/src/bin/pg_keytool/pg_keytool.c
@@ -0,0 +1,274 @@
+/*-------------------------------------------------------------------------
+ *
+ * pg_keytool.c - Handle cluster encryption key.
+ *
+ * Copyright (c) 2013-2019, PostgreSQL Global Development Group
+ *
+ * IDENTIFICATION
+ *		  src/bin/pg_keytool/pg_keytool.c
+ *-------------------------------------------------------------------------
+ */
+/*
+ * TODO Adopt the new frontend logging API, after some things are clarified:
+ * https://www.postgresql.org/message-id/1939.1560773970%40localhost
+ */
+#define FRONTEND 1
+#include "postgres.h"
+
+#include <dirent.h>
+#include <unistd.h>
+
+#include "common/fe_memutils.h"
+#include "common/logging.h"
+#include "fe_utils/encryption.h"
+#include "libpq-fe.h"
+#include "libpq/pqcomm.h"
+#include "port/pg_crc32c.h"
+#include "getopt_long.h"
+
+#ifdef USE_ENCRYPTION
+/*
+ * TODO Tune these values.
+ */
+#define ENCRYPTION_PWD_MIN_LENGTH	8
+#define ENCRYPTION_PWD_MAX_LENGTH	16
+
+static const char *progname;
+
+extern unsigned char encryption_key[ENCRYPTION_KEY_LENGTH];
+
+static void
+usage(const char *progname)
+{
+	const char *env;
+
+	printf(_("%s is a tool to handle cluster encryption key.\n\n"),
+		   progname);
+	printf(_("Usage:\n"));
+	printf(_("  %s [OPTION]...\n"), progname);
+	printf(_("\nOptions:\n"));
+	printf(_("  -D, --pgdata=DATADIR   data directory\n"));
+	/* Display default host */
+	env = getenv("PGHOST");
+	printf(_("  -h, --host=HOSTNAME    database server host or socket directory (default: \"%s\")\n"),
+			env ? env : _("local socket"));
+	/* Display default port */
+	env = getenv("PGPORT");
+	printf(_("  -p, --port=PORT        database server port (default: \"%s\")\n"),
+			env ? env : DEF_PGPORT_STR);
+#ifdef HAVE_UNIX_SOCKETS
+	printf(_("  -s,                    send output to database server\n"));
+#endif	/* HAVE_UNIX_SOCKETS */
+	printf(_("  -w                     expect password on input, not a key\n"));
+	printf(_("  -?, --help             show this help, then exit\n\n"));
+	printf(_("Password or key is read from stdin. Key is sent to PostgreSQL server being started\n"));
+}
+#endif							/* USE_ENCRYPTION */
+
+int
+main(int argc, char **argv)
+{
+/*
+ * If no encryption library is linked, let the utility fail immediately. It'd
+ * be weird if we reported incorrect usage just to say later that no useful
+ * work can be done anyway.
+ */
+#ifdef USE_ENCRYPTION
+	int			c;
+	char		*host = NULL;
+	char		*port_str = NULL;
+	char	   *DataDir = NULL;
+	bool		to_server = false;
+	bool		expect_password = false;
+	int			i, n;
+	int			optindex;
+	char		password[ENCRYPTION_PWD_MAX_LENGTH];
+	char		key_chars[ENCRYPTION_KEY_CHARS];
+
+	static struct option long_options[] =
+	{
+		{"pgdata", required_argument, NULL, 'D'},
+		{"host", required_argument, NULL, 'h'},
+		{"port", required_argument, NULL, 'p'},
+		{NULL, 0, NULL, 0}
+	};
+
+	pg_logging_init(argv[0]);
+	progname = get_progname(argv[0]);
+
+	if (argc > 1)
+	{
+		if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-?") == 0)
+		{
+			usage(progname);
+			exit(0);
+		}
+		if (strcmp(argv[1], "--version") == 0 || strcmp(argv[1], "-V") == 0)
+		{
+			puts("pg_keytool (PostgreSQL) " PG_VERSION);
+			exit(0);
+		}
+	}
+
+	while ((c = getopt_long(argc, argv, "h:D:p:sw",
+							long_options, &optindex)) != -1)
+	{
+		switch (c)
+		{
+			case 'D':
+				DataDir = optarg;
+				break;
+
+			case 'h':
+				host = pg_strdup(optarg);
+				break;
+
+			case 'p':
+				port_str = pg_strdup(optarg);
+				break;
+
+			case 's':
+				to_server = true;
+				break;
+
+			case 'w':
+				expect_password = true;
+				break;
+
+			case '?':
+				/* Actual help option given */
+				if (strcmp(argv[optind - 1], "-?") == 0)
+				{
+					usage(progname);
+					exit(EXIT_SUCCESS);
+				}
+
+			default:
+				pg_log_error("Try \"%s --help\" for more information.", progname);
+				exit(1);
+		}
+	}
+
+	/* Complain if any arguments remain */
+	if (optind < argc)
+	{
+		fprintf(stderr, _("%s: too many command-line arguments (first is \"%s\")\n"),
+				progname, argv[optind]);
+		fprintf(stderr, _("Try \"%s --help\" for more information.\n"),
+				progname);
+		exit(1);
+	}
+
+	/* Try to initialize DataDir using environment variable. */
+	if (DataDir == NULL)
+	{
+		DataDir = getenv("PGDATA");
+		if (DataDir)
+			DataDir = pg_strdup(DataDir);
+	}
+
+	if (DataDir)
+		canonicalize_path(DataDir);
+
+	/*
+	 * The KDF file is needed to derive the key from password, and this file
+	 * is located in the data directory.
+	 */
+	if (expect_password && DataDir == NULL)
+	{
+		pg_log_error("%s: no data directory specified", progname);
+		pg_log_error("Try \"%s --help\" for more information.", progname);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((host || port_str))
+		to_server = true;
+
+	/*
+	 * Read the credentials (key or password).
+	 */
+	n = 0;
+	/* Key length in characters (two characters per hexadecimal digit) */
+	while ((c = getchar()) != EOF && c != '\n')
+	{
+		if (!expect_password)
+		{
+			if (n >= ENCRYPTION_KEY_CHARS)
+			{
+				pg_log_error("The key is too long");
+				exit(EXIT_FAILURE);
+			}
+
+			key_chars[n++] = c;
+		}
+		else
+		{
+			if (n >= ENCRYPTION_PWD_MAX_LENGTH)
+			{
+				pg_log_error("The password is too long");
+				exit(EXIT_FAILURE);
+			}
+
+			password[n++] = c;
+		}
+	}
+
+	/* If password was received, turn it into encryption key. */
+	if (!expect_password)
+	{
+		if (n < ENCRYPTION_KEY_CHARS)
+		{
+			pg_log_error("The key is too short");
+			exit(EXIT_FAILURE);
+		}
+
+		encryption_key_from_string(key_chars);
+	}
+	else
+	{
+		if (n < ENCRYPTION_PWD_MIN_LENGTH)
+		{
+			pg_log_error("The password is too short");
+			exit(EXIT_FAILURE);
+		}
+
+		/* Read the KDF parameters. */
+		read_kdf_file(DataDir);
+
+		/* Run the KDF. */
+		derive_key_from_password(encryption_key, password, n);
+	}
+
+	/*
+	 * Send the encryption key either to stdout or to server.
+	 */
+	if (!to_server)
+	{
+		for (i = 0; i < ENCRYPTION_KEY_LENGTH; i++)
+			printf("%.2x", encryption_key[i]);
+		printf("\n");
+	}
+	else
+	{
+		SendKeyArgs	sk_args;
+
+		sk_args.host = host;
+		sk_args.port = port_str;
+		sk_args.encryption_key = encryption_key;
+		sk_args.pm_pid = 0;
+		sk_args.error_msg = NULL;
+
+		/* XXX Try to find the postmaster PID? */
+		if (!send_key_to_postmaster(&sk_args))
+		{
+			pg_log_error("could not send encryption key to server");
+			if (sk_args.error_msg)
+				pg_log_error("%s", sk_args.error_msg);
+		}
+	}
+#else
+	pg_log_fatal(ENCRYPTION_NOT_SUPPORTED_MSG);
+	exit(EXIT_FAILURE);
+#endif							/* USE_ENCRYPTION */
+	return 0;
+}
diff --git a/src/bin/pg_resetwal/.gitignore b/src/bin/pg_resetwal/.gitignore
index 56bade5ea4..c46466c6dc 100644
--- a/src/bin/pg_resetwal/.gitignore
+++ b/src/bin/pg_resetwal/.gitignore
@@ -1,2 +1,3 @@
 /pg_resetwal
 /tmp_check/
+/encryption.c
diff --git a/src/bin/pg_resetwal/Makefile b/src/bin/pg_resetwal/Makefile
index 2a3835691f..8750973cb7 100644
--- a/src/bin/pg_resetwal/Makefile
+++ b/src/bin/pg_resetwal/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/pg_resetwal
 #
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
 # Copyright (c) 1998-2019, PostgreSQL Global Development Group
 #
 # src/bin/pg_resetwal/Makefile
@@ -15,13 +16,19 @@ subdir = src/bin/pg_resetwal
 top_builddir = ../../..
 include $(top_builddir)/src/Makefile.global
 
-OBJS= pg_resetwal.o $(WIN32RES)
+override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
+
+OBJS= pg_resetwal.o encryption.o $(WIN32RES)
 
 all: pg_resetwal
 
 pg_resetwal: $(OBJS) | submake-libpgport
 	$(CC) $(CFLAGS) $^ $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@$(X)
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) pg_resetwal$(X) '$(DESTDIR)$(bindir)/pg_resetwal$(X)'
 
@@ -32,7 +39,7 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/pg_resetwal$(X)'
 
 clean distclean maintainer-clean:
-	rm -f pg_resetwal$(X) $(OBJS)
+	rm -f pg_resetwal$(X) $(OBJS) encryption.c
 	rm -rf tmp_check
 
 check:
diff --git a/src/bin/pg_resetwal/pg_resetwal.c b/src/bin/pg_resetwal/pg_resetwal.c
index fc79896126..0f90b913bd 100644
--- a/src/bin/pg_resetwal/pg_resetwal.c
+++ b/src/bin/pg_resetwal/pg_resetwal.c
@@ -20,6 +20,7 @@
  * step 2 ...
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -37,6 +38,7 @@
 
 #include "postgres.h"
 
+#include <arpa/inet.h>
 #include <dirent.h>
 #include <fcntl.h>
 #include <sys/stat.h>
@@ -54,11 +56,12 @@
 #include "common/file_perm.h"
 #include "common/logging.h"
 #include "common/restricted_token.h"
+#include "fe_utils/encryption.h"
+#include "storage/encryption.h"
 #include "storage/large_object.h"
 #include "pg_getopt.h"
 #include "getopt_long.h"
 
-
 static ControlFileData ControlFile; /* pg_control values */
 static XLogSegNo newXlogSegNo;	/* new XLOG segment # */
 static bool guessed = false;	/* T if we had to guess at any values */
@@ -137,7 +140,7 @@ main(int argc, char *argv[])
 	}
 
 
-	while ((c = getopt_long(argc, argv, "c:D:e:fl:m:no:O:u:x:", long_options, NULL)) != -1)
+	while ((c = getopt_long(argc, argv, "c:D:e:fK:l:m:no:O:u:x:", long_options, NULL)) != -1)
 	{
 		switch (c)
 		{
@@ -294,6 +297,12 @@ main(int argc, char *argv[])
 				}
 				break;
 
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = strdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
+
 			case 'l':
 				if (strspn(optarg, "01234567890ABCDEFabcdef") != XLOG_FNAME_LEN)
 				{
@@ -424,6 +433,48 @@ main(int argc, char *argv[])
 	if (log_fname != NULL)
 		XLogFromFileName(log_fname, &minXlogTli, &minXlogSegNo, WalSegSz);
 
+	/*
+	 * If the data is encrypted, we also might need to encrypt the XLOG record
+	 * below.
+	 */
+	if (ControlFile.data_cipher > PG_CIPHER_NONE && !noupdate)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * Try to retrieve the command from environment variable. We do this
+		 * primarily to create encrypted clusters during automated tests. XXX
+		 * Not sure the variable should be documented. If we do, then pg_ctl
+		 * should probably accept it too.
+		 */
+		if (encryption_key_command == NULL)
+		{
+			encryption_key_command = getenv("PGENCRKEYCMD");
+			if (encryption_key_command && strlen(encryption_key_command) == 0)
+				encryption_key_command = NULL;
+		}
+
+		if (encryption_key_command)
+			run_encryption_key_command(DataDir);
+		else
+		{
+			/*
+			 * If executed by pg_upgrade, we don't want pg_resetwal to run the
+			 * encryption key command (possibly interactive application)
+			 * because we have no access to terminal.
+			 */
+			read_encryption_key_f(stdin, NULL);
+		}
+
+		setup_encryption();
+		data_encrypted = true;
+	}
+#else
+	{
+		pg_log_error(ENCRYPTION_NOT_SUPPORTED_MSG);
+		exit(EXIT_FAILURE);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/*
 	 * Also look at existing segment files to set up newXlogSegNo
 	 */
@@ -832,6 +883,12 @@ PrintControlValues(bool guessed)
 		   (ControlFile.float8ByVal ? _("by value") : _("by reference")));
 	printf(_("Data page checksum version:           %u\n"),
 		   ControlFile.data_checksum_version);
+	if (ControlFile.data_cipher > PG_CIPHER_NONE)
+		printf(_("Data encryption fingerprint:          %08X%08X%08X%08X\n"),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[0]),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[1]),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[2]),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[3]));
 }
 
 
@@ -1182,6 +1239,20 @@ WriteEmptyXLOG(void)
 	FIN_CRC32C(crc);
 	record->xl_crc = crc;
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, page->xlp_tli, newXlogSegNo, 0);
+		encrypt_block(buffer.data,
+					  buffer.data,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidXLogRecPtr,
+					  InvalidBlockNumber,
+					  EDK_PERMANENT);;
+	}
+
 	/* Write the first page */
 	XLogFilePath(path, ControlFile.checkPointCopy.ThisTimeLineID,
 				 newXlogSegNo, WalSegSz);
@@ -1239,12 +1310,15 @@ usage(void)
 	printf(_("  -c, --commit-timestamp-ids=XID,XID\n"
 			 "                                   set oldest and newest transactions bearing\n"
 			 "                                   commit timestamp (zero means no change)\n"));
-	printf(_(" [-D, --pgdata=]DATADIR            data directory\n"));
-	printf(_("  -e, --epoch=XIDEPOCH             set next transaction ID epoch\n"));
-	printf(_("  -f, --force                      force update to be done\n"));
-	printf(_("  -l, --next-wal-file=WALFILE      set minimum starting location for new WAL\n"));
-	printf(_("  -m, --multixact-ids=MXID,MXID    set next and oldest multitransaction ID\n"));
-	printf(_("  -n, --dry-run                    no update, just show what would be done\n"));
+	printf(_(" [-D, --pgdata=]DATADIR          data directory\n"));
+	printf(_("  -e, --epoch=XIDEPOCH           set next transaction ID epoch\n"));
+	printf(_("  -f, --force                    force update to be done\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command   command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
+	printf(_("  -l, --next-wal-file=WALFILE    set minimum starting location for new WAL\n"));
+	printf(_("  -m, --multixact-ids=MXID,MXID  set next and oldest multitransaction ID\n"));
+	printf(_("  -n, --dry-run                  no update, just show what would be done\n"));
 	printf(_("  -o, --next-oid=OID               set next OID\n"));
 	printf(_("  -O, --multixact-offset=OFFSET    set next multitransaction offset\n"));
 	printf(_("  -u, --oldest-transaction-id=XID  set oldest transaction ID\n"));
diff --git a/src/bin/pg_rewind/.gitignore b/src/bin/pg_rewind/.gitignore
index 79ddca3eec..fb6f5e2c43 100644
--- a/src/bin/pg_rewind/.gitignore
+++ b/src/bin/pg_rewind/.gitignore
@@ -1,4 +1,5 @@
 # Files generated during build
+/encryption.c
 /xlogreader.c
 /pg_rewind
 
diff --git a/src/bin/pg_rewind/Makefile b/src/bin/pg_rewind/Makefile
index 859d3abc41..e7b9f6494f 100644
--- a/src/bin/pg_rewind/Makefile
+++ b/src/bin/pg_rewind/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/pg_rewind
 #
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
 # Portions Copyright (c) 2013-2019, PostgreSQL Global Development Group
 #
 # src/bin/pg_rewind/Makefile
@@ -16,10 +17,10 @@ top_builddir = ../../..
 include $(top_builddir)/src/Makefile.global
 
 override CPPFLAGS := -I$(libpq_srcdir) -DFRONTEND $(CPPFLAGS)
-LDFLAGS_INTERNAL += $(libpq_pgport)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 
 OBJS	= pg_rewind.o parsexlog.o xlogreader.o datapagemap.o timeline.o \
-	fetch.o file_ops.o copy_fetch.o libpq_fetch.o filemap.o \
+	fetch.o file_ops.o copy_fetch.o libpq_fetch.o filemap.o encryption.o\
 	$(WIN32RES)
 
 EXTRA_CLEAN = xlogreader.c
@@ -32,6 +33,9 @@ pg_rewind: $(OBJS) | submake-libpq submake-libpgport
 xlogreader.c: % : $(top_srcdir)/src/backend/access/transam/%
 	rm -f $@ && $(LN_S) $< .
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) pg_rewind$(X) '$(DESTDIR)$(bindir)/pg_rewind$(X)'
 
@@ -42,7 +46,7 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/pg_rewind$(X)'
 
 clean distclean maintainer-clean:
-	rm -f pg_rewind$(X) $(OBJS) xlogreader.c
+	rm -f pg_rewind$(X) $(OBJS) xlogreader.c encryption.c
 	rm -rf tmp_check
 
 check:
diff --git a/src/bin/pg_rewind/parsexlog.c b/src/bin/pg_rewind/parsexlog.c
index c8fd4f0bac..a7ab7c20d5 100644
--- a/src/bin/pg_rewind/parsexlog.c
+++ b/src/bin/pg_rewind/parsexlog.c
@@ -3,6 +3,7 @@
  * parsexlog.c
  *	  Functions for reading Write-Ahead-Log
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -332,6 +333,20 @@ SimpleXLogPageRead(XLogReaderState *xlogreader, XLogRecPtr targetPagePtr,
 		return -1;
 	}
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, targetHistory[private->tliIndex].tli,
+							xlogreadsegno, targetPageOff);
+		decrypt_block(readBuf,
+					  readBuf,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_PERMANENT);
+	}
+
 	Assert(targetSegNo == xlogreadsegno);
 
 	*pageTLI = targetHistory[private->tliIndex].tli;
diff --git a/src/bin/pg_rewind/pg_rewind.c b/src/bin/pg_rewind/pg_rewind.c
index 2a18f675c8..fa78498117 100644
--- a/src/bin/pg_rewind/pg_rewind.c
+++ b/src/bin/pg_rewind/pg_rewind.c
@@ -3,6 +3,7 @@
  * pg_rewind.c
  *	  Synchronizes a PostgreSQL data directory to a new timeline
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  *
  *-------------------------------------------------------------------------
@@ -27,8 +28,10 @@
 #include "common/file_perm.h"
 #include "common/file_utils.h"
 #include "common/restricted_token.h"
+#include "fe_utils/encryption.h"
 #include "getopt_long.h"
 #include "storage/bufpage.h"
+#include "storage/encryption.h"
 
 static void usage(const char *progname);
 
@@ -75,6 +78,10 @@ usage(const char *progname)
 	printf(_("  -D, --target-pgdata=DIRECTORY  existing data directory to modify\n"));
 	printf(_("      --source-pgdata=DIRECTORY  source data directory to synchronize with\n"));
 	printf(_("      --source-server=CONNSTR    source server to synchronize with\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command=COMMAND\n"
+			 "                                 command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -n, --dry-run                  stop before modifying anything\n"));
 	printf(_("  -N, --no-sync                  do not wait for changes to be written\n"
 			 "                                 safely to disk\n"));
@@ -99,6 +106,9 @@ main(int argc, char **argv)
 		{"no-sync", no_argument, NULL, 'N'},
 		{"progress", no_argument, NULL, 'P'},
 		{"debug", no_argument, NULL, 3},
+#ifdef	USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#endif							/* USE_ENCRYPTION */
 		{NULL, 0, NULL, 0}
 	};
 	int			option_index;
@@ -135,7 +145,7 @@ main(int argc, char **argv)
 		}
 	}
 
-	while ((c = getopt_long(argc, argv, "D:nNP", long_options, &option_index)) != -1)
+	while ((c = getopt_long(argc, argv, "D:K:nNP", long_options, &option_index)) != -1)
 	{
 		switch (c)
 		{
@@ -170,6 +180,12 @@ main(int argc, char **argv)
 			case 2:				/* --source-server */
 				connstr_source = pg_strdup(optarg);
 				break;
+#ifdef	USE_ENCRYPTION
+			case 4:				/* --encryption-key-command */
+			case 'K':
+				encryption_key_command = strdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
 		}
 	}
 
@@ -248,6 +264,48 @@ main(int argc, char **argv)
 
 	sanityChecks();
 
+	/*
+	 * Setup encryption if it's obvious that we'll have to deal with encrypted
+	 * XLOG.
+	 */
+	if (ControlFile_target.data_cipher > PG_CIPHER_NONE)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * Try to retrieve the command from environment variable. We do this
+		 * primarily to make automated tests work for encrypted cluster w/o
+		 * changing the scripts. XXX Not sure the variable should be
+		 * documented. If we do, then pg_ctl should probably accept it too.
+		 */
+		if (encryption_key_command == NULL)
+		{
+			encryption_key_command = getenv("PGENCRKEYCMD");
+			if (encryption_key_command && strlen(encryption_key_command) == 0)
+				encryption_key_command = NULL;
+		}
+
+		if (encryption_key_command == NULL)
+		{
+			pg_log_error("-K option must be passed for encrypted cluster");
+			exit(EXIT_FAILURE);
+		}
+
+		/*
+		 * It should not matter whether we pass the source or target data
+		 * directory. It should have been checked earlier that both clusters
+		 * are encrypted using the same key.
+		 */
+		run_encryption_key_command(datadir_source);
+		setup_encryption();
+		data_encrypted = true;
+	}
+#else
+	{
+		pg_log_error(ENCRYPTION_NOT_SUPPORTED_MSG);
+		exit(EXIT_FAILURE);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/*
 	 * If both clusters are already on the same timeline, there's nothing to
 	 * do.
@@ -458,6 +516,24 @@ sanityChecks(void)
 		ControlFile_source.state != DB_SHUTDOWNED &&
 		ControlFile_source.state != DB_SHUTDOWNED_IN_RECOVERY)
 		pg_fatal("source data directory must be shut down cleanly");
+
+	/*
+	 * Since slave receives XLOG stream encrypted by master, handling
+	 * differently encrypted clusters is not the typical use case for
+	 * pg_rewind. Yet we should check the encryption.
+	 */
+	if (ControlFile_source.data_cipher > PG_CIPHER_NONE ||
+		ControlFile_target.data_cipher > PG_CIPHER_NONE)
+	{
+		if (ControlFile_source.data_cipher !=
+			ControlFile_target.data_cipher)
+			pg_fatal("source and target server must be both unencrypted or both encrypted\n");
+
+		if (memcmp(ControlFile_source.encryption_verification,
+				   ControlFile_target.encryption_verification,
+				   ENCRYPTION_SAMPLE_SIZE))
+			pg_fatal("both source and target server must use the same encryption key");
+	}
 }
 
 /*
diff --git a/src/bin/pg_upgrade/controldata.c b/src/bin/pg_upgrade/controldata.c
index 5953ef3b66..2c94a98786 100644
--- a/src/bin/pg_upgrade/controldata.c
+++ b/src/bin/pg_upgrade/controldata.c
@@ -3,6 +3,7 @@
  *
  *	controldata functions
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/controldata.c
  */
@@ -203,6 +204,8 @@ get_control_data(ClusterInfo *cluster, bool live_check)
 		got_data_checksum_version = true;
 	}
 
+	cluster->controldata.data_encrypted = false;
+
 	/* we have the result of cmd in "output". so parse it line by line now */
 	while (fgets(bufin, sizeof(bufin), output))
 	{
@@ -496,6 +499,34 @@ get_control_data(ClusterInfo *cluster, bool live_check)
 			cluster->controldata.data_checksum_version = str2uint(p);
 			got_data_checksum_version = true;
 		}
+		else if ((p = strstr(bufin, "encryption fingerprint")) != NULL)
+		{
+			int			i;
+			int	sample_int[ENCRYPTION_SAMPLE_SIZE];
+
+			cluster->controldata.data_encrypted = true;
+
+			p = strchr(p, ':');
+			if (p == NULL || strlen(p) <= 1)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+			p = strpbrk(p, "01234567890ABCDEF");
+			if (p == NULL || strlen(p) <= 1)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+
+			/* Make sure it looks like a valid finerprint */
+			if (strspn(p, "0123456789ABCDEF") != 32)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+
+			/*
+			 * See encryption_key_from_string() for explanation why %2hhx
+			 * conversion cannot be used here.
+			 */
+			for (i = 0; i < ENCRYPTION_SAMPLE_SIZE; i++)
+				sscanf(p + 2 * i, "%2x", sample_int + i);
+			for (i = 0; i < ENCRYPTION_SAMPLE_SIZE; i++)
+				cluster->controldata.encryption_verification[i] =
+					(char) sample_int[i];
+		}
 	}
 
 	pclose(output);
@@ -683,6 +714,18 @@ check_control_data(ControlData *oldctrl,
 		pg_fatal("old cluster uses data checksums but the new one does not\n");
 	else if (oldctrl->data_checksum_version != newctrl->data_checksum_version)
 		pg_fatal("old and new cluster pg_controldata checksum versions do not match\n");
+
+	if (oldctrl->data_encrypted && !newctrl->data_encrypted)
+		pg_fatal("old cluster is encrypted, but the new one is not\n");
+	else if (!oldctrl->data_encrypted && newctrl->data_encrypted)
+		pg_fatal("old cluster is not encrypted, upgrading to an encrypted cluster is not possible\n");
+	else if (oldctrl->data_encrypted)
+	{
+		if (memcmp(oldctrl->encryption_verification,
+				   newctrl->encryption_verification,
+				   ENCRYPTION_SAMPLE_SIZE) != 0)
+			pg_fatal("encryption of the new cluster is not compatible with encryption of the old one\n");
+	}
 }
 
 
diff --git a/src/bin/pg_upgrade/dump.c b/src/bin/pg_upgrade/dump.c
index 0ffe171a05..797d0a5618 100644
--- a/src/bin/pg_upgrade/dump.c
+++ b/src/bin/pg_upgrade/dump.c
@@ -3,6 +3,7 @@
  *
  *	dump functions
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/dump.c
  */
@@ -22,7 +23,7 @@ generate_old_dump(void)
 	prep_status("Creating dump of global objects");
 
 	/* run new pg_dumpall binary for globals */
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/pg_dumpall\" %s --globals-only --quote-all-identifiers "
 			  "--binary-upgrade %s -f %s",
 			  new_cluster.bindir, cluster_conn_opts(&old_cluster),
diff --git a/src/bin/pg_upgrade/exec.c b/src/bin/pg_upgrade/exec.c
index 087a80220d..0939dc52c7 100644
--- a/src/bin/pg_upgrade/exec.c
+++ b/src/bin/pg_upgrade/exec.c
@@ -3,6 +3,7 @@
  *
  *	execution functions
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/exec.c
  */
@@ -74,11 +75,15 @@ get_bin_version(ClusterInfo *cluster)
  * If the command fails, an error message is optionally written to the specified
  * log_file, and the program optionally exits.
  *
+ * If encryption_key is passed, popen() is used and the key is sent to stdin
+ * of the command.
+ *
  * The code requires it be called first from the primary thread on Windows.
  */
 bool
 exec_prog(const char *log_file, const char *opt_log_file,
-		  bool report_error, bool exit_on_error, const char *fmt,...)
+		  bool report_error, bool exit_on_error, unsigned char *encryption_key,
+		  const char *fmt,...)
 {
 	int			result = 0;
 	int			written;
@@ -170,7 +175,27 @@ exec_prog(const char *log_file, const char *opt_log_file,
 	/* see comment above */
 	if (mainThreadId == GetCurrentThreadId())
 #endif
-		result = system(cmd);
+	{
+		if (!encryption_key)
+			result = system(cmd);
+		else
+		{
+			FILE	*fp;
+			int	i;
+
+			fp = popen(cmd, "w");
+			if (fp == NULL)
+				pg_fatal("Failed to execute \"%s\"\n", cmd);
+
+			/* Send the key. */
+			for (i = 0; i < ENCRYPTION_KEY_LENGTH; i++)
+				fprintf(fp, "%.2x", encryption_key[i]);
+			fputc('\n', fp);
+
+			if (pclose(fp))
+				pg_fatal("\"%s\" returned non-zero code\n", cmd);
+		}
+	}
 
 	if (result != 0 && report_error)
 	{
diff --git a/src/bin/pg_upgrade/option.c b/src/bin/pg_upgrade/option.c
index a05675c6b8..d5da77876c 100644
--- a/src/bin/pg_upgrade/option.c
+++ b/src/bin/pg_upgrade/option.c
@@ -3,6 +3,7 @@
  *
  *	options functions
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/option.c
  */
@@ -56,6 +57,9 @@ parseCommandLine(int argc, char *argv[])
 		{"socketdir", required_argument, NULL, 's'},
 		{"verbose", no_argument, NULL, 'v'},
 		{"clone", no_argument, NULL, 1},
+#ifdef USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#endif	/* USE_ENCRYPTION */
 
 		{NULL, 0, NULL, 0}
 	};
@@ -101,7 +105,7 @@ parseCommandLine(int argc, char *argv[])
 	if (os_user_effective_id == 0)
 		pg_fatal("%s: cannot be run as root\n", os_info.progname);
 
-	while ((option = getopt_long(argc, argv, "d:D:b:B:cj:ko:O:p:P:rs:U:v",
+	while ((option = getopt_long(argc, argv, "d:D:b:B:cj:K:ko:O:p:P:rs:U:v",
 								 long_options, &optindex)) != -1)
 	{
 		switch (option)
@@ -209,6 +213,21 @@ parseCommandLine(int argc, char *argv[])
 				user_opts.transfer_mode = TRANSFER_MODE_CLONE;
 				break;
 
+#ifdef USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+
+				/*
+				 * If the command is a command line option, it probably means
+				 * that the clusters do not have it in postgresql.conf, and
+				 * therefore we must pass it to pg_ctl when starting them.
+				 */
+				snprintf(encryption_key_command_opt,
+						 strlen(encryption_key_command) + 7,
+						 " -K \"%s\"", encryption_key_command);
+				break;
+#endif	/* USE_ENCRYPTION */
+
 			default:
 				fprintf(stderr, _("Try \"%s --help\" for more information.\n"),
 						os_info.progname);
@@ -309,6 +328,9 @@ usage(void)
 	printf(_("  -v, --verbose                 enable verbose internal logging\n"));
 	printf(_("  -V, --version                 display version information, then exit\n"));
 	printf(_("  --clone                       clone instead of copying files to new cluster\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command  command that returns encryption key\n\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -?, --help                    show this help, then exit\n"));
 	printf(_("\n"
 			 "Before running pg_upgrade you must:\n"
diff --git a/src/bin/pg_upgrade/parallel.c b/src/bin/pg_upgrade/parallel.c
index 80ab1b8609..24d376a401 100644
--- a/src/bin/pg_upgrade/parallel.c
+++ b/src/bin/pg_upgrade/parallel.c
@@ -3,6 +3,7 @@
  *
  *	multi-process support
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/parallel.c
  */
@@ -79,7 +80,7 @@ parallel_exec_prog(const char *log_file, const char *opt_log_file,
 
 	if (user_opts.jobs <= 1)
 		/* exit_on_error must be true to allow jobs */
-		exec_prog(log_file, opt_log_file, true, true, "%s", cmd);
+		exec_prog(log_file, opt_log_file, true, true, NULL, "%s", cmd);
 	else
 	{
 		/* parallel */
@@ -122,7 +123,8 @@ parallel_exec_prog(const char *log_file, const char *opt_log_file,
 		child = fork();
 		if (child == 0)
 			/* use _exit to skip atexit() functions */
-			_exit(!exec_prog(log_file, opt_log_file, true, true, "%s", cmd));
+			_exit(!exec_prog(log_file, opt_log_file, true, true, NULL, "%s",
+							 cmd));
 		else if (child < 0)
 			/* fork failed */
 			pg_fatal("could not create worker process: %s\n", strerror(errno));
@@ -160,7 +162,7 @@ win32_exec_prog(exec_thread_arg *args)
 {
 	int			ret;
 
-	ret = !exec_prog(args->log_file, args->opt_log_file, true, true, "%s", args->cmd);
+	ret = !exec_prog(args->log_file, args->opt_log_file, true, true, NULL, "%s", args->cmd);
 
 	/* terminates thread */
 	return ret;
diff --git a/src/bin/pg_upgrade/pg_upgrade.c b/src/bin/pg_upgrade/pg_upgrade.c
index 3d7b21526b..7fcb88373c 100644
--- a/src/bin/pg_upgrade/pg_upgrade.c
+++ b/src/bin/pg_upgrade/pg_upgrade.c
@@ -3,6 +3,7 @@
  *
  *	main source file
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/pg_upgrade.c
  */
@@ -39,6 +40,7 @@
 
 #include "pg_upgrade.h"
 #include "catalog/pg_class_d.h"
+#include "common/encryption.h"
 #include "common/file_perm.h"
 #include "common/logging.h"
 #include "common/restricted_token.h"
@@ -48,6 +50,10 @@
 #include <langinfo.h>
 #endif
 
+#ifdef USE_ENCRYPTION
+static char *get_encryption_key_command(char *bindir, char *pgconfig);
+#endif	/* USE_ENCRYPTION */
+
 static void prepare_new_cluster(void);
 static void prepare_new_globals(void);
 static void create_new_objects(void);
@@ -71,6 +77,14 @@ char	   *output_files[] = {
 	NULL
 };
 
+char encryption_key_command_opt[MAXPGPATH];
+
+/*
+ * Declare these locally so we don't have to link storage/file/encryption.c
+ * here.
+ */
+bool		encryption_setup_done = false;
+extern unsigned char encryption_key[ENCRYPTION_KEY_LENGTH];
 
 int
 main(int argc, char **argv)
@@ -78,6 +92,9 @@ main(int argc, char **argv)
 	char	   *analyze_script_file_name = NULL;
 	char	   *deletion_script_file_name = NULL;
 	bool		live_check = false;
+#ifdef USE_ENCRYPTION
+	char	*key_cmd_pgconf;
+#endif
 
 	pg_logging_init(argv[0]);
 	set_pglocale_pgservice(argv[0], PG_TEXTDOMAIN("pg_upgrade"));
@@ -85,6 +102,7 @@ main(int argc, char **argv)
 	/* Set default restrictive mask until new cluster permissions are read */
 	umask(PG_MODE_MASK_OWNER);
 
+	encryption_key_command_opt[0] = '\0';
 	parseCommandLine(argc, argv);
 
 	get_restricted_token();
@@ -92,6 +110,61 @@ main(int argc, char **argv)
 	adjust_data_dir(&old_cluster);
 	adjust_data_dir(&new_cluster);
 
+#ifdef USE_ENCRYPTION
+	/* Try to get the encryption key command from postgresql.conf. */
+	key_cmd_pgconf = get_encryption_key_command(old_cluster.bindir,
+												old_cluster.pgconfig);
+	old_cluster.has_encr_key_cmd = key_cmd_pgconf != NULL;
+#endif
+
+	/*
+	 * Is the key passed as command line option?
+	 */
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		/* The command in postgresql.conf takes precedence. */
+		if (key_cmd_pgconf)
+		{
+			pg_log(PG_WARNING,
+				   "ignoring the -K option due to presence of encryption_key_command in configuration file\n");
+			encryption_key_command = key_cmd_pgconf;
+		}
+	}
+	else
+	{
+		/* Only specified in postgresql.conf, so use that value. */
+		encryption_key_command = key_cmd_pgconf;
+	}
+
+	/*
+	 * Setup the encryption if we have the command.
+	 *
+	 * Ideally we'd use get_control_data() to find out whether the encryption
+	 * is enabled, but that function assumes that postmaster lock file has
+	 * already been cleaned up.
+	 */
+	if (encryption_key_command)
+	{
+		/*
+		 * Both clusters should have the same KDF parameters, so we can pass
+		 * pgdata of any one.
+		 */
+		run_encryption_key_command(old_cluster.pgdata);
+		encryption_setup_done = true;
+	}
+
+	/* Check if the new cluster has the key command in postgresql.conf. */
+	key_cmd_pgconf = get_encryption_key_command(new_cluster.bindir,
+												new_cluster.pgconfig);
+	new_cluster.has_encr_key_cmd = key_cmd_pgconf != NULL;
+#else
+	{
+		/* User should not be able to pass the -K option. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	setup(argv[0], &live_check);
 
 	output_check_banner(live_check);
@@ -137,6 +210,23 @@ main(int argc, char **argv)
 
 	copy_xact_xlog_xid();
 
+	if (encryption_setup_done)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * Copy KDF file so that the old cluster encryption password works for
+		 * the new cluster.
+		 */
+		read_kdf_file(old_cluster.pgdata);
+		write_kdf_file(new_cluster.pgdata);
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/* New now using xids of the old system */
 
 	/* -- NEW -- */
@@ -168,13 +258,15 @@ main(int argc, char **argv)
 	 */
 	prep_status("Setting next OID for new cluster");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_setup_done ? encryption_key : NULL,
 			  "\"%s/pg_resetwal\" -o %u \"%s\"",
-			  new_cluster.bindir, old_cluster.controldata.chkpnt_nxtoid,
+			  new_cluster.bindir,
+			  old_cluster.controldata.chkpnt_nxtoid,
 			  new_cluster.pgdata);
 	check_ok();
 
 	prep_status("Sync data directory to disk");
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/initdb\" --sync-only \"%s\"", new_cluster.bindir,
 			  new_cluster.pgdata);
 	check_ok();
@@ -200,6 +292,44 @@ main(int argc, char **argv)
 	return 0;
 }
 
+#ifdef USE_ENCRYPTION
+/*
+ * Retrieve the value of encryption_key_command parameter from postgresql.conf
+ * and return it. Return NULL if the parameter is not set.
+ */
+static char *
+get_encryption_key_command(char	*bindir, char *pgconfig)
+{
+	char		cmd[MAXPGPATH],
+		cmd_output[MAX_STRING];
+	FILE *output = NULL;
+	char	*result = NULL;
+
+	/*
+	 * Retrieve the command from the old cluster: the command can reference
+	 * data directory because of the KDF file, but KDF files haven't yet been
+	 * synchronized.
+	 */
+	snprintf(cmd, sizeof(cmd), "\"%s/postgres\" -D \"%s\" -C encryption_key_command",
+			 bindir, pgconfig);
+
+	if ((output = popen(cmd, "r")) != NULL &&
+		fgets(cmd_output, sizeof(cmd_output), output) != NULL)
+	{
+		/* Remove trailing newline */
+		if (strchr(cmd_output, '\n') != NULL)
+			*strchr(cmd_output, '\n') = '\0';
+
+		if (strlen(cmd_output) > 0)
+			result = pg_strdup(cmd_output);
+	}
+
+	if (output && pclose(output) != 0)
+		pg_fatal("could not close pipe to \"%s\"", cmd);
+
+	return result;
+}
+#endif	/* USE_ENCRYPTION */
 
 static void
 setup(char *argv0, bool *live_check)
@@ -268,7 +398,7 @@ prepare_new_cluster(void)
 	 * --analyze so autovacuum doesn't update statistics later
 	 */
 	prep_status("Analyzing all rows in the new cluster");
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/vacuumdb\" %s --all --analyze %s",
 			  new_cluster.bindir, cluster_conn_opts(&new_cluster),
 			  log_opts.verbose ? "--verbose" : "");
@@ -281,7 +411,7 @@ prepare_new_cluster(void)
 	 * counter later.
 	 */
 	prep_status("Freezing all rows in the new cluster");
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/vacuumdb\" %s --all --freeze %s",
 			  new_cluster.bindir, cluster_conn_opts(&new_cluster),
 			  log_opts.verbose ? "--verbose" : "");
@@ -302,7 +432,7 @@ prepare_new_globals(void)
 	 */
 	prep_status("Restoring global objects in the new cluster");
 
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/psql\" " EXEC_PSQL_ARGS " %s -f \"%s\"",
 			  new_cluster.bindir, cluster_conn_opts(&new_cluster),
 			  GLOBALS_DUMP_FILE);
@@ -349,6 +479,7 @@ create_new_objects(void)
 				  NULL,
 				  true,
 				  true,
+				  NULL,
 				  "\"%s/pg_restore\" %s %s --exit-on-error --verbose "
 				  "--dbname postgres \"%s\"",
 				  new_cluster.bindir,
@@ -446,7 +577,7 @@ copy_subdir_files(const char *old_subdir, const char *new_subdir)
 
 	prep_status("Copying old %s to new server", old_subdir);
 
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 #ifndef WIN32
 			  "cp -Rf \"%s\" \"%s\"",
 #else
@@ -472,6 +603,7 @@ copy_xact_xlog_xid(void)
 
 	prep_status("Setting oldest XID for new cluster");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_setup_done ? encryption_key : NULL,
 			  "\"%s/pg_resetwal\" -f -u %u \"%s\"",
 			  new_cluster.bindir, old_cluster.controldata.chkpnt_oldstxid,
 			  new_cluster.pgdata);
@@ -480,15 +612,20 @@ copy_xact_xlog_xid(void)
 	/* set the next transaction id and epoch of the new cluster */
 	prep_status("Setting next transaction ID and epoch for new cluster");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_setup_done ? encryption_key : NULL,
 			  "\"%s/pg_resetwal\" -f -x %u \"%s\"",
-			  new_cluster.bindir, old_cluster.controldata.chkpnt_nxtxid,
+			  new_cluster.bindir,
+			  old_cluster.controldata.chkpnt_nxtxid,
 			  new_cluster.pgdata);
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_setup_done ? encryption_key : NULL,
 			  "\"%s/pg_resetwal\" -f -e %u \"%s\"",
-			  new_cluster.bindir, old_cluster.controldata.chkpnt_nxtepoch,
+			  new_cluster.bindir,
+			  old_cluster.controldata.chkpnt_nxtepoch,
 			  new_cluster.pgdata);
 	/* must reset commit timestamp limits also */
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_setup_done ? encryption_key : NULL,
 			  "\"%s/pg_resetwal\" -f -c %u,%u \"%s\"",
 			  new_cluster.bindir,
 			  old_cluster.controldata.chkpnt_nxtxid,
@@ -515,6 +652,7 @@ copy_xact_xlog_xid(void)
 		 * counters here and the oldest multi present on system.
 		 */
 		exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+				  encryption_setup_done ? encryption_key : NULL,
 				  "\"%s/pg_resetwal\" -O %u -m %u,%u \"%s\"",
 				  new_cluster.bindir,
 				  old_cluster.controldata.chkpnt_nxtmxoff,
@@ -543,6 +681,7 @@ copy_xact_xlog_xid(void)
 		 * next=MaxMultiXactId, but multixact.c can cope with that just fine.
 		 */
 		exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+				  encryption_setup_done ? encryption_key : NULL,
 				  "\"%s/pg_resetwal\" -m %u,%u \"%s\"",
 				  new_cluster.bindir,
 				  old_cluster.controldata.chkpnt_nxtmulti + 1,
@@ -554,6 +693,7 @@ copy_xact_xlog_xid(void)
 	/* now reset the wal archives in the new cluster */
 	prep_status("Resetting WAL archives");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_setup_done ? encryption_key : NULL,
 	/* use timeline 1 to match controldata and no WAL history file */
 			  "\"%s/pg_resetwal\" -l 00000001%s \"%s\"", new_cluster.bindir,
 			  old_cluster.controldata.nextxlogfile + 8,
diff --git a/src/bin/pg_upgrade/pg_upgrade.h b/src/bin/pg_upgrade/pg_upgrade.h
index eac16679d5..f643c91ce3 100644
--- a/src/bin/pg_upgrade/pg_upgrade.h
+++ b/src/bin/pg_upgrade/pg_upgrade.h
@@ -1,6 +1,7 @@
 /*
  *	pg_upgrade.h
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/pg_upgrade.h
  */
@@ -10,7 +11,9 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 
+#include "fe_utils/encryption.h"
 #include "libpq-fe.h"
+#include "storage/encryption.h"
 
 /* Use port in the private/dynamic port number range */
 #define DEF_PGUPORT			50432
@@ -228,6 +231,8 @@ typedef struct
 	bool		date_is_int;
 	bool		float8_pass_by_value;
 	uint32		data_checksum_version;
+	bool		data_encrypted;
+	uint8		encryption_verification[ENCRYPTION_SAMPLE_SIZE];
 } ControlData;
 
 /*
@@ -277,6 +282,8 @@ typedef struct
 	char		major_version_str[64];	/* string PG_VERSION of cluster */
 	uint32		bin_version;	/* version returned from pg_ctl */
 	const char *tablespace_suffix;	/* directory specification */
+	bool	has_encr_key_cmd;		/* is encryption key command in the config
+									 * file? */
 } ClusterInfo;
 
 
@@ -334,7 +341,7 @@ extern UserOpts user_opts;
 extern ClusterInfo old_cluster,
 			new_cluster;
 extern OSInfo os_info;
-
+extern char encryption_key_command_opt[];
 
 /* check.c */
 
@@ -368,7 +375,9 @@ void		generate_old_dump(void);
 #define EXEC_PSQL_ARGS "--echo-queries --set ON_ERROR_STOP=on --no-psqlrc --dbname=template1"
 
 bool		exec_prog(const char *log_file, const char *opt_log_file,
-					  bool report_error, bool exit_on_error, const char *fmt,...) pg_attribute_printf(5, 6);
+					  bool report_error, bool exit_on_error,
+					  unsigned char *encryption_key, const char *fmt,...)
+	pg_attribute_printf(6, 7);
 void		verify_directories(void);
 bool		pid_lock_file_exists(const char *datadir);
 
diff --git a/src/bin/pg_upgrade/server.c b/src/bin/pg_upgrade/server.c
index d7d36b2faa..40ba1f964c 100644
--- a/src/bin/pg_upgrade/server.c
+++ b/src/bin/pg_upgrade/server.c
@@ -3,6 +3,7 @@
  *
  *	database server functions
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/server.c
  */
@@ -200,9 +201,12 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 	PGconn	   *conn;
 	bool		pg_ctl_return = false;
 	char		socket_string[MAXPGPATH + 200];
+	char		encryption_key_port_opt[64];
 
 	static bool exit_hook_registered = false;
 
+	encryption_key_port_opt[0] = '\0';
+
 	if (!exit_hook_registered)
 	{
 		atexit(stop_postmaster_atexit);
@@ -245,8 +249,11 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 	 * vacuumdb --freeze actually freezes the tuples.
 	 */
 	snprintf(cmd, sizeof(cmd),
-			 "\"%s/pg_ctl\" -w -l \"%s\" -D \"%s\" -o \"-p %d%s%s %s%s\" start",
-			 cluster->bindir, SERVER_LOG_FILE, cluster->pgconfig, cluster->port,
+			 "\"%s/pg_ctl\"%s%s -w -l \"%s\" -D \"%s\" -o \"-p %d%s%s %s%s\" start",
+			 cluster->bindir,
+			 encryption_key_command_opt,
+			 encryption_key_port_opt,
+			 SERVER_LOG_FILE, cluster->pgconfig, cluster->port,
 			 (cluster->controldata.cat_ver >=
 			  BINARY_UPGRADE_SERVER_FLAG_CAT_VER) ? " -b" :
 			 " -c autovacuum=off -c autovacuum_freeze_max_age=2000000000",
@@ -254,6 +261,61 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 			 " -c synchronous_commit=off -c fsync=off -c full_page_writes=off -c vacuum_defer_cleanup_age=0" : "",
 			 cluster->pgopts ? cluster->pgopts : "", socket_string);
 
+	/*
+	 * If encryption key needs to be sent, run a separate process now and let
+	 * it send the key to the postmaster.  We cannot send the key later in the
+	 * current process because the exec_prog call below blocks until the
+	 * postmaster succeeds or fails to start (and it will definitely fail if
+	 * it receives no key).
+	 */
+	if (encryption_setup_done && !cluster->has_encr_key_cmd)
+#ifdef USE_ENCRYPTION
+	{
+		SendKeyArgs	sk_args;
+		char	port_str[6];
+#ifndef WIN32
+		pid_t sender;
+#else
+		HANDLE sender;
+#endif
+
+		snprintf(port_str, sizeof(port_str), "%d", cluster->port);
+
+		/* in child process */
+		sk_args.host = cluster->sockdir; /* If NULL, then libpq will use
+										  * its default. */
+		sk_args.port = port_str;
+		sk_args.encryption_key = encryption_key;
+		/* XXX Find out the postmaster PID ? */
+		sk_args.pm_pid = 0;
+		sk_args.error_msg = NULL;
+
+#ifndef WIN32
+		pg_log(PG_VERBOSE, "sending encryption key to postmaster\n");
+		sender = fork();
+		if (sender == 0)
+		{
+			send_key_to_postmaster(&sk_args);
+			if (sk_args.error_msg)
+				pg_fatal("%s", sk_args.error_msg);
+			exit(EXIT_SUCCESS);
+		}
+		else if (sender < 0)
+			pg_fatal("could not create key sender process");
+#else	/* WIN32 */
+		pg_log(PG_VERBOSE, "sending encryption key to postmaster\n");
+		sender = _beginthreadex(NULL, 0, (void *) send_key_to_postmaster, &sk_args, 0, NULL);
+		if (sender == 0)
+			pg_fatal("could not create background thread: %m");
+#endif	/* WIN32 */
+	}
+#else	/* USE_ENCRYPTION */
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/*
 	 * Don't throw an error right away, let connecting throw the error because
 	 * it might supply a reason for the failure.
@@ -263,7 +325,7 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 							  (strcmp(SERVER_LOG_FILE,
 									  SERVER_START_LOG_FILE) != 0) ?
 							  SERVER_LOG_FILE : NULL,
-							  report_and_exit_on_error, false,
+							  report_and_exit_on_error, false, NULL,
 							  "%s", cmd);
 
 	/* Did it fail and we are just testing if the server could be started? */
@@ -339,7 +401,7 @@ stop_postmaster(bool in_atexit)
 	else
 		return;					/* no cluster running */
 
-	exec_prog(SERVER_STOP_LOG_FILE, NULL, !in_atexit, !in_atexit,
+	exec_prog(SERVER_STOP_LOG_FILE, NULL, !in_atexit, !in_atexit, NULL,
 			  "\"%s/pg_ctl\" -w -D \"%s\" -o \"%s\" %s stop",
 			  cluster->bindir, cluster->pgconfig,
 			  cluster->pgopts ? cluster->pgopts : "",
diff --git a/src/bin/pg_waldump/.gitignore b/src/bin/pg_waldump/.gitignore
index 3be00a8b61..d04ac3ab9d 100644
--- a/src/bin/pg_waldump/.gitignore
+++ b/src/bin/pg_waldump/.gitignore
@@ -5,6 +5,7 @@
 /clogdesc.c
 /committsdesc.c
 /dbasedesc.c
+/encryption.c
 /genericdesc.c
 /gindesc.c
 /gistdesc.c
diff --git a/src/bin/pg_waldump/Makefile b/src/bin/pg_waldump/Makefile
index 135979cef3..9eb1c2f01d 100644
--- a/src/bin/pg_waldump/Makefile
+++ b/src/bin/pg_waldump/Makefile
@@ -7,10 +7,11 @@ subdir = src/bin/pg_waldump
 top_builddir = ../../..
 include $(top_builddir)/src/Makefile.global
 
-OBJS = pg_waldump.o compat.o xlogreader.o rmgrdesc.o \
+OBJS = pg_waldump.o compat.o xlogreader.o rmgrdesc.o encryption.o \
 	$(RMGRDESCOBJS) $(WIN32RES)
 
 override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 
 RMGRDESCSOURCES = $(sort $(notdir $(wildcard $(top_srcdir)/src/backend/access/rmgrdesc/*desc.c)))
 RMGRDESCOBJS = $(patsubst %.c,%.o,$(RMGRDESCSOURCES))
@@ -27,6 +28,9 @@ xlogreader.c: % : $(top_srcdir)/src/backend/access/transam/%
 $(RMGRDESCSOURCES): % : $(top_srcdir)/src/backend/access/rmgrdesc/%
 	rm -f $@ && $(LN_S) $< .
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) pg_waldump$(X) '$(DESTDIR)$(bindir)/pg_waldump$(X)'
 
@@ -37,7 +41,8 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/pg_waldump$(X)'
 
 clean distclean maintainer-clean:
-	rm -f pg_waldump$(X) $(OBJS) $(RMGRDESCSOURCES) xlogreader.c
+	rm -f pg_waldump$(X) $(OBJS) $(RMGRDESCSOURCES) xlogreader.c \
+encryption.c
 	rm -rf tmp_check
 
 check:
diff --git a/src/bin/pg_waldump/pg_waldump.c b/src/bin/pg_waldump/pg_waldump.c
index 5d7f52583b..ee9568548d 100644
--- a/src/bin/pg_waldump/pg_waldump.c
+++ b/src/bin/pg_waldump/pg_waldump.c
@@ -2,6 +2,7 @@
  *
  * pg_waldump.c - decode and display WAL
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Copyright (c) 2013-2019, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
@@ -22,6 +23,8 @@
 #include "access/transam.h"
 #include "common/fe_memutils.h"
 #include "common/logging.h"
+#include "fe_utils/encryption.h"
+#include "storage/encryption.h"
 #include "getopt_long.h"
 #include "rmgrdesc.h"
 
@@ -194,25 +197,60 @@ search_directory(const char *directory, const char *fname)
 		PGAlignedXLogBlock buf;
 		int			r;
 
-		r = read(fd, buf.data, XLOG_BLCKSZ);
-		if (r == XLOG_BLCKSZ)
+		if (data_encrypted)
 		{
-			XLogLongPageHeader longhdr = (XLogLongPageHeader) buf.data;
-
-			WalSegSz = longhdr->xlp_seg_size;
+			/*
+			 * Segment size affects calculation of segNo and thus also the
+			 * encryption tweak, so we cannot get the size from the header
+			 * until the page is decrypted. Here we need to take more
+			 * expensive approach and really check the file size.
+			 */
+			WalSegSz = (int) lseek(fd, 0, SEEK_END);
+			if (WalSegSz <= 0)
+				fatal_error("Could not determine size of WAL segment \"%s\"", fname);
 
+			/*
+			 * Verification of the file size is the only useful thing we can
+			 * do. If anything else is wrong, the XLOG reader should find out
+			 * after decryption.
+			 */
 			if (!IsValidWalSegSize(WalSegSz))
-				fatal_error(ngettext("WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d byte",
-									 "WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d bytes",
+				fatal_error(ngettext("WAL segment size must be a power of two between 1 MB and 1 GB, but size of the WAL file \"%s\" is %d byte",
+									 "WAL segment size must be a power of two between 1 MB and 1 GB, but size of the WAL file \"%s\" is %d bytes",
 									 WalSegSz),
 							fname, WalSegSz);
 		}
-		else if (r < 0)
-			fatal_error("could not read file \"%s\": %s",
-						fname, strerror(errno));
 		else
-			fatal_error("could not read file \"%s\": read %d of %zu",
-						fname, r, (Size) XLOG_BLCKSZ);
+		{
+			r = read(fd, buf.data, XLOG_BLCKSZ);
+			if (r == XLOG_BLCKSZ)
+			{
+				XLogLongPageHeader longhdr;
+
+				longhdr = (XLogLongPageHeader) buf.data;
+
+				if (longhdr->std.xlp_magic != XLOG_PAGE_MAGIC)
+					fatal_error(gettext("WAL segment \"%s\" has an incorrect magic number. If it's encrypted, use the -K option to pass encryption credentials"),
+								fname);
+
+				WalSegSz = longhdr->xlp_seg_size;
+
+				if (!IsValidWalSegSize(WalSegSz))
+					fatal_error(ngettext("WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d byte",
+										 "WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d bytes",
+										 WalSegSz),
+								fname, WalSegSz);
+			}
+			else
+			{
+				if (r < 0)
+					fatal_error("could not read file \"%s\": %s",
+								fname, strerror(errno));
+				else
+					fatal_error("could not read file \"%s\": read %d of %zu",
+								fname, r, (Size) XLOG_BLCKSZ);
+			}
+		}
 		close(fd);
 		return true;
 	}
@@ -441,6 +479,24 @@ XLogDumpReadPage(XLogReaderState *state, XLogRecPtr targetPagePtr, int reqLen,
 	XLogDumpXLogRead(private->inpath, private->timeline, targetPagePtr,
 					 readBuff, count);
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+		XLogSegNo	readSegNo;
+		uint32		readSegOff;
+
+		XLByteToSeg(targetPagePtr, readSegNo, WalSegSz);
+		readSegOff = targetPagePtr % WalSegSz;
+
+		XLogEncryptionTweak(tweak, private->timeline, readSegNo, readSegOff);
+		decrypt_block(readBuff,
+					  readBuff,
+					  count,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_PERMANENT);
+	}
+
 	return count;
 }
 
@@ -799,6 +855,10 @@ usage(void)
 	printf(_("  -b, --bkp-details      output detailed information about backup blocks\n"));
 	printf(_("  -e, --end=RECPTR       stop reading at WAL location RECPTR\n"));
 	printf(_("  -f, --follow           keep retrying after reaching end of WAL\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command=COMMAND\n"
+			 "                         command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -n, --limit=N          number of records to display\n"));
 	printf(_("  -p, --path=PATH        directory in which to find log segment files or a\n"
 			 "                         directory with a ./pg_wal that contains such files\n"
@@ -834,6 +894,7 @@ main(int argc, char **argv)
 		{"end", required_argument, NULL, 'e'},
 		{"follow", no_argument, NULL, 'f'},
 		{"help", no_argument, NULL, '?'},
+		{"encryption-key-command", required_argument, NULL, 'K'},
 		{"limit", required_argument, NULL, 'n'},
 		{"path", required_argument, NULL, 'p'},
 		{"rmgr", required_argument, NULL, 'r'},
@@ -891,7 +952,7 @@ main(int argc, char **argv)
 		goto bad_argument;
 	}
 
-	while ((option = getopt_long(argc, argv, "be:fn:p:r:s:t:x:z",
+	while ((option = getopt_long(argc, argv, "be:fK:n:p:r:s:t:x:z",
 								 long_options, &optindex)) != -1)
 	{
 		switch (option)
@@ -911,6 +972,12 @@ main(int argc, char **argv)
 			case 'f':
 				config.follow = true;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+				data_encrypted = true;
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'n':
 				if (sscanf(optarg, "%d", &config.stop_after_records) != 1)
 				{
@@ -1106,6 +1173,19 @@ main(int argc, char **argv)
 
 	/* done with argument parsing, do the actual work */
 
+	if (data_encrypted)
+#ifdef USE_ENCRYPTION
+	{
+		run_encryption_key_command(NULL);
+		setup_encryption();
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/* we have everything we need, start reading */
 	xlogreader_state = XLogReaderAllocate(WalSegSz, XLogDumpReadPage,
 										  &private);
diff --git a/src/common/Makefile b/src/common/Makefile
index 2f22b9b101..5a8c822190 100644
--- a/src/common/Makefile
+++ b/src/common/Makefile
@@ -46,7 +46,8 @@ LIBS += $(PTHREAD_LIBS)
 
 # If you add objects here, see also src/tools/msvc/Mkvcbuild.pm
 
-OBJS_COMMON = base64.o config_info.o controldata_utils.o d2s.o exec.o f2s.o \
+OBJS_COMMON = base64.o config_info.o controldata_utils.o d2s.o encryption.o \
+	exec.o f2s.o \
 	file_perm.o ip.o keywords.o kwlookup.o link-canary.o md5.o \
 	pg_lzcompress.o pgfnames.o psprintf.o relpath.o \
 	rmtree.o saslprep.o scram-common.o string.o unicode_norm.o \
diff --git a/src/common/encryption.c b/src/common/encryption.c
new file mode 100644
index 0000000000..d2b6ffa671
--- /dev/null
+++ b/src/common/encryption.c
@@ -0,0 +1,224 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.c
+ *	  Transparent Data Encryption specific code usable by both frontend and
+ *	  backend.
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ *
+ * IDENTIFICATION
+ *	  src/common/encryption.c
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef FRONTEND
+#include "postgres.h"
+#else
+#include "postgres_fe.h"
+#endif
+
+#include "common/encryption.h"
+#include "common/logging.h"
+
+#ifdef USE_ENCRYPTION
+#include <openssl/evp.h>
+#endif	/* USE_ENCRYPTION */
+
+unsigned char encryption_key[ENCRYPTION_KEY_LENGTH];
+
+char	   *encryption_key_command = NULL;
+
+/*
+ * Run the command that is supposed to generate encryption key and store it
+ * where encryption_key points to. If valid string is passed for data_dir,
+ * it's used to replace '%D' pattern in the command.
+ */
+void
+run_encryption_key_command(char *data_dir)
+{
+	FILE	   *fp;
+	int		dlen;
+	char	*cmd, *sp, *dp, *endp;
+
+	Assert(encryption_key_command != NULL &&
+		   strlen(encryption_key_command) > 0);
+
+	dlen = strlen(encryption_key_command);
+	if (data_dir)
+		dlen += strlen(data_dir);
+	/*
+	 * The terminating '\0'. XXX Is it worth subtracting 2 for the "%D"
+	 * part?
+	 */
+	dlen += 1;
+	cmd = palloc(dlen);
+
+	/*
+	 * Replace %D pattern in the command with the actual data directory path.
+	 */
+	dp = cmd;
+	endp = cmd + dlen - 1;
+	*endp = '\0';
+	for (sp = encryption_key_command; *sp; sp++)
+	{
+		if (*sp == '%')
+		{
+			if (sp[1] == 'D')
+			{
+				if (data_dir == NULL)
+				{
+#ifdef FRONTEND
+					pg_log_fatal("data directory is not known, %%D pattern cannot be replaced");
+					exit(EXIT_FAILURE);
+#else
+					ereport(FATAL,
+							(errmsg("data directory is not known, %%D pattern cannot be replaced")));
+#endif	/* FRONTEND */
+				}
+
+				sp++;
+				strlcpy(dp, data_dir, endp - dp);
+				make_native_path(dp);
+				dp += strlen(dp);
+			}
+			else if (dp < endp)
+				*dp++ = *sp;
+			else
+				break;
+		}
+		else
+		{
+			if (dp < endp)
+				*dp++ = *sp;
+			else
+				break;
+		}
+	}
+	*dp = '\0';
+
+	/* Do not print the command itself, in case it's just "echo <the key>" */
+#ifdef FRONTEND
+	pg_log_debug("executing encryption key command");
+#else
+	ereport(DEBUG1,
+			(errmsg("executing encryption key command")));
+#endif	/* FRONTEND */
+
+	fp = popen(cmd, "r");
+	if (fp == NULL)
+	{
+#ifdef FRONTEND
+		pg_log_fatal("could not execute \"%s\"", cmd);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("could not execute \"%s\"", cmd)));
+#endif	/* FRONTEND */
+	}
+
+	/* Read the key. */
+	read_encryption_key_f(fp, cmd);
+
+	if (pclose(fp) != 0)
+	{
+#ifdef FRONTEND
+		pg_log_fatal("could not close pipe to \"%s\"", cmd);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("could not close pipe to \"%s\"", cmd)));
+#endif	/* FRONTEND */
+	}
+	pfree(cmd);
+}
+
+/*
+ * Read the encryption key from a file stream.
+ */
+void
+read_encryption_key_f(FILE *f, char *command)
+{
+	char	   buf[ENCRYPTION_KEY_CHARS];
+	int		read_len, c;
+
+	read_len = 0;
+	while ((c = fgetc(f)) != EOF && c != '\n')
+	{
+		if (read_len >= ENCRYPTION_KEY_CHARS)
+		{
+#ifdef FRONTEND
+			pg_log_fatal("encryption key is too long, should be a %d character hex key", ENCRYPTION_KEY_CHARS);
+			exit(EXIT_FAILURE);
+#else
+			ereport(FATAL,
+					(errmsg("encryption key is too long, should be a %d character hex key", ENCRYPTION_KEY_CHARS)));
+#endif	/* FRONTEND */
+		}
+
+		buf[read_len++] = c;
+	}
+
+	if (c == EOF && read_len == 0)
+	{
+		char	src[MAXPGPATH];
+
+		if (command)
+			snprintf(src, MAXPGPATH, "command \"%s\"", command);
+		else
+			snprintf(src, MAXPGPATH, "stdin");
+
+#ifdef FRONTEND
+		pg_log_fatal("could not read encryption key from %s: %m", src);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("could not read encryption key from %s: %m",
+						src)));
+#endif	/* FRONTEND */
+	}
+
+	if (read_len < ENCRYPTION_KEY_CHARS)
+	{
+#ifdef FRONTEND
+		pg_log_fatal("encryption key is too short, should be a %d character hex key", ENCRYPTION_KEY_CHARS);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("encryption key is too short, should be a %d character hex key", ENCRYPTION_KEY_CHARS)));
+#endif	/* FRONTEND */
+	}
+
+	/* Turn the hexadecimal representation into an array of bytes. */
+	encryption_key_from_string(buf);
+}
+
+/*
+ * Use the input hexadecimal string to initialize the encryption_key variable.
+ */
+void
+encryption_key_from_string(char key_str[ENCRYPTION_KEY_CHARS])
+{
+	int	encr_key_int[ENCRYPTION_KEY_LENGTH];
+	int	i;
+
+	for (i = 0; i < ENCRYPTION_KEY_LENGTH; i++)
+	{
+		/*
+		 * The code would be simpler with %2hhx conversion, but it does not
+		 * seem to be well portable. At least mingw build on Windows
+		 * complains about it.
+		 */
+		if (sscanf(key_str + 2 * i, "%2x", encr_key_int + i) == 0)
+		{
+#ifdef FRONTEND
+			pg_log_fatal("the encryption key may only contain hexadecimal digits");
+			exit(EXIT_FAILURE);
+#else
+			ereport(FATAL,
+					(errmsg("the encryption key may only contain hexadecimal digits")));
+#endif	/* FRONTEND */
+		}
+	}
+	for (i = 0; i < ENCRYPTION_KEY_LENGTH; i++)
+		encryption_key[i] = (char) encr_key_int[i];
+}
diff --git a/src/common/string.c b/src/common/string.c
index b01a56ceaa..7ab08c2532 100644
--- a/src/common/string.c
+++ b/src/common/string.c
@@ -4,6 +4,7 @@
  *		string handling helpers
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -42,6 +43,45 @@ pg_str_endswith(const char *str, const char *end)
 	return strcmp(str, end) == 0;
 }
 
+/*
+ * Helper function to check if a page is completely empty.
+ *
+ * TODO Invent name that is more consistent with that of the other function(s)
+ * in this module.
+ */
+bool
+IsAllZero(const char *input, Size size)
+{
+	const char *pos = input;
+	const char *aligned_start = (char *) MAXALIGN64(input);
+	const char *end = input + size;
+
+	/* Check 1 byte at a time until pos is 8 byte aligned */
+	while (pos < aligned_start)
+		if (*pos++ != 0)
+			return false;
+
+	/*
+	 * Run 8 parallel 8 byte checks in one iteration. On 2016 hardware
+	 * slightly faster than 4 parallel checks.
+	 */
+	while (pos + 8 * sizeof(uint64) <= end)
+	{
+		uint64	   *p = (uint64 *) pos;
+
+		if ((p[0] | p[1] | p[2] | p[3] | p[4] | p[5] | p[6] | p[7]) != 0)
+			return false;
+		pos += 8 * sizeof(uint64);
+	}
+
+	/* Handle unaligned tail. */
+	while (pos < end)
+		if (*pos++ != 0)
+			return false;
+
+	return true;
+}
+
 
 /*
  * strtoint --- just like strtol, but returns int not long
diff --git a/src/fe_utils/Makefile b/src/fe_utils/Makefile
index 7d73800323..e264eda7e2 100644
--- a/src/fe_utils/Makefile
+++ b/src/fe_utils/Makefile
@@ -5,6 +5,7 @@
 # This makefile generates a static library, libpgfeutils.a,
 # for use by client applications
 #
+# Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
 # Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -19,7 +20,8 @@ include $(top_builddir)/src/Makefile.global
 
 override CPPFLAGS := -DFRONTEND -I$(libpq_srcdir) $(CPPFLAGS)
 
-OBJS = mbprint.o print.o psqlscan.o simple_list.o string_utils.o conditional.o
+OBJS = mbprint.o print.o psqlscan.o simple_list.o string_utils.o conditional.o \
+	encryption.o
 
 all: libpgfeutils.a
 
diff --git a/src/fe_utils/encryption.c b/src/fe_utils/encryption.c
new file mode 100644
index 0000000000..b4bff695e8
--- /dev/null
+++ b/src/fe_utils/encryption.c
@@ -0,0 +1,396 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.c
+ *	  Front-end code to handle keys for full cluster encryption. The actual
+ *	  encryption is not performed here.
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * IDENTIFICATION
+ *	  src/fe_utils/encryption.c
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+
+#include "postgres_fe.h"
+
+#include "common/fe_memutils.h"
+#include "common/file_perm.h"
+#include "common/logging.h"
+#include "fe_utils/encryption.h"
+#include "libpq-fe.h"
+#include "libpq/pqcomm.h"
+
+#ifdef USE_ENCRYPTION
+#include <openssl/evp.h>
+
+/*
+ * Key derivation function.
+ */
+typedef enum KDFKind
+{
+	KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA = 0
+} KFDKind;
+
+typedef struct KDFParamsPBKDF2
+{
+	unsigned long int niter;
+	unsigned char salt[ENCRYPTION_KDF_SALT_LEN];
+} KDFParamsPBKDF2;
+
+/*
+ * Parameters of the key derivation function.
+ *
+ * The parameters are generated by initdb and stored into a file, which is
+ * then read during PG startup. This is similar to storing various settings in
+ * pg_control. However an existing KDF file is read only, so it does not have
+ * to be stored in shared memory.
+ */
+typedef struct KDFParamsData
+{
+	KFDKind		function;
+
+	/*
+	 * Function-specific parameters.
+	 */
+	union
+	{
+		KDFParamsPBKDF2 pbkdf2;
+	}			data;
+
+	/* CRC of all above ... MUST BE LAST! */
+	pg_crc32c	crc;
+} KDFParamsData;
+
+extern KDFParamsData *KDFParams;
+
+/*
+ * Pointer to the KDF parameters.
+ */
+KDFParamsData *KDFParams = NULL;
+
+/* Initialize KDF file. */
+void
+init_kdf(void)
+{
+	KDFParamsPBKDF2 *params;
+	struct timeval tv;
+	uint64	salt;
+
+	/*
+	 * The initialization should not be repeated.
+	 */
+	Assert(KDFParams == NULL);
+
+	KDFParams = palloc0(KDF_PARAMS_FILE_SIZE);
+	KDFParams->function = KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA;
+	params = &KDFParams->data.pbkdf2;
+
+	/*
+	 * Currently we derive the salt in the same way as system identifier,
+	 * however these two values are not supposed to match. XXX Is it worth the
+	 * effort if initdb derives the system identifier, passes it to this
+	 * function and also sends it to the bootstrap process? Not sure.
+	 */
+	gettimeofday(&tv, NULL);
+	salt = ((uint64) tv.tv_sec) << 32;
+	salt |= ((uint64) tv.tv_usec) << 12;
+	salt |= getpid() & 0xFFF;
+
+	memcpy(params->salt, &salt, sizeof(uint64));
+	params->niter = ENCRYPTION_KDF_NITER;
+}
+
+/*
+ * Write KDFParamsData to file.
+ */
+void
+write_kdf_file(char *dir)
+{
+	char		path[MAXPGPATH];
+	int			fd;
+
+	Assert(KDFParams != NULL);
+
+	/* Account for both file separator and terminating NULL character. */
+	if ((strlen(dir) + 1 + strlen(KDF_PARAMS_FILE) + 1) > MAXPGPATH)
+	{
+		pg_log_fatal("KDF directory is too long");
+		exit(EXIT_FAILURE);
+	}
+
+	snprintf(path, MAXPGPATH, "%s/%s", dir, KDF_PARAMS_FILE);
+
+	/* Contents are protected with a CRC */
+	INIT_CRC32C(KDFParams->crc);
+	COMP_CRC32C(KDFParams->crc,
+				(char *) KDFParams,
+				offsetof(KDFParamsData, crc));
+	FIN_CRC32C(KDFParams->crc);
+
+	fd = open(path, O_WRONLY | O_CREAT | PG_BINARY,
+			  pg_file_create_mode);
+	if (fd < 0)
+	{
+		pg_log_fatal("could not create key derivation file \"%s\": %m", path);
+		exit(EXIT_FAILURE);
+	}
+
+	if (write(fd, KDFParams, KDF_PARAMS_FILE_SIZE) != KDF_PARAMS_FILE_SIZE)
+	{
+		/* if write didn't set errno, assume problem is no disk space */
+		if (errno == 0)
+			errno = ENOSPC;
+		pg_log_fatal("could not write to key derivation file \"%s\": %m",
+					 path);
+		exit(EXIT_FAILURE);
+	}
+
+	if (close(fd))
+	{
+		pg_log_fatal("could not close key setup file: %m");
+		exit(EXIT_FAILURE);
+	}
+}
+
+/*
+ * Read KDFParamsData from file and store it in local memory.
+ *
+ * If dir is NULL, assume we're in the data directory.
+ *
+ * postmaster should call the function early enough for any other process to
+ * inherit valid pointer to the data.
+ */
+void
+read_kdf_file(char *dir)
+{
+	pg_crc32c	crc;
+	char		path[MAXPGPATH];
+	int			fd;
+
+	/* Account for both file separator and terminating NULL character. */
+	if ((strlen(dir) + 1 + strlen(KDF_PARAMS_FILE) + 1) > MAXPGPATH)
+	{
+		pg_log_fatal("KDF directory is too long");
+		exit(EXIT_FAILURE);
+	}
+
+	snprintf(path, MAXPGPATH, "%s/%s", dir, KDF_PARAMS_FILE);
+
+	KDFParams = palloc0(KDF_PARAMS_FILE_SIZE);
+	fd = open(path, O_RDONLY | PG_BINARY, S_IRUSR);
+
+	if (fd < 0)
+	{
+		pg_log_fatal("could not open key setup file \"%s\": %m", path);
+		exit(EXIT_FAILURE);
+	}
+
+	if (read(fd, KDFParams, sizeof(KDFParamsData)) != sizeof(KDFParamsData))
+	{
+		pg_log_fatal("could not read from key setup file \"%s\": %m", path);
+		exit(EXIT_FAILURE);
+	}
+
+	close(fd);
+
+	/* Now check the CRC. */
+	INIT_CRC32C(crc);
+	COMP_CRC32C(crc,
+				(char *) KDFParams,
+				offsetof(KDFParamsData, crc));
+	FIN_CRC32C(crc);
+
+	if (!EQ_CRC32C(crc, KDFParams->crc))
+	{
+		pg_log_fatal("incorrect checksum in key setup file \"%s\"", path);
+		exit(EXIT_FAILURE);
+	}
+
+
+	if (KDFParams->function != KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA)
+	{
+		pg_log_fatal("unsupported KDF function");
+		exit(EXIT_FAILURE);
+	}
+}
+
+/*
+ * Run the key derivation function and initialize encryption_key variable.
+ */
+void
+derive_key_from_password(unsigned char *encryption_key, const char *password,
+						 int len)
+{
+	KDFParamsPBKDF2 *params;
+	int			rc;
+
+	params = &KDFParams->data.pbkdf2;
+	rc = PKCS5_PBKDF2_HMAC(password,
+						   len,
+						   params->salt,
+						   ENCRYPTION_KDF_SALT_LEN,
+						   params->niter,
+						   EVP_sha1(),
+						   ENCRYPTION_KEY_LENGTH,
+						   encryption_key);
+
+	if (rc != 1)
+	{
+		pg_log_fatal("failed to derive key from password");
+		exit(EXIT_FAILURE);
+	}
+}
+
+/*
+ * Send the contents of encryption_key in the form of special startup packet
+ * to a server that is being started.
+ *
+ * Returns true if we could send the message and false if not, however even
+ * success does not guarantee that server started up - caller should
+ * eventually test server connection himself. On failure, save pointer to
+ * error message into args->error_msg.
+ */
+bool
+send_key_to_postmaster(SendKeyArgs *args)
+{
+	const char **keywords = pg_malloc0(3 * sizeof(*keywords));
+	const char **values = pg_malloc0(3 * sizeof(*values));
+	int	i;
+	PGconn *conn = NULL;
+	EncryptionKeyMsg	message;
+	int	msg_size;
+
+/* How many seconds we can wait for the postmaster to receive the key. */
+#define SEND_ENCRYPT_KEY_TIMEOUT	60
+
+	if (args->host)
+	{
+		keywords[0] = "host";
+		values[0] = args->host;
+	}
+	if (args->port)
+	{
+		keywords[1] = "port";
+		values[1] = args->port;
+	}
+
+	/* Compose the message. */
+	message.encryptionKeyCode = pg_hton32(ENCRYPTION_KEY_MSG_CODE);
+	message.version = 1;
+	if (args->encryption_key)
+	{
+		memcpy(message.data, args->encryption_key, ENCRYPTION_KEY_LENGTH);
+		message.empty = false;
+	}
+	else
+		message.empty = true;
+	msg_size = offsetof(EncryptionKeyMsg, data) + ENCRYPTION_KEY_LENGTH;
+
+	for (i = 0; i < SEND_ENCRYPT_KEY_TIMEOUT + 1; i++)
+	{
+		char	sslmode;
+
+		if (i > 0)
+			/* Sleep for 1 second. */
+			pg_usleep(1000000L);
+
+		/* Has the postmaster crashed? */
+		if (args->pm_pid != 0)
+		{
+#ifndef WIN32
+			int			exitstatus;
+
+			if (waitpid((pid_t) args->pm_pid, &exitstatus, WNOHANG) ==
+				(pid_t) args->pm_pid)
+			{
+				args->pm_exited = true;
+				return false;
+			}
+#else
+			if (WaitForSingleObject(args->pmProcess, 0) == WAIT_OBJECT_0)
+			{
+				args->pm_exited = true;
+				return false;
+			}
+#endif
+		}
+
+		if (conn)
+		{
+			PQfinish(conn);
+			conn = NULL;
+		}
+
+		/*
+		 * Although we don't expect the server to accept regular libpq
+		 * messages at the moment, try to get at least a valid socket.
+		 */
+		conn = PQconnectStartParams(keywords, values, false);
+		if (conn == NULL)
+			continue;
+
+		if (PQstatus(conn) != CONNECTION_STARTED &&
+			PQstatus(conn) != CONNECTION_MADE)
+		{
+			char	*msg = PQerrorMessage(conn);
+
+			if (msg && strlen(msg) > 0)
+				args->error_msg = pstrdup(msg);
+
+			continue;
+		}
+
+		/*
+		 * Unless we're sending the key via unix socket, take SSL mode into
+		 * account ('d' ~ "disable", 'a' ~ "allow", 'p' ~ "prefer"). "allow"
+		 * and "prefer" modes are not useful in terms of security, and
+		 * especially "allow" would be much trickier for
+		 * PQconnectSSLHandshake() to handle.
+		 */
+		sslmode = PQconnectionSSLMode(conn);
+		if (sslmode != 'd' && sslmode != 'a' && sslmode != 'p' &&
+			!PQconnectedToSocket(conn))
+		{
+			if (!PQconnectSSLHandshake(conn))
+			{
+				char	*msg = PQerrorMessage(conn);
+
+				if (msg && strlen(msg) > 0)
+					args->error_msg = pstrdup(msg);
+
+				/*
+				 * If the socket could be opened but SSL is not available, the
+				 * next try probably won't help.
+				 */
+				PQfinish(conn);
+				return false;
+			}
+		}
+
+		/* Send the packet. */
+		if (!PQpacketSend(conn, (char *) &message, msg_size))
+		{
+			args->error_msg = pstrdup(PQerrorMessage(conn));
+			return false;
+		}
+
+		/* Success */
+		break;
+	}
+
+	pg_free(keywords);
+	pg_free(values);
+	if (conn)
+		PQfinish(conn);
+
+	return true;
+}
+#endif	/* USE_ENCRYPTION */
diff --git a/src/include/access/visibilitymap.h b/src/include/access/visibilitymap.h
index 2d8804351a..c2ec50ab46 100644
--- a/src/include/access/visibilitymap.h
+++ b/src/include/access/visibilitymap.h
@@ -44,6 +44,7 @@ extern void visibilitymap_set(Relation rel, BlockNumber heapBlk, Buffer heapBuf,
 							  uint8 flags);
 extern uint8 visibilitymap_get_status(Relation rel, BlockNumber heapBlk, Buffer *vmbuf);
 extern void visibilitymap_count(Relation rel, BlockNumber *all_visible, BlockNumber *all_frozen);
-extern void visibilitymap_truncate(Relation rel, BlockNumber nheapblocks);
+extern void visibilitymap_truncate(Relation rel, BlockNumber nheapblocks,
+								   XLogRecPtr recptr);
 
 #endif							/* VISIBILITYMAP_H */
diff --git a/src/include/access/xlog.h b/src/include/access/xlog.h
index 0bed7e337c..95d5b65a96 100644
--- a/src/include/access/xlog.h
+++ b/src/include/access/xlog.h
@@ -3,6 +3,7 @@
  *
  * PostgreSQL write-ahead log manager
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -19,6 +20,7 @@
 #include "lib/stringinfo.h"
 #include "nodes/pg_list.h"
 #include "storage/fd.h"
+#include "storage/encryption.h"
 
 
 /* Sync methods */
@@ -194,8 +196,9 @@ extern PGDLLIMPORT int wal_level;
  * Normally, we don't WAL-log hint bit updates, but if checksums are enabled,
  * we have to protect them against torn page writes.  When you only set
  * individual bits on a page, it's still consistent no matter what combination
- * of the bits make it to disk, but the checksum wouldn't match.  Also WAL-log
- * them if forced by wal_log_hints=on.
+ * of the bits make it to disk, but the checksum wouldn't match.
+ *
+ * Also WAL-log the hint bits if forced by wal_log_hints=on.
  */
 #define XLogHintBitIsNeeded() (DataChecksumsEnabled() || wal_log_hints)
 
diff --git a/src/include/access/xloginsert.h b/src/include/access/xloginsert.h
index df24089ea4..9914ec42c9 100644
--- a/src/include/access/xloginsert.h
+++ b/src/include/access/xloginsert.h
@@ -57,6 +57,8 @@ extern XLogRecPtr log_newpage(RelFileNode *rnode, ForkNumber forkNum,
 extern XLogRecPtr log_newpage_buffer(Buffer buffer, bool page_std);
 extern void log_newpage_range(Relation rel, ForkNumber forkNum,
 							  BlockNumber startblk, BlockNumber endblk, bool page_std);
+extern void newpage_range_set_lsn(Relation rel, BlockNumber startblk,
+								  BlockNumber endblk);
 extern XLogRecPtr XLogSaveBufferForHint(Buffer buffer, bool buffer_std);
 
 extern void InitXLogInsert(void);
diff --git a/src/include/catalog/pg_control.h b/src/include/catalog/pg_control.h
index 874ef7b387..4fca5b46bd 100644
--- a/src/include/catalog/pg_control.h
+++ b/src/include/catalog/pg_control.h
@@ -5,6 +5,7 @@
  *	  However, we define it here so that the format is documented.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -19,6 +20,7 @@
 #include "access/xlogdefs.h"
 #include "pgtime.h"				/* for pg_time_t */
 #include "port/pg_crc32c.h"
+#include "storage/encryption.h"
 
 
 /* Version identifier for this pg_control format */
@@ -230,6 +232,16 @@ typedef struct ControlFileData
 	 */
 	char		mock_authentication_nonce[MOCK_AUTH_NONCE_LEN];
 
+	/*
+	 * Cipher used to encrypt data. Zero if unencrypted.
+	 *
+	 * The data type is actually CipherKind, but we don't want to include
+	 * encryption.h just because of this field.
+	 */
+	uint8		data_cipher;
+	/* Sample value for encryption key verification */
+	uint8		encryption_verification[ENCRYPTION_SAMPLE_SIZE];
+
 	/* CRC of all above ... MUST BE LAST! */
 	pg_crc32c	crc;
 } ControlFileData;
diff --git a/src/include/common/encryption.h b/src/include/common/encryption.h
new file mode 100644
index 0000000000..ecc6b65069
--- /dev/null
+++ b/src/include/common/encryption.h
@@ -0,0 +1,77 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.h
+ *	  Transparent Data Encryption specific code usable by both frontend and
+ *	  backend.
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ *
+ * IDENTIFICATION
+ *	  src/include/common/encryption.c
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef COMMON_ENCRYPTION_H
+#define COMMON_ENCRYPTION_H
+
+#include "port/pg_crc32c.h"
+
+/*
+ * Full database encryption key.
+ *
+ * We use 128-bits key for both AES-CTR and AES-CBC.
+ */
+#define	ENCRYPTION_KEY_LENGTH	16
+/* Key length in characters (two characters per hexadecimal digit) */
+#define ENCRYPTION_KEY_CHARS	(ENCRYPTION_KEY_LENGTH * 2)
+
+#define KDF_PARAMS_FILE			"global/kdf_params"
+#define KDF_PARAMS_FILE_SIZE	512
+
+#define ENCRYPTION_KDF_NITER		1048576
+#define	ENCRYPTION_KDF_SALT_LEN		sizeof(uint64)
+
+/*
+ * Common error message issued when particular code path cannot be executed
+ * due to absence of the OpenSSL library.
+ */
+#define ENCRYPTION_NOT_SUPPORTED_MSG \
+	"compile postgres with --with-openssl to use encryption."
+
+/*
+ * Cipher used to encrypt data. This value is stored in the control file.
+ *
+ * Due to very specific requirements, the ciphers are not likely to change,
+ * but we should be somewhat flexible.
+ *
+ * XXX If we have more than one cipher someday, have pg_controldata report the
+ * cipher kind (in textual form) instead of merely saying "on".
+ */
+typedef enum CipherKind
+{
+	/* The cluster is not encrypted. */
+	PG_CIPHER_NONE = 0,
+
+	/*
+	 * AES (Rijndael) in CTR mode of operation, key length 128 bits.
+	 *
+	 * The fact that buffile.c uses AES-CBC is not important here because
+	 * neither temporary files nor serialized data changes
+	 * (ReorderBufferSerializeTXN) can survive cluster restart.
+	 */
+	PG_CIPHER_AES_CTR_128
+}			CipherKind;
+
+/* Executable to retrieve the encryption key. */
+extern char *encryption_key_command;
+
+/*
+ * Key to encrypt / decrypt permanent data using AES-CTR cipher or any data
+ * using AES-CBC cipher.
+ */
+extern unsigned char encryption_key[];
+
+extern void run_encryption_key_command(char *data_dir);
+extern void read_encryption_key_f(FILE *f, char *command);
+extern void encryption_key_from_string(char key_str[ENCRYPTION_KEY_CHARS]);
+#endif /* COMMON_ENCRYPTION_H */
diff --git a/src/include/common/string.h b/src/include/common/string.h
index 77f31337ca..6128d81b8c 100644
--- a/src/include/common/string.h
+++ b/src/include/common/string.h
@@ -14,5 +14,6 @@ extern bool pg_str_endswith(const char *str, const char *end);
 extern int	strtoint(const char *pg_restrict str, char **pg_restrict endptr,
 					 int base);
 extern void pg_clean_ascii(char *str);
+extern bool IsAllZero(const char *input, Size size);
 
 #endif							/* COMMON_STRING_H */
diff --git a/src/include/fe_utils/encryption.h b/src/include/fe_utils/encryption.h
new file mode 100644
index 0000000000..a363cd782f
--- /dev/null
+++ b/src/include/fe_utils/encryption.h
@@ -0,0 +1,53 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.h
+ *	  Client code to support full cluster encryption.
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * IDENTIFICATION
+ *	  src/include/fe_utils/encryption.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#include "common/encryption.h"
+
+extern void init_kdf(void);
+extern void write_kdf_file(char *dir);
+extern void read_kdf_file(char *dir);
+extern void derive_key_from_password(unsigned char *encryption_key,
+									 const char *password, int len);
+
+/*
+ * Arguments for send_key_to_postmaster().
+ *
+ * If host or port are NULL, we expect libpq to use its defaults.
+ *
+ * If encryption_key is NULL, send an "empty message". This tells postmaster
+ * that the client (typically pg_ctl) has no key, so postmaster should stop
+ * waiting for it and try to get the key elsewhere.
+ *
+ * If error occurs, the appropriate message is stored in error_msg.
+ */
+typedef struct SendKeyArgs
+{
+	char	*host;
+	char	*port;
+	const unsigned char *encryption_key;
+
+	long pm_pid;
+	bool	pm_exited;
+#ifdef WIN32
+	/*
+	 * Set this *in addition to* pm_pid, otherwise it's hard to tell whether
+	 * the handle is valid.
+	 */
+	HANDLE	pmProcess;
+#endif
+
+	char *error_msg;
+} SendKeyArgs;
+
+extern bool send_key_to_postmaster(SendKeyArgs *args);
diff --git a/src/include/libpq/pqcomm.h b/src/include/libpq/pqcomm.h
index baf6a4b6c0..759192d254 100644
--- a/src/include/libpq/pqcomm.h
+++ b/src/include/libpq/pqcomm.h
@@ -6,6 +6,7 @@
  * NOTE: for historical reasons, this does not correspond to pqcomm.c.
  * pqcomm.c's routines are declared in libpq.h.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -23,6 +24,8 @@
 #endif
 #include <netinet/in.h>
 
+#include "common/encryption.h"
+
 #ifdef HAVE_STRUCT_SOCKADDR_STORAGE
 
 #ifndef HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
@@ -205,4 +208,27 @@ typedef struct CancelRequestPacket
 #define NEGOTIATE_SSL_CODE PG_PROTOCOL(1234,5679)
 #define NEGOTIATE_GSS_CODE PG_PROTOCOL(1234,5680)
 
+/* Client can also send cluster encryption key to the postmaster. */
+#define ENCRYPTION_KEY_MSG_CODE PG_PROTOCOL(1234,5681)
+
+/*
+ * Message containing the encryption key, received by postmaster during
+ * startup.
+ *
+ * TODO Consider adding extension identifier and key_length field so that
+ * postmaster can also receive extension-specific keys. Extension that needs a
+ * key would call a function from _PG_init() that tells postmaster where to
+ * store the key and how long the key is. (Should also postgres in standalone
+ * mode accept keys for extensions?)
+ */
+typedef struct EncryptionKeyMsg
+{
+	/* Note this integer field is stored in network byte order! */
+	MsgType		encryptionKeyCode;	/* code to identify a key message */
+
+	bool	empty;	 /* doesn't this message contain any key? */
+	unsigned char	version;	/* message format version. */
+	char	data[ENCRYPTION_KEY_LENGTH];	/* the key itself. */
+} EncryptionKeyMsg;
+
 #endif							/* PQCOMM_H */
diff --git a/src/include/nodes/replnodes.h b/src/include/nodes/replnodes.h
index 1e3ed4e19f..b18a747948 100644
--- a/src/include/nodes/replnodes.h
+++ b/src/include/nodes/replnodes.h
@@ -4,6 +4,7 @@
  *	  definitions for replication grammar parse nodes
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -84,6 +85,7 @@ typedef struct StartReplicationCmd
 	TimeLineID	timeline;
 	XLogRecPtr	startpoint;
 	List	   *options;
+	bool	decrypt;
 } StartReplicationCmd;
 
 
diff --git a/src/include/pg_config_manual.h b/src/include/pg_config_manual.h
index 743401cb96..1934513eb7 100644
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -6,6 +6,7 @@
  * for developers.  If you edit any of these, be sure to do a *full*
  * rebuild (and an initdb if noted).
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -171,6 +172,13 @@
 #define USE_SSL
 #endif
 
+/*
+ * OpenSSL is currently the only implementation of encryption we use.
+ */
+#ifdef USE_OPENSSL
+#define USE_ENCRYPTION
+#endif
+
 /*
  * This is the default directory in which AF_UNIX socket files are
  * placed.  Caution: changing this risks breaking your existing client
diff --git a/src/include/pgstat.h b/src/include/pgstat.h
index a044d83ed0..4f0ec34cd8 100644
--- a/src/include/pgstat.h
+++ b/src/include/pgstat.h
@@ -3,6 +3,7 @@
  *
  *	Definitions for the PostgreSQL statistics collector daemon.
  *
+ *	Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  *	Copyright (c) 2001-2019, PostgreSQL Global Development Group
  *
  *	src/include/pgstat.h
@@ -913,8 +914,6 @@ typedef enum
 	WAIT_EVENT_RELATION_MAP_READ,
 	WAIT_EVENT_RELATION_MAP_SYNC,
 	WAIT_EVENT_RELATION_MAP_WRITE,
-	WAIT_EVENT_REORDER_BUFFER_READ,
-	WAIT_EVENT_REORDER_BUFFER_WRITE,
 	WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ,
 	WAIT_EVENT_REPLICATION_SLOT_READ,
 	WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC,
diff --git a/src/include/replication/reorderbuffer.h b/src/include/replication/reorderbuffer.h
index bc97b08a90..05e42f9b1d 100644
--- a/src/include/replication/reorderbuffer.h
+++ b/src/include/replication/reorderbuffer.h
@@ -2,6 +2,7 @@
  * reorderbuffer.h
  *	  PostgreSQL logical replay/reorder buffer management.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Copyright (c) 2012-2019, PostgreSQL Global Development Group
  *
  * src/include/replication/reorderbuffer.h
@@ -384,10 +385,6 @@ struct ReorderBuffer
 	MemoryContext tup_context;
 
 	XLogRecPtr	current_restart_decoding_lsn;
-
-	/* buffer for disk<->memory conversions */
-	char	   *outbuf;
-	Size		outbufsize;
 };
 
 
diff --git a/src/include/replication/walreceiver.h b/src/include/replication/walreceiver.h
index 86a8130051..77894f9eaa 100644
--- a/src/include/replication/walreceiver.h
+++ b/src/include/replication/walreceiver.h
@@ -3,6 +3,7 @@
  * walreceiver.h
  *	  Exports from replication/walreceiverfuncs.c.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 2010-2019, PostgreSQL Global Development Group
  *
  * src/include/replication/walreceiver.h
@@ -158,6 +159,7 @@ typedef struct
 		struct
 		{
 			TimeLineID	startpointTLI;	/* Starting timeline */
+			bool	decrypt;			/* Decrypt the stream? */
 		}			physical;
 		struct
 		{
diff --git a/src/include/storage/buf_internals.h b/src/include/storage/buf_internals.h
index 487a1a6828..9e641edfda 100644
--- a/src/include/storage/buf_internals.h
+++ b/src/include/storage/buf_internals.h
@@ -332,7 +332,7 @@ extern void LocalPrefetchBuffer(SMgrRelation smgr, ForkNumber forkNum,
 								BlockNumber blockNum);
 extern BufferDesc *LocalBufferAlloc(SMgrRelation smgr, ForkNumber forkNum,
 									BlockNumber blockNum, bool *foundPtr);
-extern void MarkLocalBufferDirty(Buffer buffer);
+extern void MarkLocalBufferDirty(Buffer buffer, bool set_lsn);
 extern void DropRelFileNodeLocalBuffers(RelFileNode rnode, ForkNumber forkNum,
 										BlockNumber firstDelBlock);
 extern void DropRelFileNodeAllLocalBuffers(RelFileNode rnode);
diff --git a/src/include/storage/buffile.h b/src/include/storage/buffile.h
index 1fba404fe2..6b43c5624e 100644
--- a/src/include/storage/buffile.h
+++ b/src/include/storage/buffile.h
@@ -15,6 +15,7 @@
  * but currently we have no need for oversize temp files without buffered
  * access.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -28,9 +29,51 @@
 
 #include "storage/sharedfileset.h"
 
-/* BufFile is an opaque type whose details are not known outside buffile.c. */
+/*
+ * BufFile and TransientBufFile are opaque types whose details are not known
+ * outside buffile.c.
+ */
 
 typedef struct BufFile BufFile;
+typedef struct TransientBufFile TransientBufFile;
+
+/*
+ * We break BufFiles into gigabyte-sized segments, regardless of RELSEG_SIZE.
+ * The reason is that we'd like large BufFiles to be spread across multiple
+ * tablespaces when available.
+ *
+ * An integer value indicating the number of useful bytes in the segment is
+ * appended to each segment of if the file is both shared and encrypted, see
+ * BufFile.useful.
+ */
+#define MAX_PHYSICAL_FILESIZE		0x40000000
+
+/* Express segment size in the number of blocks. */
+#define BUFFILE_SEG_BLOCKS(phys)	((phys) / BLCKSZ)
+
+/* GUC to control size of the file segment. */
+extern int buffile_max_filesize;
+/* Segment size in blocks, derived from the above. */
+extern int buffile_seg_blocks;
+
+/*
+ * The portion of the encryption tweak that does not depend on position within
+ * the encrypted file.
+ *
+ * Note that the first byte of this word is reserved for a value of
+ * TransientBufFileKind.
+ */
+#define TWEAK_BASE_SIZE	8
+
+/*
+ * Value to be included in TransientBufFile.tweakBase. It helps to ensure that
+ * the encryption tweak is always unique.
+ */
+typedef enum TransientBufFileKind
+{
+	TRANS_BUF_FILE_REORDERBUFFER, /* reorderbuffer.c */
+	TRANS_BUF_FILE_PGSTATS		  /* pgstat.c */
+} TransientBufFileKind;
 
 /*
  * prototypes for functions in buffile.c
@@ -51,4 +94,14 @@ extern void BufFileExportShared(BufFile *file);
 extern BufFile *BufFileOpenShared(SharedFileSet *fileset, const char *name);
 extern void BufFileDeleteShared(SharedFileSet *fileset, const char *name);
 
+extern TransientBufFile *BufFileOpenTransient(const char *path, int fileFlags,
+											  char tweak_base[TWEAK_BASE_SIZE],
+											  int elevel);
+extern void BufFileCloseTransient(TransientBufFile *file);
+extern File BufFileTransientGetVfd(TransientBufFile *file);
+extern size_t BufFileReadTransient(TransientBufFile *file, void *ptr,
+					 size_t size);
+extern size_t BufFileWriteTransient(TransientBufFile *file, void *ptr,
+					  size_t size);
+
 #endif							/* BUFFILE_H */
diff --git a/src/include/storage/bufpage.h b/src/include/storage/bufpage.h
index 56ca6b6ce1..fa2f54f565 100644
--- a/src/include/storage/bufpage.h
+++ b/src/include/storage/bufpage.h
@@ -4,6 +4,7 @@
  *	  Standard POSTGRES buffer page definitions.
  *
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -425,8 +426,8 @@ do { \
 						((is_heap) ? PAI_IS_HEAP : 0))
 
 extern void PageInit(Page page, Size pageSize, Size specialSize);
-extern bool PageIsVerified(Page page, BlockNumber blkno);
-extern bool PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags);
+extern bool PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags,
+								   Page page_encr);
 extern OffsetNumber PageAddItemExtended(Page page, Item item, Size size,
 										OffsetNumber offsetNumber, int flags);
 extern Page PageGetTempPage(Page page);
diff --git a/src/include/storage/checksum_impl.h b/src/include/storage/checksum_impl.h
index 4b87610796..e1c65153b2 100644
--- a/src/include/storage/checksum_impl.h
+++ b/src/include/storage/checksum_impl.h
@@ -190,9 +190,6 @@ pg_checksum_page(char *page, BlockNumber blkno)
 	uint16		save_checksum;
 	uint32		checksum;
 
-	/* We only calculate the checksum for properly-initialized pages */
-	Assert(!PageIsNew(&cpage->phdr));
-
 	/*
 	 * Save pd_checksum and temporarily set it to zero, so that the checksum
 	 * calculation isn't affected by the old checksum stored on the page.
diff --git a/src/include/storage/encryption.h b/src/include/storage/encryption.h
new file mode 100644
index 0000000000..f144b348ed
--- /dev/null
+++ b/src/include/storage/encryption.h
@@ -0,0 +1,162 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.h
+ *	  Full database encryption support
+ *
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * src/include/storage/encryption.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef ENCRYPTION_H
+#define ENCRYPTION_H
+
+#include "access/xlogdefs.h"
+#include "common/encryption.h"
+#include "miscadmin.h"
+#include "storage/block.h"
+#include "storage/bufpage.h"
+#include "storage/relfilenode.h"
+#include "port/pg_crc32c.h"
+
+/* Is the cluster encrypted? */
+extern bool data_encrypted;
+
+/*
+ * Number of bytes reserved to store encryption sample in ControlFileData.
+ */
+#define ENCRYPTION_SAMPLE_SIZE 16
+
+typedef int (*read_encryption_key_cb) (void);
+/*
+ * This function raises ERROR if the cluster is encrypted but the binary does
+ * not support encryption, so it's compiled regardless the value of
+ * USE_ENCRYPTION. It's less invasive than if we had to ifdef each call.
+ */
+extern void read_encryption_key(read_encryption_key_cb read_char);
+
+/*
+ * Likewise, compile regardless USE_ENCRYPTION.
+ */
+extern void setup_encryption(void);
+
+#ifndef FRONTEND
+/* Copy of the same field of ControlFileData. */
+extern char encryption_verification[];
+
+extern XLogRecPtr get_lsn_for_encryption(void);
+extern void set_page_lsn_for_encryption(Page page);
+extern void set_page_lsn_for_encryption2(Page page1, Page page2);
+extern void set_page_lsn_for_encryption3(Page page1, Page page2, Page page3);
+#endif	/* FRONTEND */
+
+#define TWEAK_SIZE 16
+
+/*
+ * In some cases we need a separate copy of the data because encryption
+ * in-place (typically in the shared buffers) would make the data unusable for
+ * backends.
+ */
+extern PGAlignedBlock encrypt_buf;
+
+/*
+ * The same for XLOG. This buffer spans multiple pages, in order to reduce the
+ * number of syscalls when doing I/O.
+ *
+ * XXX Fine tune the buffer size.
+ */
+#define ENCRYPT_BUF_XLOG_SIZE	(XLOG_ENCRYPT_BUF_PAGES * XLOG_BLCKSZ)
+extern char *encrypt_buf_xlog;
+
+#define	XLOG_ENCRYPT_BUF_PAGES	8
+
+#ifndef FRONTEND
+/*
+ * Space for the encryption key in shared memory. Backend that receives the
+ * key during startup stores it here so postmaster can eventually take a local
+ * copy.
+ *
+ * Although postmaster should not do anything else with shared memory beyond
+ * its setup, mere reading of this structure should not be a problem. The
+ * worst thing that shared memory corruption can cause is wrong or missing
+ * key, both of which will be detected later during the startup. (Failed
+ * startup is not a real crash.) However we don't dare to use spinlock here
+ * because that way shared memory corruption could cause postmaster to end up
+ * in an infinite loop. See processEncryptionKey() for more comments on
+ * synchronization.
+ */
+typedef struct ShmemEncryptionKey
+{
+	char	data[ENCRYPTION_KEY_LENGTH]; /* the key */
+	bool	received;				/* received the key message? */
+	bool	empty;					/* was the key message empty? */
+} ShmemEncryptionKey;
+
+/*
+ * Encryption key in the shared memory.
+ */
+extern ShmemEncryptionKey *encryption_key_shmem;
+#endif							/* FRONTEND */
+
+/* Do we have encryption_key and the encryption library initialized? */
+extern bool	encryption_setup_done;
+
+#ifndef FRONTEND
+extern Size EncryptionShmemSize(void);
+extern void EncryptionShmemInit(void);
+#endif							/* FRONTEND */
+
+#ifdef USE_ENCRYPTION
+
+extern void encryption_error(bool fatal, char *message);
+#endif	/* USE_ENCRYPTION */
+
+/*
+ * Different kinds of data require different ciphers and keys.
+ */
+typedef enum EncryptedDataKind
+{
+	EDK_PERMANENT,				/* Permanent relations and WAL. */
+	EDK_BUFFILE,				/* Temporary and transient files
+								 * (buffile.c) */
+	EDK_TEMP					/* Unlogged and temporary relations. */
+} EncryptedDataKind;
+
+/*
+ * These functions do interact with OpenSSL, but we only enclose the relevant
+ * parts in "#ifdef USE_ENCRYPTION". Thus caller does not have to use #ifdef
+ * and the encryption code is less invasive.
+ */
+extern void encrypt_block(const char *input, char *output, Size size,
+						  char *tweak, XLogRecPtr lsn, BlockNumber block,
+						  EncryptedDataKind data_kind);
+extern void decrypt_block(const char *input, char *output, Size size,
+						  char *tweak, BlockNumber block,
+						  EncryptedDataKind data_kind);
+
+/*
+ * Convenience macros to encrypt / decrypt relation page.
+ */
+#define encrypt_page(input, output, lsn, block, relpersistence)			\
+	encrypt_block((input), (output), BLCKSZ, NULL, (lsn), (block),		\
+				  ((relpersistence) == RELPERSISTENCE_PERMANENT) ? EDK_PERMANENT : EDK_TEMP)
+#define decrypt_page(input, output, block, relpersistence)	\
+	decrypt_block((input), (output), BLCKSZ, NULL, (block), \
+				  ((relpersistence) == RELPERSISTENCE_PERMANENT) ? EDK_PERMANENT : EDK_TEMP)
+
+/*
+ * The following functions do not interact with OpenSSL directly so they are
+ * not ifdef'd using USE_ENCRYPTION. If we ifdef'd them, caller would have to
+ * do the same.
+ */
+extern void sample_encryption(char *buf);
+extern void XLogEncryptionTweak(char *tweak, TimeLineID timeline,
+					XLogSegNo segment, uint32 offset);
+extern void mdtweak(char *tweak, RelFileNode *relnode, ForkNumber forknum,
+		BlockNumber blocknum);
+
+#endif							/* ENCRYPTION_H */
diff --git a/src/include/storage/fd.h b/src/include/storage/fd.h
index d2a8c52044..52f98ca0f8 100644
--- a/src/include/storage/fd.h
+++ b/src/include/storage/fd.h
@@ -76,9 +76,11 @@ extern File PathNameOpenFile(const char *fileName, int fileFlags);
 extern File PathNameOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode);
 extern File OpenTemporaryFile(bool interXact);
 extern void FileClose(File file);
+extern bool FileIsClosed(File file);
 extern int	FilePrefetch(File file, off_t offset, int amount, uint32 wait_event_info);
 extern int	FileRead(File file, char *buffer, int amount, off_t offset, uint32 wait_event_info);
-extern int	FileWrite(File file, char *buffer, int amount, off_t offset, uint32 wait_event_info);
+extern int	FileWrite(File file, char *buffer, int amount, off_t offset,
+					  uint32 wait_event_info, int elevel);
 extern int	FileSync(File file, uint32 wait_event_info);
 extern off_t FileSize(File file);
 extern int	FileTruncate(File file, off_t offset, uint32 wait_event_info);
diff --git a/src/include/storage/freespace.h b/src/include/storage/freespace.h
index 8d8c465d7b..b09e78549f 100644
--- a/src/include/storage/freespace.h
+++ b/src/include/storage/freespace.h
@@ -14,6 +14,7 @@
 #ifndef FREESPACE_H_
 #define FREESPACE_H_
 
+#include "access/xlogdefs.h"
 #include "storage/block.h"
 #include "storage/relfilenode.h"
 #include "utils/relcache.h"
@@ -28,11 +29,12 @@ extern BlockNumber RecordAndGetPageWithFreeSpace(Relation rel,
 extern void RecordPageWithFreeSpace(Relation rel, BlockNumber heapBlk,
 									Size spaceAvail);
 extern void XLogRecordPageWithFreeSpace(RelFileNode rnode, BlockNumber heapBlk,
-										Size spaceAvail);
+										Size spaceAvail, XLogRecPtr recptr);
 
-extern void FreeSpaceMapTruncateRel(Relation rel, BlockNumber nblocks);
+extern void FreeSpaceMapTruncateRel(Relation rel, BlockNumber nblocks,
+									XLogRecPtr recptr);
 extern void FreeSpaceMapVacuum(Relation rel);
 extern void FreeSpaceMapVacuumRange(Relation rel, BlockNumber start,
-									BlockNumber end);
+									BlockNumber end, XLogRecPtr recptr);
 
 #endif							/* FREESPACE_H_ */
diff --git a/src/interfaces/libpq/exports.txt b/src/interfaces/libpq/exports.txt
index ccec59919b..ba267e67ba 100644
--- a/src/interfaces/libpq/exports.txt
+++ b/src/interfaces/libpq/exports.txt
@@ -176,3 +176,7 @@ PQresultMemorySize        173
 PQhostaddr                174
 PQgssEncInUse             175
 PQgetgssctx               176
+PQconnectSSLHandshake     177
+PQpacketSend              178
+PQconnectionSSLMode       179
+PQconnectedToSocket       180
diff --git a/src/interfaces/libpq/fe-connect.c b/src/interfaces/libpq/fe-connect.c
index 562533401e..58a22ac6af 100644
--- a/src/interfaces/libpq/fe-connect.c
+++ b/src/interfaces/libpq/fe-connect.c
@@ -3,6 +3,7 @@
  * fe-connect.c
  *	  functions related to setting up a connection to the backend
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -364,7 +365,7 @@ static const char short_uri_designator[] = "postgres://";
 static bool connectOptions1(PGconn *conn, const char *conninfo);
 static bool connectOptions2(PGconn *conn);
 static int	connectDBStart(PGconn *conn);
-static int	connectDBComplete(PGconn *conn);
+static int	connectDBComplete(PGconn *conn, bool ssl_handshake_only);
 static PGPing internal_ping(PGconn *conn);
 static PGconn *makeEmptyPGconn(void);
 static bool fillPGconn(PGconn *conn, PQconninfoOption *connOptions);
@@ -628,7 +629,7 @@ PQconnectdbParams(const char *const *keywords,
 	PGconn	   *conn = PQconnectStartParams(keywords, values, expand_dbname);
 
 	if (conn && conn->status != CONNECTION_BAD)
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	return conn;
 
@@ -682,7 +683,7 @@ PQconnectdb(const char *conninfo)
 	PGconn	   *conn = PQconnectStart(conninfo);
 
 	if (conn && conn->status != CONNECTION_BAD)
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	return conn;
 }
@@ -838,6 +839,76 @@ PQconnectStart(const char *conninfo)
 	return conn;
 }
 
+
+/*
+ * Bring a connection created earlier by PQconnectStart / PQconnectStartParams
+ * into CONNECTION_MADE state with SSL handshake complete.
+ *
+ * Returns 1 on success, 0 on failure.
+ */
+int
+PQconnectSSLHandshake(PGconn *conn)
+{
+	if (!connectDBComplete(conn, true))
+		return 0;
+
+	if (conn->status != CONNECTION_MADE || !conn->ssl_in_use)
+		return 0;
+
+	return 1;
+}
+
+/*
+ * Return the first letter of conn->sslmode.
+ */
+char
+PQconnectionSSLMode(PGconn *conn)
+{
+	return conn->sslmode[0];
+}
+
+/*
+ * Return 1 if connected to unix domain socket, 0 otherwise.
+ */
+int
+PQconnectedToSocket(PGconn *conn)
+{
+	return (conn->connhost[0].type == CHT_UNIX_SOCKET) ? 1 : 0;
+}
+
+/*
+ * This function only exposes pqPacketSend() to libpq users.
+ *
+ * XXX Currently it's only used to send the encryption key to postmaster, so
+ * we might want to rename the function (PQsendEncryptionKey) and let it
+ * construct the packet. However that would introduce dependency on the
+ * encryption specific code.
+ *
+ * Returns 1 on success, 0 on failure.
+ */
+int
+PQpacketSend(PGconn *conn, char *data, size_t len)
+{
+	/*
+	 * All connection states we expect here should have ended up at
+	 * PGRES_POLLING_WRITING, so poll for write.
+	 */
+	if (pqWaitTimed(0, 1, conn, -1) == -1)
+		return 0;
+
+	if (pqPacketSend(conn, 0, data, len) != STATUS_OK ||
+		conn->write_failed)
+	{
+		char		sebuf[PG_STRERROR_R_BUFLEN];
+
+		appendPQExpBuffer(&conn->errorMessage, "%s\n",
+						  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
+		return 0;
+	}
+
+	return 1;
+}
+
 /*
  * Move option values into conn structure
  *
@@ -1498,7 +1569,7 @@ PQsetdbLogin(const char *pghost, const char *pgport, const char *pgoptions,
 	 * Connect to the database
 	 */
 	if (connectDBStart(conn))
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	return conn;
 
@@ -1980,10 +2051,15 @@ connect_errReturn:
  *
  * Block and complete a connection.
  *
+ * If ssl_handshake_only is set, caller is only interested in the
+ * CONNECTION_MADE status preceded by CONNECTION_SSL_STARTUP. In such a case
+ * caller is not interested in PostgresPollingStatusType - typically because
+ * he'll use the socket in blocking mode.
+ *
  * Returns 1 on success, 0 on failure.
  */
 static int
-connectDBComplete(PGconn *conn)
+connectDBComplete(PGconn *conn, bool ssl_handshake_only)
 {
 	PostgresPollingStatusType flag = PGRES_POLLING_WRITING;
 	time_t		finish_time = ((time_t) -1);
@@ -2040,6 +2116,25 @@ connectDBComplete(PGconn *conn)
 			last_addr_cur = conn->addr_cur;
 		}
 
+#ifdef USE_ENCRYPTION
+		if (ssl_handshake_only)
+		{
+			if (conn->status == CONNECTION_MADE)
+			{
+				if (conn->ssl_in_use)
+					return 1;
+
+				/*
+				 * If we got that far and SSL is not allowed, it will never be
+				 * enabled. (XXX Actually it can be if sslmode is "allow", but
+				 * we don't consider this mode useful for key transfer.)
+				 */
+				if (!conn->allow_ssl_try)
+					return 0;
+			}
+		}
+#endif	/* USE_ENCRYPTION */
+
 		/*
 		 * Wait, if necessary.  Note that the initial state (just after
 		 * PQconnectStart) is to wait for the socket to select for writing.
@@ -3768,7 +3863,7 @@ internal_ping(PGconn *conn)
 
 	/* Attempt to complete the connection */
 	if (conn->status != CONNECTION_BAD)
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	/* Definitely OK if we succeeded */
 	if (conn->status != CONNECTION_BAD)
@@ -4135,7 +4230,7 @@ PQreset(PGconn *conn)
 	{
 		closePGconn(conn);
 
-		if (connectDBStart(conn) && connectDBComplete(conn))
+		if (connectDBStart(conn) && connectDBComplete(conn, false))
 		{
 			/*
 			 * Notify event procs of successful reset.  We treat an event proc
diff --git a/src/interfaces/libpq/libpq-fe.h b/src/interfaces/libpq/libpq-fe.h
index 26198fc1de..58268206b9 100644
--- a/src/interfaces/libpq/libpq-fe.h
+++ b/src/interfaces/libpq/libpq-fe.h
@@ -4,6 +4,7 @@
  *	  This file contains definitions for structures and
  *	  externs for functions used by frontend postgres applications.
  *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -258,6 +259,10 @@ extern PGconn *PQconnectStart(const char *conninfo);
 extern PGconn *PQconnectStartParams(const char *const *keywords,
 									const char *const *values, int expand_dbname);
 extern PostgresPollingStatusType PQconnectPoll(PGconn *conn);
+extern int PQconnectSSLHandshake(PGconn *conn);
+extern char PQconnectionSSLMode(PGconn *conn);
+extern int PQconnectedToSocket(PGconn *conn);
+extern int PQpacketSend(PGconn *conn, char *data, size_t len);
 
 /* Synchronous (blocking) */
 extern PGconn *PQconnectdb(const char *conninfo);
diff --git a/src/test/modules/Makefile b/src/test/modules/Makefile
index 072426d887..4d2166e18e 100644
--- a/src/test/modules/Makefile
+++ b/src/test/modules/Makefile
@@ -6,6 +6,7 @@ include $(top_builddir)/src/Makefile.global
 
 SUBDIRS = \
 		  brin \
+		  buffile \
 		  commit_ts \
 		  dummy_seclabel \
 		  snapshot_too_old \
diff --git a/src/test/modules/buffile/Makefile b/src/test/modules/buffile/Makefile
new file mode 100644
index 0000000000..f5b50aab40
--- /dev/null
+++ b/src/test/modules/buffile/Makefile
@@ -0,0 +1,32 @@
+#-------------------------------------------------------------------------
+#
+# Makefile
+#    Makefile for src/test/modules/buffile
+#
+# Regression tests for src/backend/storage/file/buffile.c
+#
+# IDENTIFICATION
+#    src/test/modules/buffile/Makefile
+#
+#-------------------------------------------------------------------------
+PG_CONFIG ?= pg_config
+MODULE_big = buffile_test
+OBJS = buffile.o $(WIN32RES)
+PGFILEDESC = "buffile_test"
+
+EXTENSION = buffile
+DATA = buffile--1.0.sql
+
+REGRESS = test_01 test_02 test_03 test_04 test_05 test_06 test_07 test_08 \
+test_09 test_10 test_11 test_12 test_13 test_14
+
+ifdef USE_PGXS
+PG_CONFIG = pg_config
+PGXS := $(shell $(PG_CONFIG) --pgxs)
+include $(PGXS)
+else
+subdir = src/test/modules/buffile
+top_builddir = ../../../..
+include $(top_builddir)/src/Makefile.global
+include $(top_srcdir)/contrib/contrib-global.mk
+endif
diff --git a/src/test/modules/buffile/README b/src/test/modules/buffile/README
new file mode 100644
index 0000000000..9c80787797
--- /dev/null
+++ b/src/test/modules/buffile/README
@@ -0,0 +1,11 @@
+This extension was written to check if changes introduced due to cluster
+encryption do not break buffile.c.
+
+Caution: To make the test cheaper, it was decided to adjust the segment sizeq,
+see
+
+#define MAX_PHYSICAL_FILESIZE	(4 * BLCKSZ)
+
+in buffile.c. BLCKSZ is 8192 (the default). All the tests rely on this
+value. So if you haven't compiled Postgres with this value, the tests will
+create 1 GB files and they will fail.
diff --git a/src/test/modules/buffile/buffile--1.0.sql b/src/test/modules/buffile/buffile--1.0.sql
new file mode 100644
index 0000000000..7c168f3514
--- /dev/null
+++ b/src/test/modules/buffile/buffile--1.0.sql
@@ -0,0 +1,54 @@
+CREATE FUNCTION buffile_create()
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_create'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_close()
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_close'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_write(text)
+RETURNS bigint
+AS 'MODULE_PATHNAME', 'buffile_write'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_read(bigint)
+RETURNS bytea
+AS 'MODULE_PATHNAME', 'buffile_read'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_seek(int, bigint)
+RETURNS int
+AS 'MODULE_PATHNAME', 'buffile_seek'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_assert_fileno(int)
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_assert_fileno'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_test_shared()
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_test_shared'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_test_shared_append()
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_test_shared_append'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_open_transient(text, bool, bool)
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_open_transient'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_close_transient()
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_close_transient'
+LANGUAGE C;
+
+CREATE FUNCTION buffile_delete_file(text)
+RETURNS void
+AS 'MODULE_PATHNAME', 'buffile_delete_file'
+LANGUAGE C;
diff --git a/src/test/modules/buffile/buffile.c b/src/test/modules/buffile/buffile.c
new file mode 100644
index 0000000000..568670a5fb
--- /dev/null
+++ b/src/test/modules/buffile/buffile.c
@@ -0,0 +1,445 @@
+/*-------------------------------------------------------------------------
+ *
+ * buffile.c
+ *	  Regression tests for src/backend/storage/file/buffile.c
+ *
+ * Portions Copyright (c) 2019, Cybertec Schönig & Schönig GmbH
+ *
+ * IDENTIFICATION
+ *	  src/test/modules/buffile/buffile.c
+ *
+ *-------------------------------------------------------------------------
+ */
+#include <fcntl.h>
+
+#include "postgres.h"
+#include "fmgr.h"
+#include "lib/stringinfo.h"
+#include "storage/buffile.h"
+#include "utils/array.h"
+#include "utils/builtins.h"
+#include "utils/lsyscache.h"
+#include "utils/memutils.h"
+#include "utils/resowner.h"
+
+PG_MODULE_MAGIC;
+
+/*
+ * To cope with files that span multiple segments w/o wasting resources, use
+ * the smallest possible segment size. The test scripts need to set
+ * buffile_max_filesize (GUC) accordingly.
+ */
+#define MAX_PHYSICAL_FILESIZE_TEST	(4 * BLCKSZ)
+
+static BufFile *bf = NULL;
+static TransientBufFile *bft = NULL;
+
+static void check_file(void);
+
+extern Datum buffile_create_transient(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_create);
+Datum
+buffile_create(PG_FUNCTION_ARGS)
+{
+	MemoryContext old_cxt;
+	ResourceOwner old_ro;
+
+	if (bf != NULL)
+		elog(ERROR, "file already exists");
+
+	old_cxt = MemoryContextSwitchTo(TopMemoryContext);
+
+	/*
+	 * Make sure the file is not deleted across function calls.
+	 */
+	old_ro = CurrentResourceOwner;
+	CurrentResourceOwner = TopTransactionResourceOwner;
+
+	bf = BufFileCreateTemp(false);
+
+	CurrentResourceOwner = old_ro;
+	MemoryContextSwitchTo(old_cxt);
+
+	PG_RETURN_VOID();
+}
+
+extern Datum buffile_close(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_close);
+Datum
+buffile_close(PG_FUNCTION_ARGS)
+{
+	if (bf == NULL)
+		elog(ERROR, "there's no file to close");
+
+	BufFileClose(bf);
+	bf = NULL;
+
+	PG_RETURN_VOID();
+}
+
+extern Datum buffile_write(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_write);
+Datum
+buffile_write(PG_FUNCTION_ARGS)
+{
+	Datum		d = PG_GETARG_DATUM(0);
+	char	   *s = TextDatumGetCString(d);
+	size_t		res;
+
+	if (bf)
+		res = BufFileWrite(bf, s, strlen(s));
+	else if (bft)
+		res = BufFileWriteTransient(bft, s, strlen(s));
+	else
+		elog(ERROR, "No file is open");
+
+	PG_RETURN_INT64(res);
+}
+
+extern Datum buffile_read(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_read);
+Datum
+buffile_read(PG_FUNCTION_ARGS)
+{
+	int64		size = PG_GETARG_INT64(0);
+	StringInfo	buf = makeStringInfo();
+	size_t		res_size;
+	bytea	   *result;
+
+	enlargeStringInfo(buf, size);
+
+	if (bf)
+		res_size = BufFileRead(bf, buf->data, size);
+	else if (bft)
+		res_size = BufFileReadTransient(bft, buf->data, size);
+	else
+		elog(ERROR, "No file is open");
+
+	buf->len = res_size;
+
+	result = DatumGetByteaPP(DirectFunctionCall1(bytearecv,
+												 PointerGetDatum(buf)));
+	PG_RETURN_BYTEA_P(result);
+}
+
+extern Datum buffile_seek(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_seek);
+Datum
+buffile_seek(PG_FUNCTION_ARGS)
+{
+	int32		fileno = PG_GETARG_INT32(0);
+	int64		offset = PG_GETARG_INT64(1);
+	int32		res;
+
+	check_file();
+	res = BufFileSeek(bf, fileno, offset, SEEK_SET);
+
+	PG_RETURN_INT32(res);
+}
+
+extern Datum buffile_assert_fileno(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_assert_fileno);
+Datum
+buffile_assert_fileno(PG_FUNCTION_ARGS)
+{
+	int32		fileno_expected = PG_GETARG_INT32(0);
+	int32		fileno;
+	off_t		offset;
+
+	check_file();
+	BufFileTell(bf, &fileno, &offset);
+
+	if (fileno != fileno_expected)
+	{
+		/*
+		 * Bring the backend down so that the following tests have no chance
+		 * to create the 1GB files.
+		 */
+		elog(FATAL, "file number does not match");
+	}
+
+	PG_RETURN_VOID();
+}
+
+static void
+check_file(void)
+{
+	if (bf == NULL)
+		elog(ERROR, "the file is not opened");
+}
+
+/*
+ * This test is especially important for shared encrypted files, see the
+ * comments below.
+ */
+extern Datum buffile_test_shared(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_test_shared);
+Datum
+buffile_test_shared(PG_FUNCTION_ARGS)
+{
+	dsm_segment *seg;
+	SharedFileSet *fileset;
+	BufFile    *bf_1,
+			   *bf_2;
+	char	   *data_1,
+			   *data_2,
+			   *data;
+	Size		chunk_size_1,
+				chunk_size_2;
+	int			fileno,
+				i;
+	off_t		offset,
+				res,
+				total_size;
+
+	/*
+	 * The size is not important, we actually do not need the shared memory.
+	 * The segment is only needed to initialize the fileset.
+	 */
+	seg = dsm_create(1024, 0);
+
+	/*
+	 * The fileset must survive error handling, so that dsm_detach works fine.
+	 * (The typical use case is that the fileset is in shared memory.)
+	 */
+	fileset = (SharedFileSet *) MemoryContextAlloc(TopTransactionContext,
+												   sizeof(SharedFileSet));
+	SharedFileSetInit(fileset, seg);
+
+	bf_1 = BufFileCreateShared(fileset, "file_1");
+
+	/*
+	 * Write more data than the buffer size, so that we can check that the
+	 * number of "useful bytes" word is only appended at the end of the
+	 * segment, not after each buffer.
+	 */
+	chunk_size_1 = BLCKSZ + 256;
+	data_1 = (char *) palloc(chunk_size_1);
+	memset(data_1, 1, chunk_size_1);
+	if (BufFileWrite(bf_1, data_1, chunk_size_1) != chunk_size_1)
+		elog(ERROR, "Failed to write data");
+	pfree(data_1);
+
+	/*
+	 * Enforce buffer flush (The BufFileFlush() function is not exported).
+	 * Thus the "useful bytes" metadata should appear at the current end the
+	 * first file segment. The next write will have to seek back to overwrite
+	 * the metadata.
+	 */
+	BufFileTell(bf_1, &fileno, &offset);
+	if (BufFileSeek(bf_1, 0, 0, SEEK_SET) != 0)
+		elog(ERROR, "seek failed");
+	if (BufFileSeek(bf_1, fileno, offset, SEEK_SET) != 0)
+		elog(ERROR, "seek failed");
+
+	/*
+	 * Write another chunk that does not fit into the first segment file. Thus
+	 * the "useful bytes" metadata should appear at the end of both segments.
+	 */
+	chunk_size_2 = 3 * BLCKSZ;
+	data_2 = (char *) palloc(chunk_size_2);
+	memset(data_2, 1, chunk_size_2);
+	if (BufFileWrite(bf_1, data_2, chunk_size_2) != chunk_size_2)
+		elog(ERROR, "Failed to write data");
+	pfree(data_2);
+	BufFileClose(bf_1);
+
+	/*
+	 * The word indicating the number of "useful bytes" (i.e. the actual data
+	 * w/o padding to buffer size) is stored at the end of each segment file.
+	 * Check that this metadata is read correctly.
+	 */
+	bf_2 = BufFileOpenShared(fileset, "file_1");
+	total_size = BufFileSize(bf_2);
+	if (total_size != (chunk_size_1 + chunk_size_2))
+		elog(ERROR, "Incorrect file size: %zu", total_size);
+
+	data = (char *) palloc(total_size);
+	res = BufFileRead(bf_2, data, total_size);
+	if (res != total_size)
+		elog(ERROR, "Incorrect chunk size read: %zu", res);
+	for (i = 0; i < total_size; i++)
+		if (data[i] != 1)
+			elog(ERROR, "Unexpected data read from the file");
+	pfree(data);
+	BufFileClose(bf_2);
+
+	dsm_detach(seg);
+
+	PG_RETURN_VOID();
+}
+
+
+/*
+ * Test BufFileAppend().
+ */
+extern Datum buffile_test_shared_append(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_test_shared_append);
+Datum
+buffile_test_shared_append(PG_FUNCTION_ARGS)
+{
+	dsm_segment *seg;
+	SharedFileSet *fileset;
+	BufFile    *bf_1,
+			   *bf_2,
+			   *bf_3;
+	char	   *data;
+	Size		chunk_size;
+	int			i;
+	off_t		res,
+				total_size;
+
+	seg = dsm_create(1024, 0);
+
+	fileset = (SharedFileSet *) MemoryContextAlloc(TopTransactionContext,
+												   sizeof(SharedFileSet));
+	SharedFileSetInit(fileset, seg);
+
+	/*
+	 * XXX Does the chunk size matter much?
+	 */
+	chunk_size = 8;
+	data = (char *) palloc(chunk_size);
+	memset(data, 1, chunk_size);
+
+	bf_1 = BufFileCreateShared(fileset, "file_1");
+	if (BufFileWrite(bf_1, data, chunk_size) != chunk_size)
+		elog(ERROR, "Failed to write data");
+
+	bf_2 = BufFileCreateShared(fileset, "file_2");
+	if (BufFileWrite(bf_2, data, chunk_size) != chunk_size)
+		elog(ERROR, "Failed to write data");
+
+	/*
+	 * Make sure it's read-only so that BufFileAppend() can accept it as
+	 * source.
+	 */
+	BufFileClose(bf_2);
+	bf_2 = BufFileOpenShared(fileset, "file_2");
+
+	bf_3 = BufFileCreateShared(fileset, "file_3");
+	if (BufFileWrite(bf_3, data, chunk_size) != chunk_size)
+		elog(ERROR, "Failed to write data");
+	BufFileClose(bf_3);
+	bf_3 = BufFileOpenShared(fileset, "file_3");
+
+	BufFileAppend(bf_1, bf_2);
+	BufFileAppend(bf_1, bf_3);
+
+	total_size = BufFileSize(bf_1);
+
+	/*
+	 * The result should contain complete segments of bf_1 and bf_2 and the
+	 * valid part of bf_3.
+	 */
+	if (total_size != (2 * MAX_PHYSICAL_FILESIZE_TEST + chunk_size))
+		elog(ERROR, "Incorrect total size of the appended data: %zu",
+			 total_size);
+
+	/*
+	 * Check that data of the 2nd segment was decrypted correctly.
+	 */
+	if (BufFileSeek(bf_1, 1, 0, SEEK_SET) != 0)
+		elog(ERROR, "seek failed");
+	res = BufFileRead(bf_1, data, chunk_size);
+	if (res != chunk_size)
+		elog(ERROR, "Incorrect chunk size read: %zu", res);
+	for (i = 0; i < chunk_size; i++)
+		if (data[i] != 1)
+			elog(ERROR, "Unexpected data read from the file");
+
+	/*
+	 * And the same for the 3rd segment.
+	 *
+	 * TODO Reuse the code above by putting it into a function.
+	 */
+	if (BufFileSeek(bf_1, 2, 0, SEEK_SET) != 0)
+		elog(ERROR, "seek failed");
+	res = BufFileRead(bf_1, data, chunk_size);
+	if (res != chunk_size)
+		elog(ERROR, "Incorrect chunk size read: %zu", res);
+	for (i = 0; i < chunk_size; i++)
+		if (data[i] != 1)
+			elog(ERROR, "Unexpected data read from the file");
+
+	BufFileClose(bf_1);
+	dsm_detach(seg);
+	PG_RETURN_VOID();
+}
+
+extern Datum buffile_open_transient(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_open_transient);
+Datum
+buffile_open_transient(PG_FUNCTION_ARGS)
+{
+	MemoryContext old_cxt;
+	Datum		d = PG_GETARG_DATUM(0);
+	char	   *path = TextDatumGetCString(d);
+	bool		write_only = PG_GETARG_BOOL(1);
+	bool		append = PG_GETARG_BOOL(2);
+	int			flags = O_CREAT | PG_BINARY;
+	char		tweak_base[TWEAK_BASE_SIZE];
+
+	if (bft != NULL)
+		elog(ERROR, "file already exists");
+
+	if (write_only)
+		flags |= O_WRONLY;
+	if (append)
+		flags |= O_APPEND;
+
+	/*
+	 * Make sure the file is not deleted across function calls.
+	 */
+	old_cxt = MemoryContextSwitchTo(TopMemoryContext);
+	/*
+	 * The tweak value does not matter for testing, but it'd better be defined
+	 * (e.g. for troubleshooting purposes).
+	 */
+	memset(tweak_base, 0, TWEAK_BASE_SIZE);
+	bft = BufFileOpenTransient(path, flags, tweak_base, ERROR);
+	MemoryContextSwitchTo(old_cxt);
+
+	PG_RETURN_VOID();
+}
+
+extern Datum buffile_close_transient(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_close_transient);
+Datum
+buffile_close_transient(PG_FUNCTION_ARGS)
+{
+	if (bft == NULL)
+		elog(ERROR, "there's no file to close");
+
+	BufFileCloseTransient(bft);
+	bft = NULL;
+
+	PG_RETURN_VOID();
+}
+
+extern Datum buffile_delete_file(PG_FUNCTION_ARGS);
+
+PG_FUNCTION_INFO_V1(buffile_delete_file);
+Datum
+buffile_delete_file(PG_FUNCTION_ARGS)
+{
+	Datum		d = PG_GETARG_DATUM(0);
+	char	   *path = TextDatumGetCString(d);
+
+	if (bft != NULL)
+		elog(ERROR, "the file is still open");
+
+	PathNameDeleteTemporaryFile(path, true);
+
+	PG_RETURN_VOID();
+}
diff --git a/src/test/modules/buffile/buffile.control b/src/test/modules/buffile/buffile.control
new file mode 100644
index 0000000000..8472c5a348
--- /dev/null
+++ b/src/test/modules/buffile/buffile.control
@@ -0,0 +1,5 @@
+# buffile_test extension
+comment = 'buffile_test'
+default_version = '1.0'
+module_pathname = '$libdir/buffile_test'
+relocatable = true
diff --git a/src/test/modules/buffile/expected/test_01.out b/src/test/modules/buffile/expected/test_01.out
new file mode 100644
index 0000000000..c1a4f5ac7b
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_01.out
@@ -0,0 +1,61 @@
+-- This is the first test, so make sure the test extension is there.
+CREATE EXTENSION IF NOT EXISTS buffile;
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+SELECT buffile_seek(0, 1);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('abc');
+ buffile_write 
+---------------
+             3
+(1 row)
+
+SELECT buffile_seek(0, 0);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Check that the trailing zeroes are not fetched.
+SELECT buffile_read(16);
+ buffile_read 
+--------------
+ \x00616263
+(1 row)
+
+-- Adjust the number of useful bytes.
+SELECT buffile_write('abc');
+ buffile_write 
+---------------
+             3
+(1 row)
+
+-- ... and check again.
+SELECT buffile_seek(0, 0);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(16);
+   buffile_read   
+------------------
+ \x00616263616263
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_02.out b/src/test/modules/buffile/expected/test_02.out
new file mode 100644
index 0000000000..f783d0cb24
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_02.out
@@ -0,0 +1,48 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+SELECT buffile_seek(0, 8189);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Initialize the last 3 positions of the first buffer and the initial 3
+-- positions of the 2nd buffer.
+SELECT buffile_write('abcdef');
+ buffile_write 
+---------------
+             6
+(1 row)
+
+SELECT buffile_seek(0, 0);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Read the first buffer.
+SELECT length(buffile_read(8192));
+ length 
+--------
+   8192
+(1 row)
+
+-- Only 3 bytes of the 2nd buffer should be fetched.
+SELECT length(buffile_read(8192));
+ length 
+--------
+      3
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_03.out b/src/test/modules/buffile/expected/test_03.out
new file mode 100644
index 0000000000..e899fa3b38
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_03.out
@@ -0,0 +1,27 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Read from an empty file.
+SELECT buffile_seek(0, 8);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(16);
+ buffile_read 
+--------------
+ \x
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_04.out b/src/test/modules/buffile/expected/test_04.out
new file mode 100644
index 0000000000..1f8eeabe48
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_04.out
@@ -0,0 +1,84 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Write something near the end of the first buffer, but leave some trailing
+-- space.
+SELECT buffile_seek(0, 8184);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('abcd');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+-- Leave the 2nd buffer empty, as well as a few leading bytes. Thus we should
+-- get a hole that spans the whole 2nd buffer as well as a few adjacent bytes
+-- on each side.
+SELECT buffile_seek(0, 2 * 8192 + 4);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('efgh');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+-- Check the initial part of the hole, which crosses the boundary of the 1st
+-- and the 2nd buffer.
+SELECT buffile_seek(0, 8184);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(16);
+            buffile_read            
+------------------------------------
+ \x61626364000000000000000000000000
+(1 row)
+
+-- Check the trailing part of the whole, which crosses the boundary of the 2nd
+-- and the 3rd buffer.
+SELECT buffile_seek(0, 2 * 8192 - 8);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(16);
+            buffile_read            
+------------------------------------
+ \x00000000000000000000000065666768
+(1 row)
+
+-- Check that the hole contains nothing but zeroes.
+SELECT buffile_seek(0, 8192 - 4);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT btrim(buffile_read(8192 + 8), '\x00');
+ btrim 
+-------
+ \x
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_05.out b/src/test/modules/buffile/expected/test_05.out
new file mode 100644
index 0000000000..6a73147711
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_05.out
@@ -0,0 +1,33 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Seek does not extend the file if it's not followed by write.
+SELECT buffile_seek(0, 1);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_seek(0, 0);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(2);
+ buffile_read 
+--------------
+ \x
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_06.out b/src/test/modules/buffile/expected/test_06.out
new file mode 100644
index 0000000000..d406bda9e6
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_06.out
@@ -0,0 +1,43 @@
+-- This test shows that the if first component file (segment) stays empty,
+-- read stops prematurely even if it starts within that segment, although it'd
+-- otherwise receive some data from the following one.
+BEGIN;
+-- Neither disk space nor time needs to be wasted.
+SET buffile_max_filesize TO 8192;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+SELECT buffile_seek(0, 8192);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('a');
+ buffile_write 
+---------------
+             1
+(1 row)
+
+SELECT buffile_seek(0, 8191);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(2);
+ buffile_read 
+--------------
+ \x
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_07.out b/src/test/modules/buffile/expected/test_07.out
new file mode 100644
index 0000000000..6f2ee3d2d9
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_07.out
@@ -0,0 +1,41 @@
+BEGIN;
+-- Use a small segment, not to waste disk space and time.
+SET buffile_max_filesize TO 8192;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Write data at component file boundary and try to read it.
+SELECT buffile_seek(0, 8192);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('abcd');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+SELECT buffile_seek(0, 8192);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(8);
+ buffile_read 
+--------------
+ \x61626364
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_08.out b/src/test/modules/buffile/expected/test_08.out
new file mode 100644
index 0000000000..6ffcb9dcd6
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_08.out
@@ -0,0 +1,41 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Neither disk space nor time needs to be wasted.
+SET buffile_max_filesize TO 8192;
+-- Write data across component file boundary and try to read it.
+SELECT buffile_seek(0, 8190);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('abcd');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+SELECT buffile_seek(0, 8190);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(8);
+ buffile_read 
+--------------
+ \x61626364
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_09.out b/src/test/modules/buffile/expected/test_09.out
new file mode 100644
index 0000000000..b9d325b676
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_09.out
@@ -0,0 +1,39 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Write data across buffer boundary and try to read it.
+SELECT buffile_seek(0, 8190);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('abcd');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+SELECT buffile_seek(0, 8190);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(8);
+ buffile_read 
+--------------
+ \x61626364
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_10.out b/src/test/modules/buffile/expected/test_10.out
new file mode 100644
index 0000000000..8e457fdcda
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_10.out
@@ -0,0 +1,76 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+-- Write some data at the end of the buffer.
+SELECT buffile_seek(0, 8188);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_write('abcd');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+SELECT buffile_seek(0, 8189);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Enforce flush with the write position not at the end of the buffer. This is
+-- special by not moving curOffset to the next buffer.
+SELECT buffile_read(1);
+ buffile_read 
+--------------
+ \x62
+(1 row)
+
+-- Therefore the next writes should eventually affect the original data. (Here
+-- we also test going directly from read to write and vice versa.)
+SELECT buffile_write('x');
+ buffile_write 
+---------------
+             1
+(1 row)
+
+SELECT buffile_read(1);
+ buffile_read 
+--------------
+ \x64
+(1 row)
+
+-- Start a new buffer, i.e. force flushing of the previous one.
+SELECT buffile_write('z');
+ buffile_write 
+---------------
+             1
+(1 row)
+
+-- Check that the 'x' and 'y' letters are in the first buffer, not in the
+-- 2nd. (We read enough data to find any non-zero bytes in the 2nd buffer.)
+SELECT buffile_seek(0, 8188);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(4 + 8192);
+ buffile_read 
+--------------
+ \x616278647a
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_11.out b/src/test/modules/buffile/expected/test_11.out
new file mode 100644
index 0000000000..c6804d08af
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_11.out
@@ -0,0 +1,34 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+SELECT buffile_write('abcd');
+ buffile_write 
+---------------
+             4
+(1 row)
+
+-- Seek beyond EOF not followed by write.
+SELECT buffile_seek(0, 5);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Nothing should be fetched.
+SELECT buffile_read(8);
+ buffile_read 
+--------------
+ \x
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_12.out b/src/test/modules/buffile/expected/test_12.out
new file mode 100644
index 0000000000..fe507a8e58
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_12.out
@@ -0,0 +1,16 @@
+-- Neither disk space nor time needs to be wasted.
+--
+-- Here the tests are designed for segments of multiple buffers.
+SET buffile_max_filesize TO 32768;
+SELECT buffile_test_shared();
+ buffile_test_shared 
+---------------------
+ 
+(1 row)
+
+SELECT buffile_test_shared_append();
+ buffile_test_shared_append 
+----------------------------
+ 
+(1 row)
+
diff --git a/src/test/modules/buffile/expected/test_13.out b/src/test/modules/buffile/expected/test_13.out
new file mode 100644
index 0000000000..7ba50a9c9d
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_13.out
@@ -0,0 +1,86 @@
+-- Use transaction block so that the file does not closed automatically at
+-- command boundary.
+BEGIN;
+SELECT buffile_open_transient('trans1', true, false);
+ buffile_open_transient 
+------------------------
+ 
+(1 row)
+
+SELECT buffile_write('01234567');
+ buffile_write 
+---------------
+             8
+(1 row)
+
+SELECT buffile_close_transient();
+ buffile_close_transient 
+-------------------------
+ 
+(1 row)
+
+-- Open for reading.
+SELECT buffile_open_transient('trans1', false, false);
+ buffile_open_transient 
+------------------------
+ 
+(1 row)
+
+SELECT length(buffile_read(65536));
+ length 
+--------
+      8
+(1 row)
+
+SELECT buffile_close_transient();
+ buffile_close_transient 
+-------------------------
+ 
+(1 row)
+
+-- Open for writing in append mode.
+SELECT buffile_open_transient('trans1', true, true);
+ buffile_open_transient 
+------------------------
+ 
+(1 row)
+
+-- Add BLCKSZ bytes, so that buffer boundary is crossed.
+SELECT buffile_write(repeat('x', 8192));
+ buffile_write 
+---------------
+          8192
+(1 row)
+
+SELECT buffile_close_transient();
+ buffile_close_transient 
+-------------------------
+ 
+(1 row)
+
+-- Open for reading and verify the valid part.
+SELECT buffile_open_transient('trans1', false, false);
+ buffile_open_transient 
+------------------------
+ 
+(1 row)
+
+SELECT length(buffile_read(65536));
+ length 
+--------
+   8200
+(1 row)
+
+SELECT buffile_close_transient();
+ buffile_close_transient 
+-------------------------
+ 
+(1 row)
+
+SELECT buffile_delete_file('trans1');
+ buffile_delete_file 
+---------------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/expected/test_14.out b/src/test/modules/buffile/expected/test_14.out
new file mode 100644
index 0000000000..a50eff0838
--- /dev/null
+++ b/src/test/modules/buffile/expected/test_14.out
@@ -0,0 +1,67 @@
+BEGIN;
+SELECT buffile_create();
+ buffile_create 
+----------------
+ 
+(1 row)
+
+SELECT buffile_seek(0, 8191);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Write data across block boundary.
+SELECT buffile_write('xyz');
+ buffile_write 
+---------------
+             3
+(1 row)
+
+SELECT buffile_seek(0, 8191);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Check it's there
+SELECT buffile_read(4);
+ buffile_read 
+--------------
+ \x78797a
+(1 row)
+
+SELECT buffile_seek(0, 8191);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+-- Overwrite only part of it.
+SELECT buffile_write('ab');
+ buffile_write 
+---------------
+             2
+(1 row)
+
+-- Check that the remaining part is not affected, i.e. the 2nd block was
+-- loaded before we started to overwrite its contents.
+SELECT buffile_seek(0, 8191);
+ buffile_seek 
+--------------
+            0
+(1 row)
+
+SELECT buffile_read(4);
+ buffile_read 
+--------------
+ \x61627a
+(1 row)
+
+SELECT buffile_close();
+ buffile_close 
+---------------
+ 
+(1 row)
+
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_01.sql b/src/test/modules/buffile/sql/test_01.sql
new file mode 100644
index 0000000000..92331dd0de
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_01.sql
@@ -0,0 +1,17 @@
+-- This is the first test, so make sure the test extension is there.
+CREATE EXTENSION IF NOT EXISTS buffile;
+
+BEGIN;
+SELECT buffile_create();
+SELECT buffile_seek(0, 1);
+SELECT buffile_write('abc');
+SELECT buffile_seek(0, 0);
+-- Check that the trailing zeroes are not fetched.
+SELECT buffile_read(16);
+-- Adjust the number of useful bytes.
+SELECT buffile_write('abc');
+-- ... and check again.
+SELECT buffile_seek(0, 0);
+SELECT buffile_read(16);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_02.sql b/src/test/modules/buffile/sql/test_02.sql
new file mode 100644
index 0000000000..35d34722d7
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_02.sql
@@ -0,0 +1,13 @@
+BEGIN;
+SELECT buffile_create();
+SELECT buffile_seek(0, 8189);
+-- Initialize the last 3 positions of the first buffer and the initial 3
+-- positions of the 2nd buffer.
+SELECT buffile_write('abcdef');
+SELECT buffile_seek(0, 0);
+-- Read the first buffer.
+SELECT length(buffile_read(8192));
+-- Only 3 bytes of the 2nd buffer should be fetched.
+SELECT length(buffile_read(8192));
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_03.sql b/src/test/modules/buffile/sql/test_03.sql
new file mode 100644
index 0000000000..a95391f7c3
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_03.sql
@@ -0,0 +1,7 @@
+BEGIN;
+SELECT buffile_create();
+-- Read from an empty file.
+SELECT buffile_seek(0, 8);
+SELECT buffile_read(16);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_04.sql b/src/test/modules/buffile/sql/test_04.sql
new file mode 100644
index 0000000000..64e8d39f94
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_04.sql
@@ -0,0 +1,25 @@
+BEGIN;
+SELECT buffile_create();
+-- Write something near the end of the first buffer, but leave some trailing
+-- space.
+SELECT buffile_seek(0, 8184);
+SELECT buffile_write('abcd');
+-- Leave the 2nd buffer empty, as well as a few leading bytes. Thus we should
+-- get a hole that spans the whole 2nd buffer as well as a few adjacent bytes
+-- on each side.
+SELECT buffile_seek(0, 2 * 8192 + 4);
+SELECT buffile_write('efgh');
+-- Check the initial part of the hole, which crosses the boundary of the 1st
+-- and the 2nd buffer.
+SELECT buffile_seek(0, 8184);
+SELECT buffile_read(16);
+-- Check the trailing part of the whole, which crosses the boundary of the 2nd
+-- and the 3rd buffer.
+SELECT buffile_seek(0, 2 * 8192 - 8);
+SELECT buffile_read(16);
+-- Check that the hole contains nothing but zeroes.
+SELECT buffile_seek(0, 8192 - 4);
+SELECT btrim(buffile_read(8192 + 8), '\x00');
+
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_05.sql b/src/test/modules/buffile/sql/test_05.sql
new file mode 100644
index 0000000000..5fd642e558
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_05.sql
@@ -0,0 +1,8 @@
+BEGIN;
+SELECT buffile_create();
+-- Seek does not extend the file if it's not followed by write.
+SELECT buffile_seek(0, 1);
+SELECT buffile_seek(0, 0);
+SELECT buffile_read(2);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_06.sql b/src/test/modules/buffile/sql/test_06.sql
new file mode 100644
index 0000000000..35aa48857c
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_06.sql
@@ -0,0 +1,15 @@
+-- This test shows that the if first component file (segment) stays empty,
+-- read stops prematurely even if it starts within that segment, although it'd
+-- otherwise receive some data from the following one.
+BEGIN;
+
+-- Neither disk space nor time needs to be wasted.
+SET buffile_max_filesize TO 8192;
+
+SELECT buffile_create();
+SELECT buffile_seek(0, 8192);
+SELECT buffile_write('a');
+SELECT buffile_seek(0, 8191);
+SELECT buffile_read(2);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_07.sql b/src/test/modules/buffile/sql/test_07.sql
new file mode 100644
index 0000000000..06057c5a1b
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_07.sql
@@ -0,0 +1,13 @@
+BEGIN;
+
+-- Use a small segment, not to waste disk space and time.
+SET buffile_max_filesize TO 8192;
+
+SELECT buffile_create();
+-- Write data at component file boundary and try to read it.
+SELECT buffile_seek(0, 8192);
+SELECT buffile_write('abcd');
+SELECT buffile_seek(0, 8192);
+SELECT buffile_read(8);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_08.sql b/src/test/modules/buffile/sql/test_08.sql
new file mode 100644
index 0000000000..2736dc22df
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_08.sql
@@ -0,0 +1,13 @@
+BEGIN;
+SELECT buffile_create();
+
+-- Neither disk space nor time needs to be wasted.
+SET buffile_max_filesize TO 8192;
+
+-- Write data across component file boundary and try to read it.
+SELECT buffile_seek(0, 8190);
+SELECT buffile_write('abcd');
+SELECT buffile_seek(0, 8190);
+SELECT buffile_read(8);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_09.sql b/src/test/modules/buffile/sql/test_09.sql
new file mode 100644
index 0000000000..cc7060932e
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_09.sql
@@ -0,0 +1,9 @@
+BEGIN;
+SELECT buffile_create();
+-- Write data across buffer boundary and try to read it.
+SELECT buffile_seek(0, 8190);
+SELECT buffile_write('abcd');
+SELECT buffile_seek(0, 8190);
+SELECT buffile_read(8);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_10.sql b/src/test/modules/buffile/sql/test_10.sql
new file mode 100644
index 0000000000..63af760d9f
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_10.sql
@@ -0,0 +1,25 @@
+BEGIN;
+SELECT buffile_create();
+-- Write some data at the end of the buffer.
+SELECT buffile_seek(0, 8188);
+SELECT buffile_write('abcd');
+SELECT buffile_seek(0, 8189);
+-- Enforce flush with the write position not at the end of the buffer. This is
+-- special by not moving curOffset to the next buffer.
+SELECT buffile_read(1);
+
+-- Therefore the next writes should eventually affect the original data. (Here
+-- we also test going directly from read to write and vice versa.)
+SELECT buffile_write('x');
+SELECT buffile_read(1);
+
+-- Start a new buffer, i.e. force flushing of the previous one.
+SELECT buffile_write('z');
+
+-- Check that the 'x' and 'y' letters are in the first buffer, not in the
+-- 2nd. (We read enough data to find any non-zero bytes in the 2nd buffer.)
+SELECT buffile_seek(0, 8188);
+SELECT buffile_read(4 + 8192);
+
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_11.sql b/src/test/modules/buffile/sql/test_11.sql
new file mode 100644
index 0000000000..94300d253f
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_11.sql
@@ -0,0 +1,9 @@
+BEGIN;
+SELECT buffile_create();
+SELECT buffile_write('abcd');
+-- Seek beyond EOF not followed by write.
+SELECT buffile_seek(0, 5);
+-- Nothing should be fetched.
+SELECT buffile_read(8);
+SELECT buffile_close();
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_12.sql b/src/test/modules/buffile/sql/test_12.sql
new file mode 100644
index 0000000000..017050ef5b
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_12.sql
@@ -0,0 +1,7 @@
+-- Neither disk space nor time needs to be wasted.
+--
+-- Here the tests are designed for segments of multiple buffers.
+SET buffile_max_filesize TO 32768;
+
+SELECT buffile_test_shared();
+SELECT buffile_test_shared_append();
diff --git a/src/test/modules/buffile/sql/test_13.sql b/src/test/modules/buffile/sql/test_13.sql
new file mode 100644
index 0000000000..bcabf7bfe6
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_13.sql
@@ -0,0 +1,25 @@
+-- Use transaction block so that the file does not closed automatically at
+-- command boundary.
+BEGIN;
+SELECT buffile_open_transient('trans1', true, false);
+SELECT buffile_write('01234567');
+SELECT buffile_close_transient();
+
+-- Open for reading.
+SELECT buffile_open_transient('trans1', false, false);
+SELECT length(buffile_read(65536));
+SELECT buffile_close_transient();
+
+-- Open for writing in append mode.
+SELECT buffile_open_transient('trans1', true, true);
+-- Add BLCKSZ bytes, so that buffer boundary is crossed.
+SELECT buffile_write(repeat('x', 8192));
+SELECT buffile_close_transient();
+
+-- Open for reading and verify the valid part.
+SELECT buffile_open_transient('trans1', false, false);
+SELECT length(buffile_read(65536));
+SELECT buffile_close_transient();
+
+SELECT buffile_delete_file('trans1');
+COMMIT;
diff --git a/src/test/modules/buffile/sql/test_14.sql b/src/test/modules/buffile/sql/test_14.sql
new file mode 100644
index 0000000000..83020cec85
--- /dev/null
+++ b/src/test/modules/buffile/sql/test_14.sql
@@ -0,0 +1,17 @@
+BEGIN;
+SELECT buffile_create();
+SELECT buffile_seek(0, 8191);
+-- Write data across block boundary.
+SELECT buffile_write('xyz');
+SELECT buffile_seek(0, 8191);
+-- Check it's there
+SELECT buffile_read(4);
+SELECT buffile_seek(0, 8191);
+-- Overwrite only part of it.
+SELECT buffile_write('ab');
+-- Check that the remaining part is not affected, i.e. the 2nd block was
+-- loaded before we started to overwrite its contents.
+SELECT buffile_seek(0, 8191);
+SELECT buffile_read(4);
+SELECT buffile_close();
+COMMIT;
