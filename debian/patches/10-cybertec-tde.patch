diff --git a/COPYRIGHT b/COPYRIGHT
index 9d65dbea7e..1d9ab1116b 100644
--- a/COPYRIGHT
+++ b/COPYRIGHT
@@ -1,6 +1,6 @@
-PostgreSQL Database Management System
-(formerly known as Postgres, then as Postgres95)
+PostgreSQL-TDE Database Management System
 
+Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
 Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
 
 Portions Copyright (c) 1994, The Regents of the University of California
@@ -21,3 +21,12 @@ INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+
+History
+=======
+
+PostgreSQL-TDE is the PostgreSQL database server to which the Transparent Data
+Encryption (TDE) feature has been added. While TDE is copyrighted by CYBERTEC
+PostgreSQL International GmbH, all the prior work is copyrighted by the
+PostgreSQL Global Development Group.
diff --git a/NEWS.TDE b/NEWS.TDE
new file mode 100644
index 0000000000..411841919d
--- /dev/null
+++ b/NEWS.TDE
@@ -0,0 +1,64 @@
+TDE_1.1.2
+=========
+
+Bug Fixes
+---------
+
+1. Reset the statistics if the statistics file is corrupt.
+
+The particular problem was an encrypted statistics file whose size was not a
+whole multiple of BLCKSZ (typically 8 kB). Although there can be other kinds
+of corruption, this one is very easy to identify and handle.
+
+2. Fixed overflow during computation of temporary file read/write position.
+
+Integer type may be insufficient if there the temporary file has too many
+segments.
+
+
+TDE_1.1.1
+=========
+
+Bug Fixes
+---------
+
+1. Make sure that the shared memory data cannot be written to disk.
+
+If the dynamic_shared_memory_type configuration variable is set to "mmap", the
+(unencrypted) shared memory data can be written to disk. This value is rather
+unusual and the initdb utility should never set it, but in theory the DBA can
+do. Our fix is to refuse startup if this value is set and if the instance is
+encrypted at the same time.
+
+
+2. Fixed processing of the "encryption key command".
+
+If the command responsible for generation of the encryption key had to read
+some information (typically the encryption password) from the standard input,
+it did not work with initdb and pg_rewind. Obviously a regression of previous
+changes.
+
+
+TDE_1.1.0
+=========
+
+New Features
+------------
+
+1. Added an option to choose the encryption key length
+
+Initially we only supported 128-bit keys. Now the user can use the --key-bits
+command line option of the initdb application to specify the key length. The
+accepted values are 128, 192 and 256.
+
+2. Improved encryption of temporary files.
+
+A new, unpredictable value of the initialization vector (IV) is now used for
+each execution of encryption. This affects the use cases where (a part of) an
+existing file is overwritten with new data.
+
+
+TDE_1.0.0
+============
+
+The initial implementation of the TDE feature.
diff --git a/configure b/configure
index cbc193dabb..dbb0988944 100755
--- a/configure
+++ b/configure
@@ -580,12 +580,12 @@ MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
-PACKAGE_NAME='PostgreSQL'
-PACKAGE_TARNAME='postgresql'
-PACKAGE_VERSION='14.6'
-PACKAGE_STRING='PostgreSQL 14.6'
-PACKAGE_BUGREPORT='pgsql-bugs@lists.postgresql.org'
-PACKAGE_URL='https://www.postgresql.org/'
+PACKAGE_NAME='PostgreSQL-TDE'
+PACKAGE_TARNAME='postgresql-tde'
+PACKAGE_VERSION='14.6_TDE_1.1.2'
+PACKAGE_STRING='PostgreSQL 14.6 TDE 1.1.2'
+PACKAGE_BUGREPORT='bugs-tde@cybertec.at'
+PACKAGE_URL='https://www.cybertec.at/'
 
 ac_unique_file="src/backend/access/common/heaptuple.c"
 ac_default_prefix=/usr/local/pgsql
@@ -2821,7 +2821,7 @@ _ACEOF
 
 
 PG_MAJORVERSION=`expr "$PACKAGE_VERSION" : '\([0-9][0-9]*\)'`
-PG_MINORVERSION=`expr "$PACKAGE_VERSION" : '.*\.\([0-9][0-9]*\)'`
+PG_MINORVERSION=`expr "$PACKAGE_VERSION" : '.*\.\([0-9][0-9]*\)_'`
 test -n "$PG_MINORVERSION" || PG_MINORVERSION=0
 
 
diff --git a/configure.ac b/configure.ac
index 62a10ee510..7e0ca9dea1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -30,7 +30,7 @@ AC_PREFIX_DEFAULT(/usr/local/pgsql)
 AC_DEFINE_UNQUOTED(CONFIGURE_ARGS, ["$ac_configure_args"], [Saved arguments from configure])
 
 [PG_MAJORVERSION=`expr "$PACKAGE_VERSION" : '\([0-9][0-9]*\)'`]
-[PG_MINORVERSION=`expr "$PACKAGE_VERSION" : '.*\.\([0-9][0-9]*\)'`]
+[PG_MINORVERSION=`expr "$PACKAGE_VERSION" : '.*\.\([0-9][0-9]*\)_'`]
 test -n "$PG_MINORVERSION" || PG_MINORVERSION=0
 AC_SUBST(PG_MAJORVERSION)
 AC_DEFINE_UNQUOTED(PG_MAJORVERSION, "$PG_MAJORVERSION", [PostgreSQL major version as a string])
diff --git a/contrib/amcheck/Makefile b/contrib/amcheck/Makefile
index b82f221e50..00f392715c 100644
--- a/contrib/amcheck/Makefile
+++ b/contrib/amcheck/Makefile
@@ -14,6 +14,10 @@ REGRESS = check check_btree check_heap
 
 TAP_TESTS = 1
 
+# We could adjust the tests so that the relations are first decrypted and then
+# corrupted, but not sure if that would add much value.
+PGENCRKEYCMD =
+
 ifdef USE_PGXS
 PG_CONFIG = pg_config
 PGXS := $(shell $(PG_CONFIG) --pgxs)
diff --git a/contrib/amcheck/t/001_verify_heapam.pl b/contrib/amcheck/t/001_verify_heapam.pl
index 64ba64d6b4..6e4f503ccb 100644
--- a/contrib/amcheck/t/001_verify_heapam.pl
+++ b/contrib/amcheck/t/001_verify_heapam.pl
@@ -15,6 +15,14 @@ my ($node, $result);
 # Test set-up
 #
 $node = get_new_node('test');
+
+# Like in Makefile, turn off encryption. With encryption, corrupt_first_page()
+# below results in different corruption than the tests expect. We could adjust
+# the test so that the page is first decrypted, but not sure it's worth the
+# effort.
+%ENV = $node->_get_env();
+$ENV{PGENCRKEYCMD}="";
+
 $node->init;
 $node->append_conf('postgresql.conf', 'autovacuum=off');
 $node->start;
diff --git a/contrib/bloom/blinsert.c b/contrib/bloom/blinsert.c
index c34a640d1c..a29a0a86f5 100644
--- a/contrib/bloom/blinsert.c
+++ b/contrib/bloom/blinsert.c
@@ -175,6 +175,9 @@ blbuildempty(Relation index)
 	 * itself might remove it while replaying, for example, an
 	 * XLOG_DBASE_CREATE or XLOG_TBLSPC_CREATE record.  Therefore, we need
 	 * this even when wal_level=minimal.
+	 *
+	 * Encryption: nothing to do, LSN (the encryption IV) is not set and there
+	 * is no user data yet.
 	 */
 	PageSetChecksumInplace(metapage, BLOOM_METAPAGE_BLKNO);
 	smgrwrite(index->rd_smgr, INIT_FORKNUM, BLOOM_METAPAGE_BLKNO,
diff --git a/contrib/keycmd/key_listener b/contrib/keycmd/key_listener
new file mode 100755
index 0000000000..6ddc18d190
--- /dev/null
+++ b/contrib/keycmd/key_listener
@@ -0,0 +1,161 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+"""A key management server: just wait to the key and outputs it to stdout. This
+is needed by CYBERTEX's PostgreSQL TDE implementation.
+
+Generate certificates with:
+
+    openssl req -x509 -newkey rsa:2048 -keyout selfsigned.key -nodes \
+        -out selfsigned.cert -sha256 -days 1000
+
+See the official `documentation`_ if need be. Note that the `test with SSL`_
+might be really useful when we do tests.
+
+.. _documentation: https://docs.python.org/3/library/asyncio.html
+.. _test with SSL: https://aliceh75.github.io/testing-asyncio-with-ssl
+"""
+
+import argparse
+import asyncio
+import logging
+import os.path
+import ssl
+import sys
+from pathlib import Path
+
+
+class KeyListenerProtocol(asyncio.Protocol):
+    """The key server, waits for something to give it a key."""
+
+    def __init__(self, on_con_lost):
+        self._logger = logging.getLogger(self.__class__.__name__)
+        self.transport = None
+        self.on_con_lost = on_con_lost
+        self._logger.info("Initialised.")
+
+    def connection_made(self, transport):
+        """Called when a connection is made.
+
+        The transport argument is the transport representing the
+        connection. The protocol is responsible for storing the
+        reference to its transport.
+        """
+        peername = transport.get_extra_info("peername")
+        self._logger.info("Connection from {}.".format(peername))
+        self.transport = transport
+
+    def data_received(self, data):
+        """Called when some data is received. data is a non-empty bytes object
+        containing the incoming data.
+
+        Whether the data is buffered, chunked or reassembled depends on the
+        transport. In general, you shouldnâ€™t rely on specific semantics and
+        instead make your parsing generic and flexible. However, data is
+        always received in the correct order.
+
+        The method can be called an arbitrary number of times while a
+        connection is open.
+
+        However, protocol.eof_received() is called at most once. Once
+        eof_received() is called, data_received() is not called anymore.
+        """
+        message = data.decode()
+        # self._logger.info("Data received: {!r}.".format(message))
+        print("{}".format(message), flush=True)
+
+        self._logger.info("Acknowledge the client's message.")
+        self.transport.write(b"Merci et au revoire!")
+
+        self._logger.info("Close the client socket.")
+        self.transport.close()
+
+        self._logger.info("Close the server socket.")
+        self.on_con_lost.set_result(True)
+
+
+def get_certificates_location():
+    """Returns the top level path to the certificates based on where the code
+    thinks it is running."""
+    if cert_dir:
+        cert_path = Path(cert_dir)
+    if cert_dir and cert_path.exists() and cert_path.is_dir():
+        # This is in the docker image.
+        return cert_path
+    else:
+        test_path = Path.cwd().joinpath("certs")
+        if test_path.exists() and test_path.is_dir():
+            # This is testing in db-tde.
+            return test_path
+        else:
+            # We give up!
+            raise IOError("No idea where to find certificates!")
+
+
+async def main():
+    """Does the hard work so you do not have to."""
+
+    # Logging.
+    logging.basicConfig(
+        filename=log_file,
+        level=logging.DEBUG,
+    )
+    logger = logging.getLogger("main")
+    logger.info("Started")
+
+    # Get a reference to the event loop as we plan to use low-level APIs.
+    loop = asyncio.get_running_loop()
+    on_con_lost = loop.create_future()
+
+    # SSL.
+    server = None
+    try:
+        certs = get_certificates_location()
+        sc = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
+        sc.load_cert_chain(
+            certs.joinpath(cert_file), certs.joinpath(key_file)
+        )
+
+        server = await loop.create_server(
+            lambda: KeyListenerProtocol(on_con_lost), host, port, ssl=sc
+        )
+
+        logger.info("Waiting for inputâ€¦ ")
+        await on_con_lost
+        return 0
+    except IOError as err:
+        logger.exception(err)
+        logger.fatal(err)
+        return 1
+    except OSError as err:
+        logger.exception(err)
+        logger.fatal(err)
+        return 2
+    finally:
+        logger.warning("We are done, bye bye.")
+        if server is not None:
+            server.close()
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--host', default="localhost",
+                        help="Host the key listener is running on")
+    parser.add_argument('--port', default=8888,
+                        help="Port the key listener is running on")
+    parser.add_argument('--certs', default="/usr/local/certs",
+                        help="Directory to search for SSL certificates")
+    parser.add_argument('--cert-file', default="server.crt",
+                        help="Certificate file name")
+    parser.add_argument('--key-file', default="server.key",
+                        help="Key file name")
+    parser.add_argument('--log', default="/var/tmp/key_listener.log",
+                        help="Log file path")
+    args = parser.parse_args()
+    arg_dict = vars(args)
+    host = arg_dict['host']
+    port = arg_dict['port']
+    cert_dir = arg_dict['certs']
+    cert_file = arg_dict['cert_file']
+    key_file = arg_dict['key_file']
+    log_file = arg_dict['log']
+    sys.exit(asyncio.run(main()))
diff --git a/contrib/keycmd/key_talker b/contrib/keycmd/key_talker
new file mode 100755
index 0000000000..027e4df627
--- /dev/null
+++ b/contrib/keycmd/key_talker
@@ -0,0 +1,105 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+"""A key management client: just sends the key to the server.
+
+See the official `documentation`_ if need be.
+
+.. _documentation: https://docs.python.org/3/library/asyncio.html
+"""
+
+import argparse
+import asyncio
+import ssl
+
+
+class KeyTalkerProtocol(asyncio.Protocol):
+    """The main echo key protocol."""
+
+    def __init__(self, message, on_con_lost):
+        self.message = message
+        self.on_con_lost = on_con_lost
+
+    def connection_made(self, transport):
+        """Called when a connection is made.
+
+        The transport argument is the transport representing the
+        connection. The protocol is responsible for storing the
+        reference to its transport.
+        """
+        transport.write(self.message.encode())
+        print("Data sent: {!r}.".format(self.message))
+
+    def data_received(self, data):
+        """Called when some data is received. data is a non-empty bytes object
+        containing the incoming data.
+
+        Whether the data is buffered, chunked or reassembled depends on the
+        transport. In general, you shouldnâ€™t rely on specific semantics and
+        instead make your parsing generic and flexible. However, data is
+        always received in the correct order.
+
+        The method can be called an arbitrary number of times while a
+        connection is open.
+
+        However, protocol.eof_received() is called at most once. Once
+        eof_received() is called, data_received() is not called anymore.
+        """
+        print("Data received: {!r}.".format(data.decode()))
+
+    def connection_lost(self, exc):
+        """Called when the connection is lost or closed.
+
+        The argument is either an exception object or None. The latter
+        means a regular EOF is received, or the connection was aborted
+        or closed by this side of the connection.
+        """
+        if exc is not None:
+            print("Error, closed the connection because {}", exc)
+        else:
+            print("The server closed the connection.")
+        self.on_con_lost.set_result(True)
+
+
+async def main():
+    """Does the hard work so you do not have to."""
+
+    # Get a reference to the event loop as we plan to use low-level APIs.
+    loop = asyncio.get_running_loop()
+
+    # Make sure we can exit this.
+    on_con_lost = loop.create_future()
+
+    # SSL.
+    sc = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
+    sc.check_hostname = False  # FIXME
+
+    # Start the client.
+    transport, _ = await loop.create_connection(
+        lambda: KeyTalkerProtocol(message, on_con_lost),
+        host,
+        port,
+        ssl=sc,
+    )
+
+    # Wait until the protocol signals that the connection is lost and close
+    # the transport.
+    try:
+        await on_con_lost
+    finally:
+        transport.close()
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--host', default="localhost",
+                        help="Host the key listener is running on")
+    parser.add_argument('--port', default=8888,
+                        help="Port the key listener is running on")
+    parser.add_argument('--key', default=8888, required=True,
+                        help="The key to be sent to the listener")
+    args = parser.parse_args()
+    arg_dict = vars(args)
+    host = arg_dict['host']
+    port = arg_dict['port']
+    message = arg_dict['key']
+    asyncio.run(main())
diff --git a/contrib/pg_visibility/pg_visibility.c b/contrib/pg_visibility/pg_visibility.c
index dd0c124e62..d3ca3c00e3 100644
--- a/contrib/pg_visibility/pg_visibility.c
+++ b/contrib/pg_visibility/pg_visibility.c
@@ -394,7 +394,7 @@ pg_truncate_visibility_map(PG_FUNCTION_ARGS)
 	RelationOpenSmgr(rel);
 	rel->rd_smgr->smgr_cached_nblocks[VISIBILITYMAP_FORKNUM] = InvalidBlockNumber;
 
-	block = visibilitymap_prepare_truncate(rel, 0);
+	block = visibilitymap_prepare_truncate(rel, 0, InvalidXLogRecPtr);
 	if (BlockNumberIsValid(block))
 	{
 		fork = VISIBILITYMAP_FORKNUM;
diff --git a/doc/src/sgml/acronyms.sgml b/doc/src/sgml/acronyms.sgml
index 2df6559acc..6acae2bbbc 100644
--- a/doc/src/sgml/acronyms.sgml
+++ b/doc/src/sgml/acronyms.sgml
@@ -387,6 +387,16 @@
     </listitem>
    </varlistentry>
 
+   <varlistentry>
+    <term><acronym>KDF</acronym></term>
+    <listitem>
+     <para>
+      <ulink url="https://en.wikipedia.org/wiki/Key_derivation_function">Key
+      Derivation Function</ulink>
+     </para>
+    </listitem>
+   </varlistentry>
+
    <varlistentry>
     <term><acronym>LDAP</acronym></term>
     <listitem>
diff --git a/doc/src/sgml/config.sgml b/doc/src/sgml/config.sgml
index e069ccdec4..306886aace 100644
--- a/doc/src/sgml/config.sgml
+++ b/doc/src/sgml/config.sgml
@@ -10082,6 +10082,20 @@ dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'
       </listitem>
      </varlistentry>
 
+     <varlistentry id="guc-data-encryption" xreflabel="data_encryption">
+      <term><varname>data_encryption</varname> (<type>boolean</type>)
+      <indexterm>
+       <primary><varname>data_encryption</varname> configuration parameter</primary>
+      </indexterm>
+      </term>
+      <listitem>
+       <para>
+        Reports whether data encryption is enabled for this cluster.
+        See <xref linkend="encryption"/> for more information.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry id="guc-data-directory-mode" xreflabel="data_directory_mode">
       <term><varname>data_directory_mode</varname> (<type>integer</type>)
       <indexterm>
diff --git a/doc/src/sgml/contrib.sgml b/doc/src/sgml/contrib.sgml
index d3ca4b6932..e3aeace674 100644
--- a/doc/src/sgml/contrib.sgml
+++ b/doc/src/sgml/contrib.sgml
@@ -114,6 +114,7 @@ CREATE EXTENSION <replaceable>module_name</replaceable>;
  &intagg;
  &intarray;
  &isn;
+ &keycmd;
  &lo;
  &ltree;
  &oldsnapshot;
diff --git a/doc/src/sgml/encryption.sgml b/doc/src/sgml/encryption.sgml
new file mode 100644
index 0000000000..f2e475251c
--- /dev/null
+++ b/doc/src/sgml/encryption.sgml
@@ -0,0 +1,150 @@
+<!-- doc/src/sgml/encryption.sgml -->
+
+<chapter id="encryption">
+ <title>Transparent Data Encryption</title>
+
+ <para>
+  Cluster encryption can be used if the <acronym>DBA</acronym> cannot or does not
+  want to rely on the filesystem in terms of data confidentiality. If this
+  feature is enabled, <productname>PostgreSQL</productname> encrypts data
+  (both relations and write-ahead log) when writing it to disk, and decrypts
+  it when reading it. The encryption is transparent, so applications see no
+  difference between encrypted and unencrypted clusters.
+ </para>
+
+ <para>
+  If you want to use this feature, please make sure
+  that <productname>OpenSSL</productname> is installed on your server and that
+  support in <productname>PostgreSQL</productname> is enabled at build time
+  (see <xref linkend="installation"/>).
+ </para>
+
+ <para>
+  To create an encrypted cluster, call <xref linkend="app-initdb"/> with the
+  option <option>-K</option> and the path to the command that will retrieve
+  the encryption key. For example:
+<screen>
+<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data -K /usr/local/pgsql/fetch_key_cmd</userinput>
+</screen>
+  Here <filename>/usr/local/pgsql/fetch_key_cmd</filename> is an executable
+  file that writes the encryption key to its standard output and returns
+  zero.
+ </para>
+
+ <para>
+   The encryption key is expected in hexadecimal format, two characters
+   (hexadecimal digits) per byte. For the default key length of 128 bits (16
+   bytes), the expected length of the key string is 32 characters. For
+   example:
+   <computeroutput>
+     882fb7c12e80280fd664c69d2d636913
+   </computeroutput>
+   Likewise, for the key lengths <literal>192</literal> and
+<literal>256</literal> bits, the key string length should
+   be <literal>48</literal> and <literal>64</literal> characters respectively.
+ </para>
+
+ <para>
+   <application>initdb</application> eventually puts the encryption key
+   command into the <filename>postgresql.conf</filename> file, as the value
+   of the <literal>encryption_key_command</literal> parameter. That ensures that
+   you don't need to pass it to <application>pg_ctl</application> each time
+   you want to start the server.
+ </para>
+
+ <para>
+   If you want to enter a password, you can use the
+   <xref linkend="app-pg-keytool"/> utility to derive an encryption key from
+   it. For example, if the <option>-K</option> option looks like the
+   following example, the DBA will be asked for a password interactively:
+
+<screen>
+<prompt>$</prompt> <userinput>initdb -K '(read -sp "Cluster encryption password: " PGENCRPWD; echo $PGENCRPWD | pg_keytool -D %D -w)' -D data
+</userinput>
+</screen>
+
+ </para>
+
+ <note id="encryption_kdf_file">
+  <title>kdf_params file</title>
+  <para>
+    If the cluster should be encrypted, <application>initdb</application>
+    creates <filename>global/kdf_params</filename> file in the data
+    directory. This file contains parameters of
+    the <ulink url="https://en.wikipedia.org/wiki/Key_derivation_function">key
+    derivation function</ulink> (<acronym>KDF</acronym>) and is needed to
+    derive the encryption key from a password. Currently the only
+    supported <acronym>KDF</acronym>
+    is <ulink url="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</ulink>, so
+    the parameters stored in the file are: 1) number of iterations and 2)
+    salt. Since the salt is data directory specific, a different key will be
+    derived from the same password for different data directories.
+  </para>
+
+  <para>
+   The <filename>kdf_params</filename> file contents is not secret, but if it
+   gets lost, you can no longer derive the encryption key from the
+   password. However but you can still use the encryption key if you have it
+   stored somewhere.
+  </para>
+ </note>
+
+ <para>
+   As long as <application>pg_keytool</application> is called
+   by <application>initdb</application>, you can put <literal>%D</literal>
+   into the command and
+   <application>initdb</application> will replace it with the actual directory
+   path. Note, however, that only the actual value of the <option>-K</option>
+   option is subject to this replacement. No replacement will take place
+   if <application>pg_keytool</application> is called from a shell script
+   whose path is passed to <application>initdb</application> via
+   the <option>-K</option> option. In such a case, it may be easier to pass the
+   data directory to
+   <application>pg_keytool</application> via the <envar>PGDATA</envar> environment
+   variable.
+ </para>
+
+ <para>
+   If the <literal>encryption_key_command</literal> setting is not present
+   in <filename>postgresql.conf</filename>, the command can be passed to
+   <xref linkend="app-pg-ctl"/> when starting the cluster:
+
+<screen>
+<prompt>$</prompt> <userinput>pg_ctl -K '(read -sp "Cluster encryption password: " PGENCRPWD; echo $PGENCRPWD | pg_keytool -D %D -w)' -D data start
+</userinput>
+</screen>
+ </para>
+
+ <note>
+   <para>
+     You need to use the <option>-K</option> option if the encryption key
+     command needs to read the password from the console, like it does in the
+     example above. In such a case, please comment out
+     the <literal>encryption_key_command</literal> parameter
+     in <filename>postgresql.conf</filename>.
+   </para>
+ </note>
+
+ <para>
+  Once the <productname>PostgreSQL</productname> server is running, client
+  applications should recognize no difference to an unencrypted cluster,
+  except that the <xref linkend="guc-data-encryption"/> variable is set.
+ </para>
+
+ <para>
+  Since WAL is encrypted, any replication solution based on log shipping
+  (<xref linkend="warm-standby"/>) assumes that all standby servers are
+  encrypted using the same key as their primary server. On the other hand,
+  logical replication (see <xref linkend="logical-replication"/>) allows
+  replication between encrypted and unencrypted clusters, or between clusters
+  encrypted with different keys.
+ </para>
+
+ <note>
+  <para>
+   Key rotation is currently not supported. If you need it, you can use the key
+   management system of your choice and rotate the corresponding key encryption
+   key (KEK) instead.
+  </para>
+ </note>
+</chapter>
diff --git a/doc/src/sgml/filelist.sgml b/doc/src/sgml/filelist.sgml
index 459add557b..cd6a413e7f 100644
--- a/doc/src/sgml/filelist.sgml
+++ b/doc/src/sgml/filelist.sgml
@@ -49,6 +49,7 @@
 <!ENTITY wal           SYSTEM "wal.sgml">
 <!ENTITY logical-replication    SYSTEM "logical-replication.sgml">
 <!ENTITY jit    SYSTEM "jit.sgml">
+<!ENTITY encryption    SYSTEM "encryption.sgml">
 
 <!-- programmer's guide -->
 <!ENTITY bgworker   SYSTEM "bgworker.sgml">
@@ -128,6 +129,7 @@
 <!ENTITY intagg          SYSTEM "intagg.sgml">
 <!ENTITY intarray        SYSTEM "intarray.sgml">
 <!ENTITY isn             SYSTEM "isn.sgml">
+<!ENTITY keycmd          SYSTEM "keycmd.sgml">
 <!ENTITY lo              SYSTEM "lo.sgml">
 <!ENTITY ltree           SYSTEM "ltree.sgml">
 <!ENTITY oid2name        SYSTEM "oid2name.sgml">
diff --git a/doc/src/sgml/installation.sgml b/doc/src/sgml/installation.sgml
index 2af4374455..30f08ce47b 100644
--- a/doc/src/sgml/installation.sgml
+++ b/doc/src/sgml/installation.sgml
@@ -251,8 +251,9 @@ su - postgres
     <listitem>
      <para>
       You need <productname>OpenSSL</productname>, if you want to support
-      encrypted client connections.  <productname>OpenSSL</productname> is
-      also required for random number generation on platforms that do not
+      on-disk data encryption or encrypted client
+      connections.  <productname>OpenSSL</productname> is also required for
+      random number generation on platforms that do not
       have <filename>/dev/urandom</filename> (except Windows).  The minimum
       version required is 1.0.1.
      </para>
@@ -1003,9 +1004,10 @@ build-postgresql:
        </term>
        <listitem>
         <para>
-         Build with support for <acronym>SSL</acronym> (encrypted)
-         connections. The only <replaceable>LIBRARY</replaceable>
-         supported is <option>openssl</option>. This requires the
+         Build with support for for on-disk data encryption
+         or <acronym>SSL</acronym> (encrypted) connections. The
+         only <replaceable>LIBRARY</replaceable> supported
+         is <option>openssl</option>. This requires the
          <productname>OpenSSL</productname> package to be installed.
          <filename>configure</filename> will check for the required
          header files and libraries to make sure that your
diff --git a/doc/src/sgml/keycmd.sgml b/doc/src/sgml/keycmd.sgml
new file mode 100644
index 0000000000..783099b2e2
--- /dev/null
+++ b/doc/src/sgml/keycmd.sgml
@@ -0,0 +1,183 @@
+<!-- doc/src/sgml/keycmd.sgml -->
+
+<sect1 id="keycmd" xreflabel="keycmd">
+ <title>keycmd</title>
+
+ <indexterm zone="keycmd">
+  <primary>keycmd</primary>
+ </indexterm>
+
+ <para>
+  <filename>keycmd</filename> is one particular implementation of the command
+  to retrieve the encryption key for the <productname>PostgreSQL</productname>
+  server. It consists of two scripts:
+
+  <orderedlist spacing="compact">
+   <listitem>
+    <para>
+     <literal>key_listener</literal> - this is to be called via the
+     <literal>encryption_key_command</literal> configuration variable, as
+     described in <xref linkend="encryption"/>. It binds to the specified port
+     and waits for the key. Once the key has arrived, it's printed to the
+     standard output.
+    </para>
+
+    <cmdsynopsis>
+     <command>key_listener</command>
+     <arg choice="opt"><option>--host</option> <replaceable>host</replaceable></arg>
+     <arg choice="opt"><option>--port</option> <replaceable>port</replaceable></arg>
+     <arg choice="opt"><option>--certs</option> <replaceable>directory</replaceable></arg>
+    </cmdsynopsis>
+
+    <para>
+     Following is description of the options:
+
+     <variablelist>
+
+      <varlistentry>
+       <term><option>--host</option></term>
+       <listitem>
+        <para>
+         Host or IP on which the listener waits for the encryption key.
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--port</option></term>
+       <listitem>
+        <para>
+         Port on which the listener waits for the encryption key.
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--certs</option></term>
+       <listitem>
+        <para>
+         Directory in which the listener expects the SSL certificates to
+         initialize the secured connection for the key transfer. If not
+         specified, it looks for the certificates in the current directory.
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--cert-file</option></term>
+       <listitem>
+        <para>
+         Certificate file name, defaults to <literal>server.crt</literal>
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--key-file</option></term>
+       <listitem>
+        <para>
+         Key file name, defaults to <literal>server.key</literal>
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--log</option></term>
+       <listitem>
+        <para>
+         Path to the log file.
+        </para>
+       </listitem>
+      </varlistentry>
+     </variablelist>
+    </para>
+   </listitem>
+
+   <listitem>
+    <para>
+     <literal>key_talker</literal> - this reads the key from the
+     command line and sends it to the listener via secured connection.
+    </para>
+
+    <cmdsynopsis>
+     <command>key_talker</command>
+     <arg choice="opt"><option>--host</option> <replaceable>host</replaceable></arg>
+     <arg choice="opt"><option>--port</option> <replaceable>port</replaceable></arg>
+     <arg choice="plain"><option>--key</option> <replaceable>key</replaceable></arg>
+    </cmdsynopsis>
+
+    <para>
+     Following is description of the options:
+     <variablelist>
+
+      <varlistentry>
+       <term><option>--host</option></term>
+       <listitem>
+        <para>
+         Host or IP to which the encryption key should be sent.
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--port</option></term>
+       <listitem>
+        <para>
+         Port to which the encryption key should be sent.
+        </para>
+       </listitem>
+      </varlistentry>
+
+      <varlistentry>
+       <term><option>--key</option></term>
+       <listitem>
+        <para>
+         The encryption key to be sent.
+        </para>
+       </listitem>
+      </varlistentry>
+     </variablelist>
+    </para>
+   </listitem>
+  </orderedlist>
+ </para>
+
+
+ <sect2>
+  <title>Example</title>
+
+  <para>
+   First, make sure you have the SSL certificate - see
+   <xref linkend="ssl-certificate-creation"/> how to create it.
+  </para>
+
+  <para>
+   Then set <literal>encryption_key_command</literal>
+   in <filename>postgresql.conf</filename> so it points
+   to <literal>key_listener</literal>:
+<programlisting>
+encryption_key_command = '/usr/local/bin/key_listener --certs /home/postgres/certs'
+</programlisting>
+   Here the <literal>--certs</literal> option tells
+   where <literal>key_listener</literal> should look for the certificate to
+   establish the secured connection that it will use to receive the encryption
+   key. Default values are used for the other options.
+  </para>
+
+  <para>
+   Then initiate the <productname>PostgreSQL</productname> server startup
+   (typically using the <command>pg_ctl</command> command) and while the
+   server is starting, use <literal>key_listener</literal> in another
+   console (which can in fact be on another host) to send the encryption key
+   to the key listener:
+<programlisting>
+key_listener --key 3a8455151d1e8fcd5d308667ddc43086
+</programlisting>
+   Once the key listener receives the key, it prints it out to its standard
+   output so that the <productname>PostgreSQL</productname> server can read it
+   and finish the startup.
+  </para>
+ </sect2>
+
+
+</sect1>
diff --git a/doc/src/sgml/postgres.sgml b/doc/src/sgml/postgres.sgml
index dba9cf413f..58764a742b 100644
--- a/doc/src/sgml/postgres.sgml
+++ b/doc/src/sgml/postgres.sgml
@@ -171,6 +171,7 @@ break is not needed in a wider output rendering.
   &wal;
   &logical-replication;
   &jit;
+  &encryption;
   &regress;
 
  </part>
diff --git a/doc/src/sgml/protocol.sgml b/doc/src/sgml/protocol.sgml
index cf1fadcda4..6ed6f34503 100644
--- a/doc/src/sgml/protocol.sgml
+++ b/doc/src/sgml/protocol.sgml
@@ -2125,7 +2125,7 @@ The commands accepted in replication mode are:
   </varlistentry>
 
   <varlistentry>
-    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
+    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ] [ <literal>DECRYPT</literal> ]
      <indexterm><primary>START_REPLICATION</primary></indexterm>
     </term>
     <listitem>
@@ -2180,6 +2180,11 @@ The commands accepted in replication mode are:
       client contains a message of one of the following formats:
      </para>
 
+     <para>
+      If the server is encrypted, the <literal>DECRYPT</literal> option can be
+      passed to tell the server that the WAL stream should be sent in decrypted form.
+     </para>
+
      <para>
       <variablelist>
       <varlistentry>
@@ -2577,7 +2582,7 @@ The commands accepted in replication mode are:
   </varlistentry>
 
   <varlistentry id="protocol-replication-base-backup" xreflabel="BASE_BACKUP">
-    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ] [ <literal>MANIFEST</literal> <replaceable>manifest_option</replaceable> ] [ <literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable> ]
+    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ] [ <literal>MANIFEST</literal> <replaceable>manifest_option</replaceable> ] [ <literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable> ] [ <literal>DECRYPT</literal> ]
      <indexterm><primary>BASE_BACKUP</primary></indexterm>
     </term>
     <listitem>
@@ -2722,6 +2727,22 @@ The commands accepted in replication mode are:
          </para>
         </listitem>
        </varlistentry>
+
+       <varlistentry>
+        <term><literal>DECRYPT</literal></term>
+        <listitem>
+         <para>
+          If the cluster is encrypted and this option is passed, the relation
+          files and WAL files are decrypted before they are sent to the
+          client. In addition, the <literal>Data encryption</literal> field of
+          the control file is set to <literal>off</literal>. This option also
+          ensures that the <filename>global/kdf_params</filename> file
+          (containing parameters of the key derivation function, which is used
+          to derive the encryption key from the password) is not sent to the
+          client.
+         </para>
+        </listitem>
+       </varlistentry>
       </variablelist>
      </para>
      <para>
diff --git a/doc/src/sgml/ref/allfiles.sgml b/doc/src/sgml/ref/allfiles.sgml
index d67270ccc3..7cb40760c1 100644
--- a/doc/src/sgml/ref/allfiles.sgml
+++ b/doc/src/sgml/ref/allfiles.sgml
@@ -207,6 +207,7 @@ Complete list of usable sgml source files in this directory.
 <!ENTITY pgDump             SYSTEM "pg_dump.sgml">
 <!ENTITY pgDumpall          SYSTEM "pg_dumpall.sgml">
 <!ENTITY pgIsready          SYSTEM "pg_isready.sgml">
+<!ENTITY pgKeytool          SYSTEM "pg_keytool.sgml">
 <!ENTITY pgReceivewal       SYSTEM "pg_receivewal.sgml">
 <!ENTITY pgRecvlogical      SYSTEM "pg_recvlogical.sgml">
 <!ENTITY pgResetwal         SYSTEM "pg_resetwal.sgml">
diff --git a/doc/src/sgml/ref/initdb.sgml b/doc/src/sgml/ref/initdb.sgml
index 6604575f36..3ce1639740 100644
--- a/doc/src/sgml/ref/initdb.sgml
+++ b/doc/src/sgml/ref/initdb.sgml
@@ -207,6 +207,31 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry id="app-initdb-data-encr-cmd" xreflabel="data encryption">
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        Encrypt the cluster using a key retrieved from the command specified
+        here. See <xref linkend="encryption"/> for more information.
+       </para>
+      </listitem>
+     </varlistentry>
+
+     <varlistentry id="app-initdb-data-encr-key-length" xreflabel="data
+        encryption key length">
+      <term><option>--key-bits=<replaceable class="parameter">nbits</replaceable></option></term>
+      <listitem>
+       <para>
+         If the cluster should be encrypted, this option can be used to
+         specify the key length in bits. Accepted values
+         are <literal>128</literal> (the default), <literal>192</literal>
+         and <literal>256</literal>. See <xref linkend="encryption"/> for
+         information on the key format.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry id="app-initdb-data-checksums" xreflabel="data checksums">
       <term><option>-k</option></term>
       <term><option>--data-checksums</option></term>
diff --git a/doc/src/sgml/ref/pg_basebackup.sgml b/doc/src/sgml/ref/pg_basebackup.sgml
index 9e6807b457..663832808e 100644
--- a/doc/src/sgml/ref/pg_basebackup.sgml
+++ b/doc/src/sgml/ref/pg_basebackup.sgml
@@ -353,6 +353,19 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-y</option></term>
+      <term><option>--decrypt</option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted (see <xref linkend="encryption"/>), this
+        option can be passed to tell the server that the data should be
+        decrypted before it's sent
+        to <application>pg_basebackup</application>.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-z</option></term>
       <term><option>--gzip</option></term>
diff --git a/doc/src/sgml/ref/pg_ctl-ref.sgml b/doc/src/sgml/ref/pg_ctl-ref.sgml
index 3946fa52ea..a3c0c8eb57 100644
--- a/doc/src/sgml/ref/pg_ctl-ref.sgml
+++ b/doc/src/sgml/ref/pg_ctl-ref.sgml
@@ -24,6 +24,7 @@ PostgreSQL documentation
    <command>pg_ctl</command>
    <arg choice="plain"><option>init[db]</option></arg>
    <arg choice="opt"><option>-D</option> <replaceable>datadir</replaceable></arg>
+   <arg choice="opt"><option>-K</option> <replaceable>command</replaceable></arg>
    <arg choice="opt"><option>-s</option></arg>
    <arg choice="opt"><option>-o</option> <replaceable>initdb-options</replaceable></arg>
   </cmdsynopsis>
@@ -32,6 +33,7 @@ PostgreSQL documentation
    <command>pg_ctl</command>
    <arg choice="plain"><option>start</option></arg>
    <arg choice="opt"><option>-D</option> <replaceable>datadir</replaceable></arg>
+   <arg choice="opt"><option>-K</option> <replaceable>command</replaceable></arg>
    <arg choice="opt"><option>-l</option> <replaceable>filename</replaceable></arg>
    <arg choice="opt"><option>-W</option></arg>
    <arg choice="opt"><option>-t</option> <replaceable>seconds</replaceable></arg>
@@ -61,6 +63,7 @@ PostgreSQL documentation
    <command>pg_ctl</command>
    <arg choice="plain"><option>restart</option></arg>
    <arg choice="opt"><option>-D</option> <replaceable>datadir</replaceable></arg>
+   <arg choice="opt"><option>-K</option> <replaceable>command</replaceable></arg>
    <arg choice="opt"><option>-m</option>
      <group choice="plain">
        <arg choice="plain"><option>s[mart]</option></arg>
@@ -292,6 +295,33 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K <replaceable class="parameter">command</replaceable></option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted and
+        if <literal>encryption_key_command</literal> is not present
+        in <filename>postgresql.conf</filename>, this option can be used to
+        pass the encryption key command to <application>pg_ctl</application>.
+        <application>pg_ctl</application> runs this command to retrieve the
+        encryption key and sends the key to the database server during startup
+        - see <xref linkend="encryption"/> for details.
+       </para>
+
+       <note>
+        <para>
+         If you start your cluster in another way than
+         using <application>pg_ctl</application> (for example
+         using <firstterm>systemd</firstterm> or a custom script) (and
+         if <literal>encryption_key_command</literal> is not present
+         in <filename>postgresql.conf</filename>), consider sending the key
+         using the <xref linkend="app-pg-keytool"/> utility.
+        </para>
+       </note>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-l <replaceable class="parameter">filename</replaceable></option></term>
       <term><option>--log=<replaceable class="parameter">filename</replaceable></option></term>
diff --git a/doc/src/sgml/ref/pg_keytool.sgml b/doc/src/sgml/ref/pg_keytool.sgml
new file mode 100644
index 0000000000..d831faefa0
--- /dev/null
+++ b/doc/src/sgml/ref/pg_keytool.sgml
@@ -0,0 +1,146 @@
+<!--
+doc/src/sgml/ref/pg_keytool.sgml
+PostgreSQL documentation
+-->
+
+<refentry id="app-pg-keytool">
+ <indexterm zone="app-pg-keytool">
+  <primary>pg_keytool</primary>
+ </indexterm>
+
+ <refmeta>
+  <refentrytitle><application>pg_keytool</application></refentrytitle>
+  <manvolnum>1</manvolnum>
+  <refmiscinfo>Application</refmiscinfo>
+ </refmeta>
+
+ <refnamediv>
+  <refname>pg_keytool</refname>
+  <refpurpose>derive cluster encryption key and/or send it to the
+    <productname>PostgreSQL</productname> server</refpurpose>
+ </refnamediv>
+
+ <refsynopsisdiv>
+  <cmdsynopsis>
+   <command>pg_keytool</command>
+   <arg rep="repeat"><replaceable class="parameter">option</replaceable></arg>
+  </cmdsynopsis>
+ </refsynopsisdiv>
+
+ <refsect1>
+  <title>Description</title>
+  <para>
+   <application>pg_keytool</application> reads either an encryption key or a
+   password (if the <option>-w</option> was specified) from standard input. If
+   it receives a password, it runs
+   the <ulink url="https://en.wikipedia.org/wiki/Key_derivation_function"><firstterm>key
+   derivation function</firstterm></ulink> (<acronym>KDF</acronym>) on it in
+   order to derive the key.
+  </para>
+
+  <para>
+   The encryption key is written either to standard output (the default
+   behavior) or, if any of the <option>-s</option>, <option>-h</option>
+   or <option>-p</option> options is specified, sent via a frontend/backend
+   protocol to the <productname>PostgreSQL</productname> server during start
+   up.
+  </para>
+
+  <para>
+   One common use case is that <application>pg_keytool</application> is used
+   with the <option>-K</option> option of <command>initdb</command> or
+   <command>pg_ctl</command>, see the examples in
+   <xref linkend="encryption"/>. In this case it sends the encryption key to
+   standard output.
+  </para>
+
+  <para>
+   The other use case is that <productname>PostgreSQL</productname> is started
+   in another way than using <xref linkend="app-pg-ctl"/>, typically
+   using <firstterm>systemd</firstterm> or a custom script. In this
+   case, <application>pg_keytool</application> can be used to send the key to
+   the server. (<application>pg_keytool</application> should connect to
+   the same port or Unix-domain socket to which applications will eventually
+   connect.)
+  </para>
+
+  <para>
+   If in the latter case you provide <application>pg_keytool</application>
+   with an encryption key (as opposed to with a password), the utility only ensures
+   transmission of the key to the database server.
+  </para>
+ </refsect1>
+
+ <refsect1>
+  <title>Options</title>
+
+   <para>
+    <variablelist>
+     <varlistentry>
+      <term><option>-D <replaceable>directory</replaceable></option></term>
+      <listitem>
+       <para>
+        Specifies the directory where the database cluster is stored. In
+        particular, <application>pg_keytool</application> reads
+        the <filename>global/kdf_params</filename> file from here (see
+        <xref linkend="encryption_kdf_file"/>), as well
+        as <filename>global/pg_control</filename>.
+       </para>
+
+       <para>
+         If this option is not passed, <application>pg_keytool</application>
+         tries to get the data directory from the <envar>PGDATA</envar>
+         environment variable.
+       </para>
+      </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-h <replaceable class="parameter">hostname</replaceable></option></term>
+       <term><option>--host=<replaceable class="parameter">hostname</replaceable></option></term>
+       <listitem>
+        <para>
+          Specifies the host name of the machine on which the server is
+          running. If the value begins with a slash, it is used as the
+          directory for the Unix-domain socket.
+        </para>
+       </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-p <replaceable class="parameter">port</replaceable></option></term>
+       <listitem>
+         <para>
+           Specifies the TCP port or the local Unix-domain socket file
+           extension on which the server is listening for connections.
+           Defaults to the port specified at compile time, usually 5432.
+         </para>
+       </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-s</option></term>
+       <listitem>
+         <para>
+           Send the key to the <productname>PostgreSQL</productname> server
+           rather than to standard output. This option does not have to be
+           specified explicitly if the
+           <literal>--host</literal> or <literal>--port</literal> option is
+           passed.
+         </para>
+       </listitem>
+     </varlistentry>
+
+     <varlistentry>
+       <term><option>-w</option></term>
+       <listitem>
+         <para>
+           If this option is given, the data read from the standard input is
+           the password, otherwise it is the encryption key itself.
+         </para>
+       </listitem>
+     </varlistentry>
+    </variablelist>
+   </para>
+ </refsect1>
+</refentry>
diff --git a/doc/src/sgml/ref/pg_receivewal.sgml b/doc/src/sgml/ref/pg_receivewal.sgml
index 96cc40957a..e55180856c 100644
--- a/doc/src/sgml/ref/pg_receivewal.sgml
+++ b/doc/src/sgml/ref/pg_receivewal.sgml
@@ -251,6 +251,19 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-y</option></term>
+      <term><option>--decrypt</option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted (see <xref linkend="encryption"/>), this
+        option can be passed to tell the server that the data should be
+        decrypted before it's sent
+        to <application>pg_receivewal</application>.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-Z <replaceable class="parameter">level</replaceable></option></term>
       <term><option>--compress=<replaceable class="parameter">level</replaceable></option></term>
diff --git a/doc/src/sgml/ref/pg_resetwal.sgml b/doc/src/sgml/ref/pg_resetwal.sgml
index fd539f5604..5de101fcf1 100644
--- a/doc/src/sgml/ref/pg_resetwal.sgml
+++ b/doc/src/sgml/ref/pg_resetwal.sgml
@@ -99,6 +99,17 @@ PostgreSQL documentation
     </listitem>
    </varlistentry>
 
+   <varlistentry>
+     <term><option>-K</option></term>
+     <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+     <listitem>
+       <para>
+        If the cluster is encrypted (see <xref linkend="encryption"/>), run
+        this command to retrieve the encryption key.
+       </para>
+     </listitem>
+   </varlistentry>
+
    <varlistentry>
     <term><option>-n</option></term>
     <term><option>--dry-run</option></term>
diff --git a/doc/src/sgml/ref/pg_rewind.sgml b/doc/src/sgml/ref/pg_rewind.sgml
index 47c5549230..a2730d526e 100644
--- a/doc/src/sgml/ref/pg_rewind.sgml
+++ b/doc/src/sgml/ref/pg_rewind.sgml
@@ -152,6 +152,17 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted, run this command to retrieve the
+        encryption key. See <xref linkend="encryption"/> for details.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>--source-pgdata=<replaceable class="parameter">directory</replaceable></option></term>
       <listitem>
diff --git a/doc/src/sgml/ref/pg_verifybackup.sgml b/doc/src/sgml/ref/pg_verifybackup.sgml
index 5f83c98706..26650a9f36 100644
--- a/doc/src/sgml/ref/pg_verifybackup.sgml
+++ b/doc/src/sgml/ref/pg_verifybackup.sgml
@@ -178,6 +178,17 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted, run this command to retrieve the
+        encryption key. See <xref linkend="encryption"/> for details.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-q</option></term>
       <term><option>--quiet</option></term>
diff --git a/doc/src/sgml/ref/pg_waldump.sgml b/doc/src/sgml/ref/pg_waldump.sgml
index 5fcdfe210a..428e6774ea 100644
--- a/doc/src/sgml/ref/pg_waldump.sgml
+++ b/doc/src/sgml/ref/pg_waldump.sgml
@@ -100,6 +100,17 @@ PostgreSQL documentation
       </listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the cluster is encrypted, run this command to retrieve the
+        encryption key. See <xref linkend="encryption"/> for details.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-n <replaceable>limit</replaceable></option></term>
       <term><option>--limit=<replaceable>limit</replaceable></option></term>
diff --git a/doc/src/sgml/ref/pgupgrade.sgml b/doc/src/sgml/ref/pgupgrade.sgml
index 98662102fa..f8df843e54 100644
--- a/doc/src/sgml/ref/pgupgrade.sgml
+++ b/doc/src/sgml/ref/pgupgrade.sgml
@@ -122,6 +122,37 @@ PostgreSQL documentation
       </para></listitem>
      </varlistentry>
 
+     <varlistentry>
+      <term><option>-K</option> <replaceable class="parameter">command</replaceable></term>
+      <term><option>--encryption-key-command=<replaceable class="parameter">command</replaceable></option></term>
+      <listitem>
+       <para>
+        If the clusters are encrypted, run this command to retrieve the
+        encryption key. This is the same command that was passed to
+        <xref linkend="app-initdb"/> for cluster creation. For the upgrade to
+        be successful, both old and new clusters must use the same key.
+        Therefore, unless the command contains the <literal>%D</literal>
+        string, it does not matter which cluster the command comes from.
+       </para>
+
+       <note>
+         <para>
+           If you are using <xref linkend="app-pg-keytool"/> to derive the
+           encryption key (see <xref linkend="app-initdb-data-encr-cmd"/>),
+           make sure the <option>-D</option> option points to
+           the <emphasis>old</emphasis> cluster. If it pointed to the new
+           one, then the new cluster would derive a different key from the same
+           password, thus <xref linkend="pgupgrade"/> would fail to start
+           the new cluster.
+         </para>
+       </note>
+
+       <para>
+         See <xref linkend="encryption"/> for details on the command.
+       </para>
+      </listitem>
+     </varlistentry>
+
      <varlistentry>
       <term><option>-k</option></term>
       <term><option>--link</option></term>
diff --git a/doc/src/sgml/reference.sgml b/doc/src/sgml/reference.sgml
index da421ff24e..8a9276bb61 100644
--- a/doc/src/sgml/reference.sgml
+++ b/doc/src/sgml/reference.sgml
@@ -281,6 +281,7 @@
    &pgChecksums;
    &pgControldata;
    &pgCtl;
+   &pgKeytool;
    &pgResetwal;
    &pgRewind;
    &pgtestfsync;
diff --git a/src/backend/access/brin/brin.c b/src/backend/access/brin/brin.c
index 21a2384259..3fd9e43f6f 100644
--- a/src/backend/access/brin/brin.c
+++ b/src/backend/access/brin/brin.c
@@ -816,6 +816,7 @@ brinbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 	BrinBuildState *state;
 	Buffer		meta;
 	BlockNumber pagesPerRange;
+	Page		page;
 
 	/*
 	 * We expect to be called exactly once for any index relation.
@@ -837,11 +838,11 @@ brinbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 					   BRIN_CURRENT_VERSION);
 	MarkBufferDirty(meta);
 
+	page = BufferGetPage(meta);
 	if (RelationNeedsWAL(index))
 	{
 		xl_brin_createidx xlrec;
 		XLogRecPtr	recptr;
-		Page		page;
 
 		xlrec.version = BRIN_CURRENT_VERSION;
 		xlrec.pagesPerRange = BrinGetPagesPerRange(index);
@@ -852,9 +853,10 @@ brinbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 
 		recptr = XLogInsert(RM_BRIN_ID, XLOG_BRIN_CREATE_INDEX);
 
-		page = BufferGetPage(meta);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	UnlockReleaseBuffer(meta);
 
@@ -1320,7 +1322,8 @@ terminate_brin_buildstate(BrinBuildState *state)
 		blk = BufferGetBlockNumber(state->bs_currentInsertBuf);
 		ReleaseBuffer(state->bs_currentInsertBuf);
 		RecordPageWithFreeSpace(state->bs_irel, blk, freespace);
-		FreeSpaceMapVacuumRange(state->bs_irel, blk, blk + 1);
+		FreeSpaceMapVacuumRange(state->bs_irel, blk, blk + 1,
+								InvalidXLogRecPtr);
 	}
 
 	brin_free_desc(state->bs_bdesc);
diff --git a/src/backend/access/brin/brin_pageops.c b/src/backend/access/brin/brin_pageops.c
index 992b33a896..4d2107e460 100644
--- a/src/backend/access/brin/brin_pageops.c
+++ b/src/backend/access/brin/brin_pageops.c
@@ -138,7 +138,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 				brin_initialize_empty_new_buffer(idxrel, newbuf);
 			UnlockReleaseBuffer(newbuf);
 			if (extended)
-				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+										InvalidXLogRecPtr);
 		}
 		return false;
 	}
@@ -159,7 +160,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 				brin_initialize_empty_new_buffer(idxrel, newbuf);
 			UnlockReleaseBuffer(newbuf);
 			if (extended)
-				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+										InvalidXLogRecPtr);
 		}
 		return false;
 	}
@@ -200,6 +202,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 
 			PageSetLSN(oldpage, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(oldpage);
 
 		END_CRIT_SECTION();
 
@@ -212,7 +216,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 				brin_initialize_empty_new_buffer(idxrel, newbuf);
 			UnlockReleaseBuffer(newbuf);
 			if (extended)
-				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+				FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+										InvalidXLogRecPtr);
 		}
 
 		return true;
@@ -300,6 +305,9 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 			PageSetLSN(newpage, recptr);
 			PageSetLSN(BufferGetPage(revmapbuf), recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption3(oldpage, newpage,
+										 BufferGetPage(revmapbuf));
 
 		END_CRIT_SECTION();
 
@@ -310,7 +318,8 @@ brin_doupdate(Relation idxrel, BlockNumber pagesPerRange,
 		if (extended)
 		{
 			RecordPageWithFreeSpace(idxrel, newblk, freespace);
-			FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1);
+			FreeSpaceMapVacuumRange(idxrel, newblk, newblk + 1,
+									InvalidXLogRecPtr);
 		}
 
 		return true;
@@ -448,6 +457,8 @@ brin_doinsert(Relation idxrel, BlockNumber pagesPerRange,
 		PageSetLSN(page, recptr);
 		PageSetLSN(BufferGetPage(revmapbuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(page, BufferGetPage(revmapbuf));
 
 	END_CRIT_SECTION();
 
@@ -461,7 +472,8 @@ brin_doinsert(Relation idxrel, BlockNumber pagesPerRange,
 	if (extended)
 	{
 		RecordPageWithFreeSpace(idxrel, blk, freespace);
-		FreeSpaceMapVacuumRange(idxrel, blk, blk + 1);
+		FreeSpaceMapVacuumRange(idxrel, blk, blk + 1,
+								InvalidXLogRecPtr);
 	}
 
 	return off;
@@ -787,7 +799,8 @@ brin_getinsertbuffer(Relation irel, Buffer oldbuf, Size itemsz,
 
 				if (*extended)
 				{
-					FreeSpaceMapVacuumRange(irel, newblk, newblk + 1);
+					FreeSpaceMapVacuumRange(irel, newblk, newblk + 1,
+											InvalidXLogRecPtr);
 					/* shouldn't matter, but don't confuse caller */
 					*extended = false;
 				}
diff --git a/src/backend/access/brin/brin_revmap.c b/src/backend/access/brin/brin_revmap.c
index c574c8a06e..929bd1689f 100644
--- a/src/backend/access/brin/brin_revmap.c
+++ b/src/backend/access/brin/brin_revmap.c
@@ -433,6 +433,8 @@ brinRevmapDesummarizeRange(Relation idxrel, BlockNumber heapBlk)
 		PageSetLSN(revmapPg, recptr);
 		PageSetLSN(regPg, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(revmapPg, regPg);
 
 	END_CRIT_SECTION();
 
@@ -655,6 +657,8 @@ revmap_physical_extend(BrinRevmap *revmap)
 		PageSetLSN(metapage, recptr);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(metapage, page);
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/gin/ginbtree.c b/src/backend/access/gin/ginbtree.c
index 482cf10877..eb924a24eb 100644
--- a/src/backend/access/gin/ginbtree.c
+++ b/src/backend/access/gin/ginbtree.c
@@ -436,6 +436,14 @@ ginPlaceToPage(GinBtree btree, GinBtreeStack *stack,
 			if (BufferIsValid(childbuf))
 				PageSetLSN(childpage, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr recptr = get_lsn_for_encryption();
+
+			PageSetLSN(page, recptr);
+			if (BufferIsValid(childbuf))
+				PageSetLSN(childpage, recptr);
+		}
 
 		END_CRIT_SECTION();
 
@@ -623,6 +631,17 @@ ginPlaceToPage(GinBtree btree, GinBtreeStack *stack,
 			if (BufferIsValid(childbuf))
 				PageSetLSN(childpage, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			PageSetLSN(page, recptr);
+			PageSetLSN(BufferGetPage(rbuffer), recptr);
+			if (stack->parent == NULL)
+				PageSetLSN(BufferGetPage(lbuffer), recptr);
+			if (BufferIsValid(childbuf))
+				PageSetLSN(childpage, recptr);
+		}
 		END_CRIT_SECTION();
 
 		/*
diff --git a/src/backend/access/gin/gindatapage.c b/src/backend/access/gin/gindatapage.c
index 06c0586543..1f4e9a8ae5 100644
--- a/src/backend/access/gin/gindatapage.c
+++ b/src/backend/access/gin/gindatapage.c
@@ -855,6 +855,8 @@ ginVacuumPostingTreeLeaf(Relation indexrel, Buffer buffer, GinVacuumState *gvs)
 			recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_VACUUM_DATA_LEAF_PAGE);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 	}
@@ -1847,6 +1849,8 @@ createPostingTree(Relation index, ItemPointerData *items, uint32 nitems,
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_CREATE_PTREE);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	UnlockReleaseBuffer(buffer);
 
diff --git a/src/backend/access/gin/ginfast.c b/src/backend/access/gin/ginfast.c
index 1f4f3f62e3..2d71e21644 100644
--- a/src/backend/access/gin/ginfast.c
+++ b/src/backend/access/gin/ginfast.c
@@ -130,6 +130,8 @@ writeListPage(Relation index, Buffer buffer,
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_INSERT_LISTPAGE);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	/* get free space before releasing buffer */
 	freesize = PageGetExactFreeSpace(page);
@@ -435,6 +437,17 @@ ginHeapTupleFastInsert(GinState *ginstate, GinTupleCollector *collector)
 			PageSetLSN(page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(metapage, recptr);
+
+		if (buffer != InvalidBuffer)
+		{
+			PageSetLSN(page, recptr);
+		}
+	}
 
 	if (buffer != InvalidBuffer)
 		UnlockReleaseBuffer(buffer);
@@ -652,6 +665,18 @@ shiftList(Relation index, Buffer metabuffer, BlockNumber newHead,
 				PageSetLSN(page, recptr);
 			}
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			PageSetLSN(metapage, recptr);
+
+			for (i = 0; i < data.ndeleted; i++)
+			{
+				page = BufferGetPage(buffers[i]);
+				PageSetLSN(page, recptr);
+			}
+		}
 
 		for (i = 0; i < data.ndeleted; i++)
 			UnlockReleaseBuffer(buffers[i]);
diff --git a/src/backend/access/gin/gininsert.c b/src/backend/access/gin/gininsert.c
index 0e8672c9e9..bd934891e4 100644
--- a/src/backend/access/gin/gininsert.c
+++ b/src/backend/access/gin/gininsert.c
@@ -418,6 +418,8 @@ ginbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 						  0, RelationGetNumberOfBlocks(index),
 						  true);
 	}
+	else if (data_encrypted)
+		newpage_range_set_lsn(index, 0, RelationGetNumberOfBlocks(index));
 
 	/*
 	 * Return statistics
diff --git a/src/backend/access/gin/ginutil.c b/src/backend/access/gin/ginutil.c
index cdd626ff0a..bd03d610cf 100644
--- a/src/backend/access/gin/ginutil.c
+++ b/src/backend/access/gin/ginutil.c
@@ -700,6 +700,8 @@ ginUpdateStats(Relation index, const GinStatsData *stats, bool is_build)
 		recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_UPDATE_META_PAGE);
 		PageSetLSN(metapage, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(metapage);
 
 	UnlockReleaseBuffer(metabuffer);
 
diff --git a/src/backend/access/gin/ginvacuum.c b/src/backend/access/gin/ginvacuum.c
index a276eb020b..4dfff6bd50 100644
--- a/src/backend/access/gin/ginvacuum.c
+++ b/src/backend/access/gin/ginvacuum.c
@@ -97,7 +97,12 @@ xlogVacuumPage(Relation index, Buffer buffer)
 	Assert(GinPageIsLeaf(page));
 
 	if (!RelationNeedsWAL(index))
+	{
+		if (data_encrypted)
+			set_page_lsn_for_encryption(page);
+
 		return;
+	}
 
 	/*
 	 * Always create a full image, we don't track the changes on the page at
@@ -224,6 +229,8 @@ ginDeletePage(GinVacuumState *gvs, BlockNumber deleteBlkno, BlockNumber leftBlkn
 		PageSetLSN(parentPage, recptr);
 		PageSetLSN(BufferGetPage(lBuffer), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption3(page, parentPage, BufferGetPage(lBuffer));
 
 	ReleaseBuffer(pBuffer);
 	ReleaseBuffer(lBuffer);
diff --git a/src/backend/access/gist/gist.c b/src/backend/access/gist/gist.c
index 0683f42c25..6f0bf0ef7a 100644
--- a/src/backend/access/gist/gist.c
+++ b/src/backend/access/gist/gist.c
@@ -508,6 +508,8 @@ gistplacetopage(Relation rel, Size freespace, GISTSTATE *giststate,
 				recptr = gistXLogSplit(is_leaf,
 									   dist, oldrlink, oldnsn, leftchildbuf,
 									   markfollowright);
+			else if (data_encrypted)
+				recptr = get_lsn_for_encryption();
 			else
 				recptr = gistGetFakeLSN(rel);
 		}
@@ -586,6 +588,8 @@ gistplacetopage(Relation rel, Size freespace, GISTSTATE *giststate,
 										deloffs, ndeloffs, itup, ntup,
 										leftchildbuf);
 			}
+			else if (data_encrypted)
+				recptr = get_lsn_for_encryption();
 			else
 				recptr = gistGetFakeLSN(rel);
 		}
@@ -1698,6 +1702,8 @@ gistprunepage(Relation rel, Page page, Buffer buffer, Relation heapRel)
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 		else
 			PageSetLSN(page, gistGetFakeLSN(rel));
 
diff --git a/src/backend/access/gist/gistbuild.c b/src/backend/access/gist/gistbuild.c
index ec28bfe89f..ead1a8ca3b 100644
--- a/src/backend/access/gist/gistbuild.c
+++ b/src/backend/access/gist/gistbuild.c
@@ -331,6 +331,8 @@ gistbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 							  0, RelationGetNumberOfBlocks(index),
 							  true);
 		}
+		else if (data_encrypted)
+			newpage_range_set_lsn(index, 0, RelationGetNumberOfBlocks(index));
 	}
 
 	/* okay, all heap tuples are indexed */
@@ -399,6 +401,7 @@ gist_indexsortbuild(GISTBuildState *state)
 	GistSortedBuildPageState *leafstate;
 	GistSortedBuildPageState *pagestate;
 	Page		page;
+	char		*buf;
 
 	state->pages_allocated = 0;
 	state->pages_written = 0;
@@ -407,6 +410,8 @@ gist_indexsortbuild(GISTBuildState *state)
 	/*
 	 * Write an empty page as a placeholder for the root page. It will be
 	 * replaced with the real root page at the end.
+	 *
+	 * Empty page has no valid LSN, therefore encryption is not applicable.
 	 */
 	page = palloc0(BLCKSZ);
 	RelationOpenSmgr(state->indexrel);
@@ -451,10 +456,28 @@ gist_indexsortbuild(GISTBuildState *state)
 
 	/* Write out the root */
 	RelationOpenSmgr(state->indexrel);
-	PageSetLSN(pagestate->page, GistBuildLSN);
-	PageSetChecksumInplace(pagestate->page, GIST_ROOT_BLKNO);
+
+	buf = (char *) pagestate->page;
+	PageSetLSN(buf, GistBuildLSN);
+
+	if (data_encrypted)
+	{
+		encrypt_page(buf,
+					 encrypt_buf.data,
+					 GistBuildLSN,
+					 GIST_ROOT_BLKNO);
+
+		buf = encrypt_buf.data;
+	}
+
+	PageSetChecksumInplace(buf, GIST_ROOT_BLKNO);
 	smgrwrite(state->indexrel->rd_smgr, MAIN_FORKNUM, GIST_ROOT_BLKNO,
-			  pagestate->page, true);
+			  buf, true);
+
+	/*
+	 * Encryption: no need to enforce the LSN, the page isn't going to be
+	 * flushed to disk now.
+	 */
 	if (RelationNeedsWAL(state->indexrel))
 		log_newpage(&state->indexrel->rd_node, MAIN_FORKNUM, GIST_ROOT_BLKNO,
 					pagestate->page, true);
@@ -574,6 +597,8 @@ gist_indexsortbuild_pagestate_flush(GISTBuildState *state,
 static void
 gist_indexsortbuild_flush_ready_pages(GISTBuildState *state)
 {
+	char	*buf;
+
 	if (state->ready_num_pages == 0)
 		return;
 
@@ -588,13 +613,29 @@ gist_indexsortbuild_flush_ready_pages(GISTBuildState *state)
 		if (blkno != state->pages_written)
 			elog(ERROR, "unexpected block number to flush GiST sorting build");
 
-		PageSetLSN(page, GistBuildLSN);
-		PageSetChecksumInplace(page, blkno);
-		smgrextend(state->indexrel->rd_smgr, MAIN_FORKNUM, blkno, page, true);
+		buf = (char *) page;
+		PageSetLSN(buf, GistBuildLSN);
+
+		if (data_encrypted)
+		{
+			encrypt_page(buf,
+						 encrypt_buf.data,
+						 GistBuildLSN,
+						 blkno);
+
+			buf = encrypt_buf.data;
+		}
+
+		PageSetChecksumInplace(buf, blkno);
+		smgrextend(state->indexrel->rd_smgr, MAIN_FORKNUM, blkno, buf, true);
 
 		state->pages_written++;
 	}
 
+	/*
+	 * Encryption: no need to enforce the LSN, the pages aren't going to be
+	 * flushed to disk now.
+	 */
 	if (RelationNeedsWAL(state->indexrel))
 		log_newpages(&state->indexrel->rd_node, MAIN_FORKNUM, state->ready_num_pages,
 					 state->ready_blknos, state->ready_pages, true);
diff --git a/src/backend/access/gist/gistvacuum.c b/src/backend/access/gist/gistvacuum.c
index 0663193531..c3df174667 100644
--- a/src/backend/access/gist/gistvacuum.c
+++ b/src/backend/access/gist/gistvacuum.c
@@ -174,6 +174,8 @@ gistvacuumscan(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,
 	vstate.callback_state = callback_state;
 	if (RelationNeedsWAL(rel))
 		vstate.startNSN = GetInsertRecPtr();
+	else if (data_encrypted)
+		vstate.startNSN = get_lsn_for_encryption();
 	else
 		vstate.startNSN = gistGetFakeLSN(rel);
 
@@ -369,6 +371,8 @@ restart:
 										NULL, 0, InvalidBuffer);
 				PageSetLSN(page, recptr);
 			}
+			else if (data_encrypted)
+				set_page_lsn_for_encryption(page);
 			else
 				PageSetLSN(page, gistGetFakeLSN(rel));
 
@@ -657,6 +661,8 @@ gistdeletepage(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,
 
 	if (RelationNeedsWAL(info->index))
 		recptr = gistXLogPageDelete(leafBuffer, txid, parentBuffer, downlink);
+	else if (data_encrypted)
+		recptr = get_lsn_for_encryption();
 	else
 		recptr = gistGetFakeLSN(info->index);
 	PageSetLSN(parentPage, recptr);
diff --git a/src/backend/access/hash/hash.c b/src/backend/access/hash/hash.c
index 0752fb38a9..1e6e4cce49 100644
--- a/src/backend/access/hash/hash.c
+++ b/src/backend/access/hash/hash.c
@@ -619,6 +619,8 @@ loop_top:
 		recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_UPDATE_META_PAGE);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(metabuf));
 
 	END_CRIT_SECTION();
 
@@ -835,6 +837,8 @@ hashbucketcleanup(Relation rel, Bucket cur_bucket, Buffer bucket_buf,
 				recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_DELETE);
 				PageSetLSN(BufferGetPage(buf), recptr);
 			}
+			else if (data_encrypted)
+				set_page_lsn_for_encryption(BufferGetPage(buf));
 
 			END_CRIT_SECTION();
 		}
@@ -901,6 +905,8 @@ hashbucketcleanup(Relation rel, Bucket cur_bucket, Buffer bucket_buf,
 			recptr = XLogInsert(RM_HASH_ID, XLOG_HASH_SPLIT_CLEANUP);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 	}
diff --git a/src/backend/access/hash/hashinsert.c b/src/backend/access/hash/hashinsert.c
index d254a00b6a..c960be06de 100644
--- a/src/backend/access/hash/hashinsert.c
+++ b/src/backend/access/hash/hashinsert.c
@@ -231,6 +231,9 @@ restart_insert:
 		PageSetLSN(BufferGetPage(buf), recptr);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(buf),
+									 BufferGetPage(metabuf));
 
 	END_CRIT_SECTION();
 
@@ -420,6 +423,9 @@ _hash_vacuum_one_page(Relation rel, Relation hrel, Buffer metabuf, Buffer buf)
 			PageSetLSN(BufferGetPage(buf), recptr);
 			PageSetLSN(BufferGetPage(metabuf), recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption2(BufferGetPage(buf),
+										 BufferGetPage(metabuf));
 
 		END_CRIT_SECTION();
 
diff --git a/src/backend/access/hash/hashovfl.c b/src/backend/access/hash/hashovfl.c
index 1ff2e0c18e..38203666c3 100644
--- a/src/backend/access/hash/hashovfl.c
+++ b/src/backend/access/hash/hashovfl.c
@@ -419,6 +419,21 @@ found:
 
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(BufferGetPage(ovflbuf), recptr);
+		PageSetLSN(BufferGetPage(buf), recptr);
+
+		if (BufferIsValid(mapbuf))
+			PageSetLSN(BufferGetPage(mapbuf), recptr);
+
+		if (BufferIsValid(newmapbuf))
+			PageSetLSN(BufferGetPage(newmapbuf), recptr);
+
+		PageSetLSN(BufferGetPage(metabuf), recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -710,6 +725,23 @@ _hash_freeovflpage(Relation rel, Buffer bucketbuf, Buffer ovflbuf,
 		if (update_metap)
 			PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(BufferGetPage(wbuf), recptr);
+		PageSetLSN(BufferGetPage(ovflbuf), recptr);
+
+		if (BufferIsValid(prevbuf) && !(wbuf == prevbuf))
+			PageSetLSN(BufferGetPage(prevbuf), recptr);
+		if (BufferIsValid(nextbuf))
+			PageSetLSN(BufferGetPage(nextbuf), recptr);
+
+		PageSetLSN(BufferGetPage(mapbuf), recptr);
+
+		if (update_metap)
+			PageSetLSN(BufferGetPage(metabuf), recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -980,6 +1012,9 @@ readpage:
 						PageSetLSN(BufferGetPage(wbuf), recptr);
 						PageSetLSN(BufferGetPage(rbuf), recptr);
 					}
+					else if (data_encrypted)
+						set_page_lsn_for_encryption2(BufferGetPage(wbuf),
+													 BufferGetPage(rbuf));
 
 					END_CRIT_SECTION();
 
diff --git a/src/backend/access/hash/hashpage.c b/src/backend/access/hash/hashpage.c
index 49a9867787..092f677386 100644
--- a/src/backend/access/hash/hashpage.c
+++ b/src/backend/access/hash/hashpage.c
@@ -3,6 +3,7 @@
  * hashpage.c
  *	  Hash table page management code for the Postgres hash access method
  *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
  * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -400,6 +401,8 @@ _hash_init(Relation rel, double num_tuples, ForkNumber forkNum)
 
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(metabuf));
 
 	num_buckets = metap->hashm_maxbucket + 1;
 
@@ -432,6 +435,9 @@ _hash_init(Relation rel, double num_tuples, ForkNumber forkNum)
 						blkno,
 						BufferGetPage(buf),
 						true);
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(BufferGetPage(buf));
+
 		_hash_relbuf(rel, buf);
 	}
 
@@ -482,6 +488,9 @@ _hash_init(Relation rel, double num_tuples, ForkNumber forkNum)
 		PageSetLSN(BufferGetPage(bitmapbuf), recptr);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(bitmapbuf),
+									 BufferGetPage(metabuf));
 
 	/* all done */
 	_hash_relbuf(rel, bitmapbuf);
@@ -933,6 +942,10 @@ restart_expand:
 		PageSetLSN(BufferGetPage(buf_nblkno), recptr);
 		PageSetLSN(BufferGetPage(metabuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption3(BufferGetPage(buf_oblkno),
+									 BufferGetPage(buf_nblkno),
+									 BufferGetPage(metabuf));
 
 	END_CRIT_SECTION();
 
@@ -990,6 +1003,7 @@ _hash_alloc_buckets(Relation rel, BlockNumber firstblock, uint32 nblocks)
 	PGAlignedBlock zerobuf;
 	Page		page;
 	HashPageOpaque ovflopaque;
+	XLogRecPtr	lsn;
 
 	lastblock = firstblock + nblocks - 1;
 
@@ -1018,15 +1032,35 @@ _hash_alloc_buckets(Relation rel, BlockNumber firstblock, uint32 nblocks)
 	ovflopaque->hasho_page_id = HASHO_PAGE_ID;
 
 	if (RelationNeedsWAL(rel))
+	{
 		log_newpage(&rel->rd_node,
 					MAIN_FORKNUM,
 					lastblock,
 					zerobuf.data,
 					true);
+		lsn = PageGetLSN(zerobuf.data);
+	}
+	else if (data_encrypted)
+		lsn = get_lsn_for_encryption();
+
+	/*
+	 * Encrypt only if we have valid IV. It should be always except when
+	 * log_newpage() encountered an empty page - it should be safe not to
+	 * encrypt such one.
+	 */
+	if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+	{
+		encrypt_page(zerobuf.data,
+					 encrypt_buf.data,
+					 lsn,
+					 lastblock);
+
+		page = encrypt_buf.data;
+	}
 
 	RelationOpenSmgr(rel);
 	PageSetChecksumInplace(page, lastblock);
-	smgrextend(rel->rd_smgr, MAIN_FORKNUM, lastblock, zerobuf.data, false);
+	smgrextend(rel->rd_smgr, MAIN_FORKNUM, lastblock, page, false);
 
 	return true;
 }
@@ -1309,6 +1343,9 @@ _hash_splitbucket(Relation rel,
 		PageSetLSN(BufferGetPage(bucket_obuf), recptr);
 		PageSetLSN(BufferGetPage(bucket_nbuf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(bucket_obuf),
+									 BufferGetPage(bucket_nbuf));
 
 	END_CRIT_SECTION();
 
@@ -1480,6 +1517,8 @@ log_split_page(Relation rel, Buffer buf)
 
 		PageSetLSN(BufferGetPage(buf), recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(buf));
 }
 
 /*
diff --git a/src/backend/access/heap/heapam.c b/src/backend/access/heap/heapam.c
index fcb7e33898..602dbe6ece 100644
--- a/src/backend/access/heap/heapam.c
+++ b/src/backend/access/heap/heapam.c
@@ -2237,6 +2237,8 @@ heap_insert(Relation relation, HeapTuple tup, CommandId cid,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(buffer));
 
 	END_CRIT_SECTION();
 
@@ -2585,6 +2587,8 @@ heap_multi_insert(Relation relation, TupleTableSlot **slots, int ntuples,
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 
@@ -3084,6 +3088,8 @@ l1:
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -3797,6 +3803,8 @@ l2:
 			recptr = XLogInsert(RM_HEAP_ID, XLOG_HEAP_LOCK);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 
@@ -4032,6 +4040,14 @@ l2:
 		}
 		PageSetLSN(BufferGetPage(buffer), recptr);
 	}
+	else if (data_encrypted)
+	{
+		if (newbuf != buffer)
+			set_page_lsn_for_encryption2(BufferGetPage(newbuf),
+										 BufferGetPage(buffer));
+		else
+			set_page_lsn_for_encryption(BufferGetPage(buffer));
+	}
 
 	END_CRIT_SECTION();
 
@@ -4989,6 +5005,8 @@ failed:
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -5740,6 +5758,8 @@ l4:
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(BufferGetPage(buf));
 
 		END_CRIT_SECTION();
 
@@ -5898,6 +5918,8 @@ heap_finish_speculative(Relation relation, ItemPointer tid)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -6041,6 +6063,8 @@ heap_abort_speculative(Relation relation, ItemPointer tid)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -6152,6 +6176,8 @@ heap_inplace_update(Relation relation, HeapTuple tuple)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/heap/hio.c b/src/backend/access/heap/hio.c
index 66f7a523c3..fe1e72a653 100644
--- a/src/backend/access/heap/hio.c
+++ b/src/backend/access/heap/hio.c
@@ -266,7 +266,8 @@ RelationAddExtraBlocks(Relation relation, BulkInsertState bistate)
 	 * subsequent insertion activity sees all of those nifty free pages we
 	 * just inserted.
 	 */
-	FreeSpaceMapVacuumRange(relation, firstBlock, blockNum + 1);
+	FreeSpaceMapVacuumRange(relation, firstBlock, blockNum + 1,
+							InvalidXLogRecPtr);
 }
 
 /*
diff --git a/src/backend/access/heap/pruneheap.c b/src/backend/access/heap/pruneheap.c
index f7f8056d63..78325252b2 100644
--- a/src/backend/access/heap/pruneheap.c
+++ b/src/backend/access/heap/pruneheap.c
@@ -420,6 +420,8 @@ heap_page_prune(Relation relation, Buffer buffer,
 
 			PageSetLSN(BufferGetPage(buffer), recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(BufferGetPage(buffer));
 	}
 	else
 	{
diff --git a/src/backend/access/heap/rewriteheap.c b/src/backend/access/heap/rewriteheap.c
index 15bef9f7d3..f772e92dc5 100644
--- a/src/backend/access/heap/rewriteheap.c
+++ b/src/backend/access/heap/rewriteheap.c
@@ -92,7 +92,8 @@
  * heap's TOAST table will go through the normal bufmgr.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994-5, Regents of the University of California
  *
  * IDENTIFICATION
@@ -317,18 +318,41 @@ end_heap_rewrite(RewriteState state)
 	/* Write the last page, if any */
 	if (state->rs_buffer_valid)
 	{
+		char	*buf = (char *) state->rs_buffer;
+		XLogRecPtr	lsn = InvalidXLogRecPtr;
+
 		if (RelationNeedsWAL(state->rs_new_rel))
+		{
 			log_newpage(&state->rs_new_rel->rd_node,
 						MAIN_FORKNUM,
 						state->rs_blockno,
-						state->rs_buffer,
+						buf,
 						true);
+			lsn = PageGetLSN(buf);
+		}
+		else if (data_encrypted)
+			lsn = get_lsn_for_encryption();
+
+		/*
+		 * Encrypt only if we have valid IV. It should be always except when
+		 * log_newpage() encountered an empty page - it should be safe not to
+		 * encrypt such.
+		 */
+		if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+		{
+			encrypt_page(buf,
+						 encrypt_buf.data,
+						 lsn,
+						 state->rs_blockno);
+
+			buf = encrypt_buf.data;
+		}
 
-		PageSetChecksumInplace(state->rs_buffer, state->rs_blockno);
+		PageSetChecksumInplace(buf, state->rs_blockno);
 
 		RelationOpenSmgr(state->rs_new_rel);
 		smgrextend(state->rs_new_rel->rd_smgr, MAIN_FORKNUM, state->rs_blockno,
-				   (char *) state->rs_buffer, true);
+				   buf, true);
 	}
 
 	/*
@@ -676,6 +700,9 @@ raw_heap_insert(RewriteState state, HeapTuple tup)
 
 		if (len + saveFreeSpace > pageFreeSpace)
 		{
+			char	*buf = (char *) page;
+			XLogRecPtr	lsn = InvalidXLogRecPtr;
+
 			/*
 			 * Doesn't fit, so write out the existing page.  It always
 			 * contains a tuple.  Hence, unlike RelationGetBufferForTuple(),
@@ -684,11 +711,16 @@ raw_heap_insert(RewriteState state, HeapTuple tup)
 
 			/* XLOG stuff */
 			if (RelationNeedsWAL(state->rs_new_rel))
+			{
 				log_newpage(&state->rs_new_rel->rd_node,
 							MAIN_FORKNUM,
 							state->rs_blockno,
-							page,
+							buf,
 							true);
+				lsn = PageGetLSN(buf);
+			}
+			else if (data_encrypted)
+				lsn = get_lsn_for_encryption();
 
 			/*
 			 * Now write the page. We say skipFsync = true because there's no
@@ -697,10 +729,24 @@ raw_heap_insert(RewriteState state, HeapTuple tup)
 			 */
 			RelationOpenSmgr(state->rs_new_rel);
 
-			PageSetChecksumInplace(page, state->rs_blockno);
+			/*
+			 * Encrypt only if we have valid IV. It should be always except
+			 * when log_newpage() encountered an empty page - it should be
+			 * safe not to encrypt such.
+			 */
+			if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+			{
+				encrypt_page(buf,
+							 encrypt_buf.data,
+							 lsn,
+							 state->rs_blockno);
+
+				buf = encrypt_buf.data;
+			}
 
+			PageSetChecksumInplace(buf, state->rs_blockno);
 			smgrextend(state->rs_new_rel->rd_smgr, MAIN_FORKNUM,
-					   state->rs_blockno, (char *) page, true);
+					   state->rs_blockno, buf, true);
 
 			state->rs_blockno++;
 			state->rs_buffer_valid = false;
@@ -920,7 +966,7 @@ logical_heap_rewrite_flush_mappings(RewriteState state)
 		 * check the above "Logical rewrite support" comment for reasoning.
 		 */
 		written = FileWrite(src->vfd, waldata_start, len, src->off,
-							WAIT_EVENT_LOGICAL_REWRITE_WRITE);
+							WAIT_EVENT_LOGICAL_REWRITE_WRITE, ERROR);
 		if (written != len)
 			ereport(ERROR,
 					(errcode_for_file_access(),
diff --git a/src/backend/access/heap/vacuumlazy.c b/src/backend/access/heap/vacuumlazy.c
index 8aab6e324e..671b2b7b14 100644
--- a/src/backend/access/heap/vacuumlazy.c
+++ b/src/backend/access/heap/vacuumlazy.c
@@ -1197,7 +1197,7 @@ lazy_scan_heap(LVRelState *vacrel, VacuumParams *params, bool aggressive)
 			 * upper-level FSM pages.  Note we have not yet processed blkno.
 			 */
 			FreeSpaceMapVacuumRange(vacrel->rel, next_fsm_block_to_vacuum,
-									blkno);
+									blkno, InvalidXLogRecPtr);
 			next_fsm_block_to_vacuum = blkno;
 
 			/* Report that we are once again scanning the heap */
@@ -1359,6 +1359,9 @@ lazy_scan_heap(LVRelState *vacrel, VacuumParams *params, bool aggressive)
 				if (RelationNeedsWAL(vacrel->rel) &&
 					PageGetLSN(page) == InvalidXLogRecPtr)
 					log_newpage_buffer(buf, true);
+				else if (data_encrypted &&
+						 PageGetLSN(page) == InvalidXLogRecPtr)
+					set_page_lsn_for_encryption(page);
 
 				PageSetAllVisible(page);
 				visibilitymap_set(vacrel->rel, blkno, buf, InvalidXLogRecPtr,
@@ -1416,7 +1419,7 @@ lazy_scan_heap(LVRelState *vacrel, VacuumParams *params, bool aggressive)
 				if (blkno - next_fsm_block_to_vacuum >= VACUUM_FSM_EVERY_PAGES)
 				{
 					FreeSpaceMapVacuumRange(vacrel->rel, next_fsm_block_to_vacuum,
-											blkno);
+											blkno, InvalidXLogRecPtr);
 					next_fsm_block_to_vacuum = blkno;
 				}
 
@@ -1609,7 +1612,8 @@ lazy_scan_heap(LVRelState *vacrel, VacuumParams *params, bool aggressive)
 	 * not there were indexes, and whether or not we bypassed index vacuuming.
 	 */
 	if (blkno > next_fsm_block_to_vacuum)
-		FreeSpaceMapVacuumRange(vacrel->rel, next_fsm_block_to_vacuum, blkno);
+		FreeSpaceMapVacuumRange(vacrel->rel, next_fsm_block_to_vacuum, blkno,
+								InvalidXLogRecPtr);
 
 	/* report all blocks vacuumed */
 	pgstat_progress_update_param(PROGRESS_VACUUM_HEAP_BLKS_VACUUMED, blkno);
@@ -1994,6 +1998,8 @@ retry:
 									 frozen, nfrozen);
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(page);
 
 		END_CRIT_SECTION();
 	}
@@ -2476,6 +2482,8 @@ lazy_vacuum_heap_page(LVRelState *vacrel, BlockNumber blkno, Buffer buffer,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	/*
 	 * End critical section, so we safely can do visibility tests (which
diff --git a/src/backend/access/heap/visibilitymap.c b/src/backend/access/heap/visibilitymap.c
index e198df65d8..373b723c6a 100644
--- a/src/backend/access/heap/visibilitymap.c
+++ b/src/backend/access/heap/visibilitymap.c
@@ -3,7 +3,8 @@
  * visibilitymap.c
  *	  bitmap for tracking visibility of heap tuples
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -288,8 +289,11 @@ visibilitymap_set(Relation rel, BlockNumber heapBlk, Buffer heapBuf,
 				/*
 				 * If data checksums are enabled (or wal_log_hints=on), we
 				 * need to protect the heap page from being torn.
+				 *
+				 * For the encryption case, new recptr is needed so that
+				 * different IV is used for the next encryption.
 				 */
-				if (XLogHintBitIsNeeded())
+				if (XLogHintBitIsNeeded() || data_encrypted)
 				{
 					Page		heapPage = BufferGetPage(heapBuf);
 
@@ -300,6 +304,18 @@ visibilitymap_set(Relation rel, BlockNumber heapBlk, Buffer heapBuf,
 			}
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			if (XLogRecPtrIsInvalid(recptr))
+			{
+				Page		heapPage = BufferGetPage(heapBuf);
+
+				recptr = get_lsn_for_encryption();
+
+				PageSetLSN(heapPage, recptr);
+			}
+			PageSetLSN(page, recptr);
+		}
 
 		END_CRIT_SECTION();
 	}
@@ -440,9 +456,13 @@ visibilitymap_count(Relation rel, BlockNumber *all_visible, BlockNumber *all_fro
  * If it's InvalidBlockNumber, there is nothing to truncate;
  * otherwise the caller is responsible for calling smgrtruncate()
  * to truncate the visibility map pages.
+ *
+ * Valid recptr is passed iff called during WAL replay, see
+ * visibilitymap_set() for details.
  */
 BlockNumber
-visibilitymap_prepare_truncate(Relation rel, BlockNumber nheapblocks)
+visibilitymap_prepare_truncate(Relation rel, BlockNumber nheapblocks,
+							   XLogRecPtr recptr)
 {
 	BlockNumber newnblocks;
 
@@ -455,6 +475,8 @@ visibilitymap_prepare_truncate(Relation rel, BlockNumber nheapblocks)
 	elog(DEBUG1, "vm_truncate %s %d", RelationGetRelationName(rel), nheapblocks);
 #endif
 
+	Assert(InRecovery || XLogRecPtrIsInvalid(recptr));
+
 	RelationOpenSmgr(rel);
 
 	/*
@@ -520,6 +542,19 @@ visibilitymap_prepare_truncate(Relation rel, BlockNumber nheapblocks)
 		MarkBufferDirty(mapBuffer);
 		if (!InRecovery && RelationNeedsWAL(rel) && XLogHintBitIsNeeded())
 			log_newpage_buffer(mapBuffer, false);
+		else if (data_encrypted)
+		{
+			if (XLogRecPtrIsInvalid(recptr))
+				set_page_lsn_for_encryption(BufferGetPage(mapBuffer));
+			else
+			{
+				/*
+				 * The LSN must be set even during recovery because it's
+				 * used as the encryption IV.
+				 */
+				PageSetLSN(BufferGetPage(mapBuffer), recptr);
+			}
+		}
 
 		END_CRIT_SECTION();
 
@@ -652,8 +687,13 @@ vm_extend(Relation rel, BlockNumber vm_nblocks)
 	/* Now extend the file */
 	while (vm_nblocks_now < vm_nblocks)
 	{
-		PageSetChecksumInplace((Page) pg.data, vm_nblocks_now);
+		/*
+		 * Encryption: invalid LSN means that the page should not be
+		 * encrypted. This is o.k. as the page is still empty.
+		 */
+		Assert(XLogRecPtrIsInvalid(PageGetLSN(pg.data)));
 
+		PageSetChecksumInplace((Page) pg.data, vm_nblocks_now);
 		smgrextend(rel->rd_smgr, VISIBILITYMAP_FORKNUM, vm_nblocks_now,
 				   pg.data, false);
 		vm_nblocks_now++;
diff --git a/src/backend/access/nbtree/nbtdedup.c b/src/backend/access/nbtree/nbtdedup.c
index 1cd1b59ec3..bbc09cd0ef 100644
--- a/src/backend/access/nbtree/nbtdedup.c
+++ b/src/backend/access/nbtree/nbtdedup.c
@@ -264,6 +264,9 @@ _bt_dedup_pass(Relation rel, Buffer buf, Relation heapRel, IndexTuple newitem,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
+
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/nbtree/nbtinsert.c b/src/backend/access/nbtree/nbtinsert.c
index 1241c56239..bf13192199 100644
--- a/src/backend/access/nbtree/nbtinsert.c
+++ b/src/backend/access/nbtree/nbtinsert.c
@@ -3,7 +3,8 @@
  * nbtinsert.c
  *	  Item insertion in Lehman and Yao btrees for Postgres.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -1392,6 +1393,16 @@ _bt_insertonpg(Relation rel,
 
 			PageSetLSN(page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			if (BufferIsValid(metabuf))
+				PageSetLSN(metapg, recptr);
+			if (!isleaf)
+				PageSetLSN(BufferGetPage(cbuf), recptr);
+			PageSetLSN(page, recptr);
+		}
 
 		END_CRIT_SECTION();
 
@@ -2057,6 +2068,17 @@ _bt_split(Relation rel, BTScanInsert itup_key, Buffer buf, Buffer cbuf,
 		if (!isleaf)
 			PageSetLSN(BufferGetPage(cbuf), recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(origpage, recptr);
+		PageSetLSN(rightpage, recptr);
+		if (!isrightmost)
+			PageSetLSN(spage, recptr);
+		if (!isleaf)
+			PageSetLSN(BufferGetPage(cbuf), recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -2585,6 +2607,14 @@ _bt_newroot(Relation rel, Buffer lbuf, Buffer rbuf)
 		PageSetLSN(rootpage, recptr);
 		PageSetLSN(metapg, recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(lpage, recptr);
+		PageSetLSN(rootpage, recptr);
+		PageSetLSN(metapg, recptr);
+	}
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/nbtree/nbtpage.c b/src/backend/access/nbtree/nbtpage.c
index ebec8fa5b8..28c97852be 100644
--- a/src/backend/access/nbtree/nbtpage.c
+++ b/src/backend/access/nbtree/nbtpage.c
@@ -4,7 +4,8 @@
  *	  BTree-specific page management code for the Postgres btree access
  *	  method.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -307,9 +308,10 @@ _bt_set_cleanup_info(Relation rel, BlockNumber num_delpages)
 
 		PageSetLSN(metapg, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(metapg);
 
 	END_CRIT_SECTION();
-
 	_bt_relbuf(rel, metabuf);
 }
 
@@ -497,6 +499,8 @@ _bt_getroot(Relation rel, int access)
 			PageSetLSN(rootpage, recptr);
 			PageSetLSN(metapg, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption2(rootpage, metapg);
 
 		END_CRIT_SECTION();
 
@@ -1264,6 +1268,8 @@ _bt_delitems_vacuum(Relation rel, Buffer buf,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -1381,6 +1387,8 @@ _bt_delitems_delete(Relation rel, Buffer buf, TransactionId latestRemovedXid,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -2267,6 +2275,9 @@ _bt_mark_page_halfdead(Relation rel, Buffer leafbuf, BTStack stack)
 		page = BufferGetPage(leafbuf);
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption2(BufferGetPage(subtreeparent),
+									 BufferGetPage(leafbuf));
 
 	END_CRIT_SECTION();
 
@@ -2700,6 +2711,27 @@ _bt_unlink_halfdead_page(Relation rel, Buffer leafbuf, BlockNumber scanblkno,
 			PageSetLSN(page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		if (BufferIsValid(metabuf))
+			PageSetLSN(metapg, recptr);
+		page = BufferGetPage(rbuf);
+		PageSetLSN(page, recptr);
+		page = BufferGetPage(buf);
+		PageSetLSN(page, recptr);
+		if (BufferIsValid(lbuf))
+		{
+			page = BufferGetPage(lbuf);
+			PageSetLSN(page, recptr);
+		}
+		if (target != leafblkno)
+		{
+			page = BufferGetPage(leafbuf);
+			PageSetLSN(page, recptr);
+		}
+	}
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/nbtree/nbtree.c b/src/backend/access/nbtree/nbtree.c
index 1360ab80c1..87e79a090e 100644
--- a/src/backend/access/nbtree/nbtree.c
+++ b/src/backend/access/nbtree/nbtree.c
@@ -8,7 +8,8 @@
  *	  This file contains only the public interface routines.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -163,6 +164,7 @@ btbuildempty(Relation index)
 	 * this even when wal_level=minimal.
 	 */
 	PageSetChecksumInplace(metapage, BTREE_METAPAGE);
+	/* Encryption: no-op, the page has no LSN (i.e. IV) yet. */
 	smgrwrite(index->rd_smgr, INIT_FORKNUM, BTREE_METAPAGE,
 			  (char *) metapage, true);
 	log_newpage(&index->rd_smgr->smgr_rnode.node, INIT_FORKNUM,
diff --git a/src/backend/access/nbtree/nbtsearch.c b/src/backend/access/nbtree/nbtsearch.c
index fdf0e5654a..13d493dd9b 100644
--- a/src/backend/access/nbtree/nbtsearch.c
+++ b/src/backend/access/nbtree/nbtsearch.c
@@ -4,7 +4,8 @@
  *	  Search code for postgres btrees.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
diff --git a/src/backend/access/nbtree/nbtsort.c b/src/backend/access/nbtree/nbtsort.c
index 78f78e7341..bdc19ab3dd 100644
--- a/src/backend/access/nbtree/nbtsort.c
+++ b/src/backend/access/nbtree/nbtsort.c
@@ -34,7 +34,8 @@
  * This code isn't concerned about the FSM at all. The caller is responsible
  * for initializing that.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -637,6 +638,9 @@ _bt_blnewpage(uint32 level)
 static void
 _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 {
+	char	*buf;
+	XLogRecPtr	lsn = InvalidXLogRecPtr;
+
 	/* Ensure rd_smgr is open (could have been closed by relcache flush!) */
 	RelationOpenSmgr(wstate->index);
 
@@ -645,7 +649,10 @@ _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 	{
 		/* We use the XLOG_FPI record type for this */
 		log_newpage(&wstate->index->rd_node, MAIN_FORKNUM, blkno, page, true);
+		lsn = PageGetLSN(page);
 	}
+	else if (data_encrypted)
+		lsn = get_lsn_for_encryption();
 
 	/*
 	 * If we have to write pages nonsequentially, fill in the space with
@@ -658,14 +665,36 @@ _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 	{
 		if (!wstate->btws_zeropage)
 			wstate->btws_zeropage = (Page) palloc0(BLCKSZ);
+
 		/* don't set checksum for all-zero page */
+		/*
+		 * Encryption: no need to enforce LSN, all-zero page won't be
+		 * encrypted anyway.
+		 */
 		smgrextend(wstate->index->rd_smgr, MAIN_FORKNUM,
 				   wstate->btws_pages_written++,
 				   (char *) wstate->btws_zeropage,
 				   true);
 	}
 
-	PageSetChecksumInplace(page, blkno);
+	buf = (char *) page;
+
+	/*
+	 * Encrypt only if we have valid IV. It should be always except when
+	 * log_newpage() encountered an empty page - it should be safe not to
+	 * encrypt such one.
+	 */
+	if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+	{
+		encrypt_page(buf,
+					 encrypt_buf.data,
+					 lsn,
+					 blkno);
+
+		buf = encrypt_buf.data;
+	}
+
+	PageSetChecksumInplace(buf, blkno);
 
 	/*
 	 * Now write the page.  There's no need for smgr to schedule an fsync for
@@ -674,15 +703,13 @@ _bt_blwritepage(BTWriteState *wstate, Page page, BlockNumber blkno)
 	if (blkno == wstate->btws_pages_written)
 	{
 		/* extending the file... */
-		smgrextend(wstate->index->rd_smgr, MAIN_FORKNUM, blkno,
-				   (char *) page, true);
+		smgrextend(wstate->index->rd_smgr, MAIN_FORKNUM, blkno, buf, true);
 		wstate->btws_pages_written++;
 	}
 	else
 	{
 		/* overwriting a block we zero-filled before */
-		smgrwrite(wstate->index->rd_smgr, MAIN_FORKNUM, blkno,
-				  (char *) page, true);
+		smgrwrite(wstate->index->rd_smgr, MAIN_FORKNUM, blkno, buf, true);
 	}
 
 	pfree(page);
diff --git a/src/backend/access/spgist/spgdoinsert.c b/src/backend/access/spgist/spgdoinsert.c
index 70557bcf3d..af8a5e4d35 100644
--- a/src/backend/access/spgist/spgdoinsert.c
+++ b/src/backend/access/spgist/spgdoinsert.c
@@ -4,7 +4,8 @@
  *	  implementation of insert algorithm
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -315,6 +316,15 @@ addLeafTuple(Relation index, SpGistState *state, SpGistLeafTuple leafTuple,
 			PageSetLSN(parent->page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(current->page, recptr);
+
+		if (xlrec.offnumParent != InvalidOffsetNumber)
+			PageSetLSN(parent->page, recptr);
+	}
 
 	END_CRIT_SECTION();
 }
@@ -548,6 +558,14 @@ moveLeafs(Relation index, SpGistState *state,
 		PageSetLSN(npage, recptr);
 		PageSetLSN(parent->page, recptr);
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(current->page, recptr);
+		PageSetLSN(npage, recptr);
+		PageSetLSN(parent->page, recptr);
+	}
 
 	END_CRIT_SECTION();
 
@@ -1433,6 +1451,31 @@ doPickSplit(Relation index, SpGistState *state,
 			PageSetLSN(parent->page, recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		if (newLeafBuffer != InvalidBuffer)
+		{
+			Page		page = BufferGetPage(newLeafBuffer);
+
+			PageSetLSN(page, recptr);
+		}
+
+		if (saveCurrent.buffer != InvalidBuffer)
+		{
+			Page		page = BufferGetPage(saveCurrent.buffer);
+
+			PageSetLSN(page, recptr);
+		}
+
+		PageSetLSN(current->page, recptr);
+
+		if (parent->buffer != InvalidBuffer)
+		{
+			PageSetLSN(parent->page, recptr);
+		}
+	}
 
 	END_CRIT_SECTION();
 
@@ -1567,6 +1610,8 @@ spgAddNodeAction(Relation index, SpGistState *state,
 
 			PageSetLSN(current->page, recptr);
 		}
+		else if (data_encrypted)
+			set_page_lsn_for_encryption(current->page);
 
 		END_CRIT_SECTION();
 	}
@@ -1694,6 +1739,14 @@ spgAddNodeAction(Relation index, SpGistState *state,
 			PageSetLSN(parent->page, recptr);
 			PageSetLSN(saveCurrent.page, recptr);
 		}
+		else if (data_encrypted)
+		{
+			XLogRecPtr	recptr = get_lsn_for_encryption();
+
+			PageSetLSN(current->page, recptr);
+			PageSetLSN(parent->page, recptr);
+			PageSetLSN(saveCurrent.page, recptr);
+		}
 
 		END_CRIT_SECTION();
 
@@ -1891,6 +1944,15 @@ spgSplitNodeAction(Relation index, SpGistState *state,
 			PageSetLSN(BufferGetPage(newBuffer), recptr);
 		}
 	}
+	else if (data_encrypted)
+	{
+		XLogRecPtr	recptr = get_lsn_for_encryption();
+
+		PageSetLSN(current->page, recptr);
+
+		if (newBuffer != InvalidBuffer)
+			PageSetLSN(BufferGetPage(newBuffer), recptr);
+	}
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/access/spgist/spginsert.c b/src/backend/access/spgist/spginsert.c
index 1af0af7da2..dcb5d9b08d 100644
--- a/src/backend/access/spgist/spginsert.c
+++ b/src/backend/access/spgist/spginsert.c
@@ -5,7 +5,8 @@
  *
  * All the actual insertion logic is in spgdoinsert.c.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -141,6 +142,8 @@ spgbuild(Relation heap, Relation index, IndexInfo *indexInfo)
 						  0, RelationGetNumberOfBlocks(index),
 						  true);
 	}
+	else if (data_encrypted)
+		newpage_range_set_lsn(index, 0, RelationGetNumberOfBlocks(index));
 
 	result = (IndexBuildResult *) palloc0(sizeof(IndexBuildResult));
 	result->heap_tuples = reltuples;
@@ -169,6 +172,14 @@ spgbuildempty(Relation index)
 	 * replayed.
 	 */
 	PageSetChecksumInplace(page, SPGIST_METAPAGE_BLKNO);
+	/*
+	 * On encryption: LSN is used as the encryption IV, but all the three
+	 * pages created here have initially invalid LSN. Since no user data will
+	 * be written so far, it doesn't seem worth the complexity to generate
+	 * either regular or fake LSN (depending on relperistence) and to encrypt
+	 * the pages before they are logged. Let's just leave them unencrypted
+	 * until any data is added to the index.
+	 */
 	smgrwrite(index->rd_smgr, INIT_FORKNUM, SPGIST_METAPAGE_BLKNO,
 			  (char *) page, true);
 	log_newpage(&index->rd_smgr->smgr_rnode.node, INIT_FORKNUM,
diff --git a/src/backend/access/spgist/spgvacuum.c b/src/backend/access/spgist/spgvacuum.c
index 76fb0374c4..cc6f87178a 100644
--- a/src/backend/access/spgist/spgvacuum.c
+++ b/src/backend/access/spgist/spgvacuum.c
@@ -394,6 +394,8 @@ vacuumLeafPage(spgBulkDeleteState *bds, Relation index, Buffer buffer,
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
@@ -475,6 +477,8 @@ vacuumLeafRoot(spgBulkDeleteState *bds, Relation index, Buffer buffer)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
@@ -600,6 +604,8 @@ vacuumRedirectAndPlaceholder(Relation index, Buffer buffer)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 }
diff --git a/src/backend/access/transam/generic_xlog.c b/src/backend/access/transam/generic_xlog.c
index 63301a1ab1..7d0c1e781d 100644
--- a/src/backend/access/transam/generic_xlog.c
+++ b/src/backend/access/transam/generic_xlog.c
@@ -332,7 +332,7 @@ GenericXLogRegisterBuffer(GenericXLogState *state, Buffer buffer, int flags)
 XLogRecPtr
 GenericXLogFinish(GenericXLogState *state)
 {
-	XLogRecPtr	lsn;
+	XLogRecPtr	lsn = InvalidXLogRecPtr;
 	int			i;
 
 	if (state->isLogged)
@@ -411,6 +411,9 @@ GenericXLogFinish(GenericXLogState *state)
 	}
 	else
 	{
+		if (data_encrypted)
+			lsn = get_lsn_for_encryption();
+
 		/* Unlogged relation: skip xlog-related stuff */
 		START_CRIT_SECTION();
 		for (i = 0; i < MAX_GENERIC_XLOG_PAGES; i++)
@@ -419,10 +422,15 @@ GenericXLogFinish(GenericXLogState *state)
 
 			if (BufferIsInvalid(pageData->buffer))
 				continue;
+
+			/* We don't worry about zeroing the "hole" in this case */
 			memcpy(BufferGetPage(pageData->buffer),
 				   pageData->image,
 				   BLCKSZ);
-			/* We don't worry about zeroing the "hole" in this case */
+
+			if (data_encrypted)
+				PageSetLSN(BufferGetPage(pageData->buffer), lsn);
+
 			MarkBufferDirty(pageData->buffer);
 		}
 		END_CRIT_SECTION();
diff --git a/src/backend/access/transam/xlog.c b/src/backend/access/transam/xlog.c
index 134a6481b9..b9d6248f90 100644
--- a/src/backend/access/transam/xlog.c
+++ b/src/backend/access/transam/xlog.c
@@ -4,7 +4,8 @@
  *		PostgreSQL write-ahead log manager
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/backend/access/transam/xlog.c
@@ -61,6 +62,7 @@
 #include "replication/walreceiver.h"
 #include "replication/walsender.h"
 #include "storage/bufmgr.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
 #include "storage/large_object.h"
@@ -83,6 +85,7 @@
 #include "utils/timestamp.h"
 
 extern uint32 bootstrap_data_checksum_version;
+extern char *bootstrap_encryption_sample;
 
 /* Unsupported old recovery command file names (relative to $PGDATA) */
 #define RECOVERY_COMMAND_FILE	"recovery.conf"
@@ -920,6 +923,7 @@ static void CreateEndOfRecoveryRecord(void);
 static XLogRecPtr CreateOverwriteContrecordRecord(XLogRecPtr aborted_lsn);
 static void CheckPointGuts(XLogRecPtr checkPointRedo, int flags);
 static void KeepLogSeg(XLogRecPtr recptr, XLogSegNo *logSegNo);
+static Size XLogWritePages(char *from, int npages, uint32 startoffset);
 static XLogRecPtr XLogGetReplicationSlotMinimumLSN(void);
 
 static void AdvanceXLInsertBuffer(XLogRecPtr upto, bool opportunistic);
@@ -2556,64 +2560,70 @@ XLogWrite(XLogwrtRqst WriteRqst, bool flexible)
 			finishing_seg)
 		{
 			char	   *from;
-			Size		nbytes;
-			Size		nleft;
-			int			written;
-			instr_time	start;
 
 			/* OK to write the page(s) */
 			from = XLogCtl->pages + startidx * (Size) XLOG_BLCKSZ;
-			nbytes = npages * (Size) XLOG_BLCKSZ;
-			nleft = nbytes;
-			do
+			if (data_encrypted)
 			{
-				errno = 0;
-
-				/* Measure I/O timing to write WAL data */
-				if (track_wal_io_timing)
-					INSTR_TIME_SET_CURRENT(start);
-
-				pgstat_report_wait_start(WAIT_EVENT_WAL_WRITE);
-				written = pg_pwrite(openLogFile, from, nleft, startoffset);
-				pgstat_report_wait_end();
+				int			i,
+							nencrypted;
+				char	   *to;
+				uint32		encr_offset;
 
 				/*
-				 * Increment the I/O timing and the number of times WAL data
-				 * were written out to disk.
+				 * Encrypt and write multiple pages at a time, in order to
+				 * reduce the number of syscalls.
 				 */
-				if (track_wal_io_timing)
+				nencrypted = 0;
+				to = encrypt_buf_xlog;
+				encr_offset = startoffset;
+				for (i = 1; i <= npages; i++)
 				{
-					instr_time	duration;
+					char		tweak[TWEAK_SIZE];
+					Size		nbytes;
 
-					INSTR_TIME_SET_CURRENT(duration);
-					INSTR_TIME_SUBTRACT(duration, start);
-					WalStats.m_wal_write_time += INSTR_TIME_GET_MICROSEC(duration);
-				}
-
-				WalStats.m_wal_write++;
+					XLogEncryptionTweak(tweak, ThisTimeLineID, openLogSegNo, encr_offset);
 
-				if (written <= 0)
-				{
-					char		xlogfname[MAXFNAMELEN];
-					int			save_errno;
-
-					if (errno == EINTR)
-						continue;
+					/*
+					 * We should not encrypt the unused space, in order to
+					 * avoid "reused key attack".
+					 */
+					if (i == npages && ispartialpage)
+						nbytes = WriteRqst.Write % XLOG_BLCKSZ;
+					else
+						nbytes = XLOG_BLCKSZ;
+
+					encrypt_block(from,
+								  to,
+								  nbytes,
+								  tweak,
+								  InvalidXLogRecPtr,
+								  InvalidBlockNumber,
+								  EDK_REL_WAL);
+					nencrypted++;
+					from += XLOG_BLCKSZ;
+					to += XLOG_BLCKSZ;
+					encr_offset += XLOG_BLCKSZ;
 
-					save_errno = errno;
-					XLogFileName(xlogfname, ThisTimeLineID, openLogSegNo,
-								 wal_segment_size);
-					errno = save_errno;
-					ereport(PANIC,
-							(errcode_for_file_access(),
-							 errmsg("could not write to log file %s "
-									"at offset %u, length %zu: %m",
-									xlogfname, startoffset, nleft)));
+					/*
+					 * Write the encrypted data if the encryption buffer is
+					 * full or if the last page has been encrypted.
+					 */
+					if (nencrypted >= XLOG_ENCRYPT_BUF_PAGES || i >= npages)
+					{
+						startoffset += XLogWritePages(encrypt_buf_xlog,
+													  nencrypted,
+													  startoffset);
+
+						/* Prepare for the next round of page encryptions. */
+						nencrypted = 0;
+						to = encrypt_buf_xlog;
+						encr_offset = startoffset;
+					}
 				}
-				nleft -= written;
-				from += written;
-				startoffset += written;
-			} while (nleft > 0);
+			}
+			else
+				startoffset += XLogWritePages(from, npages, startoffset);
 
 			npages = 0;
 
@@ -2730,6 +2740,75 @@ XLogWrite(XLogwrtRqst WriteRqst, bool flexible)
 	}
 }
 
+/*
+ * Write page(s) to the XLOG file.
+ *
+ * Returns the number of bytes written.
+ */
+static Size
+XLogWritePages(char *from, int npages, uint32 startoffset)
+{
+	Size		nbytes,
+				nleft;
+	Size		written;
+	instr_time	start;
+
+	nbytes = npages * (Size) XLOG_BLCKSZ;
+	nleft = nbytes;
+	do
+	{
+		errno = 0;
+
+		/* Measure I/O timing to write WAL data */
+		if (track_wal_io_timing)
+			INSTR_TIME_SET_CURRENT(start);
+
+		pgstat_report_wait_start(WAIT_EVENT_WAL_WRITE);
+		written = pg_pwrite(openLogFile, from, nleft, startoffset);
+		pgstat_report_wait_end();
+
+		/*
+		 * Increment the I/O timing and the number of times WAL data
+		 * were written out to disk.
+		 */
+		if (track_wal_io_timing)
+		{
+			instr_time	duration;
+
+			INSTR_TIME_SET_CURRENT(duration);
+			INSTR_TIME_SUBTRACT(duration, start);
+			WalStats.m_wal_write_time += INSTR_TIME_GET_MICROSEC(duration);
+		}
+
+		WalStats.m_wal_write++;
+
+		if (written <= 0)
+		{
+			char	xlogfname[MAXFNAMELEN];
+			int		save_errno;
+
+			if (errno == EINTR)
+				continue;
+
+			save_errno = errno;
+			XLogFileName(xlogfname, ThisTimeLineID, openLogSegNo,
+						 wal_segment_size);
+			errno = save_errno;
+			ereport(PANIC,
+					(errcode_for_file_access(),
+					 errmsg("could not write to log file %s "
+							"at offset %u, length %zu: %m",
+							xlogfname,
+							startoffset, nbytes)));
+		}
+		nleft -= written;
+		from += written;
+		startoffset += written;
+	} while (nleft > 0);
+
+	return written;
+}
+
 /*
  * Record the LSN for an asynchronous transaction commit/abort
  * and nudge the WALWriter if there is work for it to do.
@@ -3580,6 +3659,35 @@ XLogFileCopy(XLogSegNo destsegno, TimeLineID srcTLI, XLogSegNo srcsegno,
 			}
 			pgstat_report_wait_end();
 		}
+
+		/*
+		 * Since timeline is being changed and since encryption tweak contains
+		 * the timeline, we need to decrypt the buffer and encrypt it with the
+		 * new tweak. Do not encrypt the unused space, in order to avoid
+		 * "reused key attack".
+		 */
+		if (data_encrypted && nread > 0)
+		{
+			char		tweak[TWEAK_SIZE];
+
+			XLogEncryptionTweak(tweak, srcTLI, srcsegno, nbytes);
+			decrypt_block(buffer.data,
+						  buffer.data,
+						  nread,
+						  tweak,
+						  InvalidBlockNumber,
+						  EDK_REL_WAL);
+
+			XLogEncryptionTweak(tweak, ThisTimeLineID, destsegno, nbytes);
+			encrypt_block(buffer.data,
+						  buffer.data,
+						  nread,
+						  tweak,
+						  InvalidXLogRecPtr,
+						  InvalidBlockNumber,
+						  EDK_REL_WAL);
+		}
+
 		errno = 0;
 		pgstat_report_wait_start(WAIT_EVENT_WAL_COPY_WRITE);
 		if ((int) write(fd, buffer.data, sizeof(buffer)) != (int) sizeof(buffer))
@@ -4973,6 +5081,32 @@ ReadControlFile(void)
 		ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
 						errmsg("\"max_wal_size\" must be at least twice \"wal_segment_size\"")));
 
+	/*
+	 * Initialize encryption, but not if the current backend has already done
+	 * that.
+	 */
+	if (DATA_CIPHER_GET_KIND(ControlFile->data_cipher) != PG_CIPHER_NONE &&
+		!data_encrypted)
+	{
+		/* Save the data cipher. */
+		data_cipher = ControlFile->data_cipher;
+
+		/*
+		 * Set data_encryption for caller to know that he needs to retrieve
+		 * the key and initialize the encryption context.
+		 */
+		SetConfigOption("data_encryption", "true", PGC_INTERNAL,
+						PGC_S_OVERRIDE);
+
+		/*
+		 * Save the verification string. We'll perform the actual verification
+		 * as soon as the encryption setup is done.
+		 */
+		memcpy(encryption_verification,
+			   ControlFile->encryption_verification,
+			   ENCRYPTION_SAMPLE_SIZE);
+	}
+
 	UsableBytesInSegment =
 		(wal_segment_size / XLOG_BLCKSZ * UsableBytesInPage) -
 		(SizeOfXLogLongPHD - SizeOfXLogShortPHD);
@@ -5390,6 +5524,20 @@ BootStrapXLOG(void)
 	use_existent = false;
 	openLogFile = XLogFileInit(1, &use_existent, false);
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, ThisTimeLineID, 1, 0);
+		encrypt_block((char *) page,
+					  (char *) page,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidXLogRecPtr,
+					  InvalidBlockNumber,
+					  EDK_REL_WAL);
+	}
+
 	/*
 	 * We needn't bother with Reserve/ReleaseExternalFD here, since we'll
 	 * close the file again in a moment.
@@ -5429,6 +5577,27 @@ BootStrapXLOG(void)
 	ControlFile->checkPoint = checkPoint.redo;
 	ControlFile->checkPointCopy = checkPoint;
 
+	if (data_encrypted)
+	{
+		char	sample[ENCRYPTION_SAMPLE_SIZE];
+
+		/* The bootstrap process should have initialized data_cipher. */
+		Assert(DATA_CIPHER_GET_KIND(data_cipher) != PG_CIPHER_NONE);
+		ControlFile->data_cipher = data_cipher;
+
+		sample_encryption(sample);
+
+		memcpy(ControlFile->encryption_verification, sample,
+			   ENCRYPTION_SAMPLE_SIZE);
+	}
+	else
+	{
+		DATA_CIPHER_CLEAR(data_cipher);
+		ControlFile->data_cipher = data_cipher;
+		memset(ControlFile->encryption_verification, 0,
+			   ENCRYPTION_SAMPLE_SIZE);
+	}
+
 	/* some additional ControlFile fields are set in WriteControlFile() */
 	WriteControlFile();
 
@@ -12514,6 +12683,19 @@ retry:
 
 	xlogreader->seg.ws_tli = curFileTLI;
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, curFileTLI, readSegNo, readOff);
+		decrypt_block(readBuf,
+					  readBuf,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_REL_WAL);
+	}
+
 	/*
 	 * Check the page header immediately, so that we can retry immediately if
 	 * it's not valid. This may seem unnecessary, because XLogReadRecord()
diff --git a/src/backend/access/transam/xloginsert.c b/src/backend/access/transam/xloginsert.c
index b153fad594..7a039479ab 100644
--- a/src/backend/access/transam/xloginsert.c
+++ b/src/backend/access/transam/xloginsert.c
@@ -1192,6 +1192,56 @@ log_newpage_range(Relation rel, ForkNumber forkNum,
 	}
 }
 
+/*
+ * Set fake LSN to pages which log_newpage_range would WAL-log if the relation
+ * was persistent and if encryption was disabled.
+ *
+ * This is for encryption because we uses LSN to construct the encryption IV.
+ */
+void
+newpage_range_set_lsn(Relation rel, BlockNumber startblk, BlockNumber endblk)
+{
+	BlockNumber blkno;
+	XLogRecPtr	recptr;
+
+	if (!data_encrypted)
+		return;
+
+	recptr = get_lsn_for_encryption();
+	blkno = startblk;
+	while (blkno < endblk)
+	{
+		Buffer		buf = ReadBuffer(rel, blkno);
+
+		CHECK_FOR_INTERRUPTS();
+
+		START_CRIT_SECTION();
+
+		LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE);
+
+		/*
+		 * Completely empty pages are not encrypted.
+		 */
+		if (!PageIsNew(BufferGetPage(buf)))
+		{
+			MarkBufferDirty(buf);
+			PageSetLSN(BufferGetPage(buf), recptr);
+		}
+#ifdef USE_ASSERT_CHECKING
+		else
+		{
+			Assert(XLogRecPtrIsInvalid(PageGetLSN(BufferGetPage(buf))));
+
+		}
+#endif	/* USE_ASSERT_CHECKING */
+		UnlockReleaseBuffer(buf);
+
+		END_CRIT_SECTION();
+
+		blkno++;
+	}
+}
+
 /*
  * Allocate working buffers needed for WAL record construction.
  */
diff --git a/src/backend/access/transam/xlogreader.c b/src/backend/access/transam/xlogreader.c
index d797d9d508..2821073a36 100644
--- a/src/backend/access/transam/xlogreader.c
+++ b/src/backend/access/transam/xlogreader.c
@@ -3,7 +3,8 @@
  * xlogreader.c
  *		Generic XLog reading facility
  *
- * Portions Copyright (c) 2013-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2020-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 2013-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *		src/backend/access/transam/xlogreader.c
@@ -1079,6 +1080,26 @@ err:
 
 #endif							/* FRONTEND */
 
+static int
+WALReadBuffer(WALOpenSegment *seg, char *buf, int nbytes, int startoff)
+{
+	int			readbytes;
+
+#ifndef FRONTEND
+	pgstat_report_wait_start(WAIT_EVENT_WAL_READ);
+#endif
+
+	/* Reset errno first; eases reporting non-errno-affecting errors */
+	errno = 0;
+	readbytes = pg_pread(seg->ws_file, buf, nbytes, (off_t) startoff);
+
+#ifndef FRONTEND
+	pgstat_report_wait_end();
+#endif
+
+	return readbytes;
+}
+
 /*
  * Helper function to ease writing of XLogRoutine->page_read callbacks.
  * If this function is used, caller must supply a segment_open callback in
@@ -1096,7 +1117,7 @@ err:
 bool
 WALRead(XLogReaderState *state,
 		char *buf, XLogRecPtr startptr, Size count, TimeLineID tli,
-		WALReadError *errinfo)
+		WALReadError *errinfo, bool decrypt)
 {
 	char	   *p;
 	XLogRecPtr	recptr;
@@ -1110,7 +1131,7 @@ WALRead(XLogReaderState *state,
 	{
 		uint32		startoff;
 		int			segbytes;
-		int			readbytes;
+		int			readbytes, readbytes_last;
 
 		startoff = XLogSegmentOffset(recptr, state->segcxt.ws_segsize);
 
@@ -1139,32 +1160,115 @@ WALRead(XLogReaderState *state,
 			state->seg.ws_segno = nextSegNo;
 		}
 
+		/* Caller should not request decryption of unencrypted data. */
+		Assert(!(decrypt && !data_encrypted));
+
 		/* How many bytes are within this segment? */
 		if (nbytes > (state->segcxt.ws_segsize - startoff))
 			segbytes = state->segcxt.ws_segsize - startoff;
 		else
 			segbytes = nbytes;
 
-#ifndef FRONTEND
-		pgstat_report_wait_start(WAIT_EVENT_WAL_READ);
-#endif
+		if (data_encrypted && decrypt)
+		{
+			int			pageoff = startoff % XLOG_BLCKSZ;
+			uint32		pagebase = startoff - pageoff;
+			int			bufbytes,
+						bufend,
+						i;
+			char		tweak[TWEAK_SIZE];
 
-		/* Reset errno first; eases reporting non-errno-affecting errors */
-		errno = 0;
-		readbytes = pg_pread(state->seg.ws_file, p, segbytes, (off_t) startoff);
+			/*
+			 * Only accept as much data as can fit into the buffer.
+			 */
+			if (segbytes > (ENCRYPT_BUF_XLOG_SIZE - pageoff))
+				bufbytes = ENCRYPT_BUF_XLOG_SIZE - pageoff;
+			else
+				bufbytes = segbytes;
+			bufend = pageoff + bufbytes;
 
-#ifndef FRONTEND
-		pgstat_report_wait_end();
-#endif
+			/*
+			 * Read the data, including the leading part of the page which
+			 * caller is not interested in (this is not included in
+			 * bufbytes). The tweak we passed to encrypt_block() for
+			 * encryption was for the beginning of the block, so it'd be hard
+			 * to start decryption anywhere else.
+			 */
+			readbytes = 0;
+			while (readbytes < bufend)
+			{
+				readbytes_last = WALReadBuffer(&state->seg,
+											   encrypt_buf_xlog + readbytes,
+											   bufend - readbytes,
+											   pagebase + readbytes);
 
-		if (readbytes <= 0)
+				if (readbytes_last <= 0)
+				{
+					errinfo->wre_errno = errno;
+					errinfo->wre_req = bufend - readbytes;
+					errinfo->wre_read = readbytes_last;
+					errinfo->wre_off = pagebase + readbytes;
+					errinfo->wre_seg = state->seg;
+					return false;
+				}
+
+				readbytes += readbytes_last;
+			}
+
+			/*
+			 * Decrypt the data one page at a time (the tweak is only valid
+			 * for particular page).
+			 */
+			for (i = 0; i < readbytes; i += XLOG_BLCKSZ)
+			{
+				Size		nencrypt;
+
+				XLogEncryptionTweak(tweak,
+									state->seg.ws_tli,
+									state->seg.ws_segno,
+									pagebase + i);
+
+				/*
+				 * If the last page is not complete, only decrypt the used
+				 * part.
+				 */
+				if ((bufend - i) < XLOG_BLCKSZ)
+					nencrypt = bufend - i;
+				else
+					nencrypt = XLOG_BLCKSZ;
+
+				decrypt_block(encrypt_buf_xlog + i,
+							  encrypt_buf_xlog + i,
+							  nencrypt,
+							  tweak,
+							  InvalidBlockNumber,
+							  EDK_REL_WAL);
+			}
+
+			/*
+			 * Caller does not care that we possibly had to read pageoff bytes
+			 * in addition (because we cannot decrypt trailing part of the
+			 * page alone). This overhead must not affect the accounting.
+			 */
+			readbytes = bufbytes;
+
+			/* Copy the data to the output buffer. */
+			memcpy(p, encrypt_buf_xlog + pageoff, bufbytes);
+		}
+		else
 		{
-			errinfo->wre_errno = errno;
-			errinfo->wre_req = segbytes;
-			errinfo->wre_read = readbytes;
-			errinfo->wre_off = startoff;
-			errinfo->wre_seg = state->seg;
-			return false;
+			readbytes_last = WALReadBuffer(&state->seg, p, segbytes, startoff);
+
+			if (readbytes_last <= 0)
+			{
+				errinfo->wre_errno = errno;
+				errinfo->wre_req = segbytes;
+				errinfo->wre_read = readbytes_last;
+				errinfo->wre_off = startoff;
+				errinfo->wre_seg = state->seg;
+				return false;
+			}
+			readbytes = readbytes_last;
 		}
 
 		/* Update state for read */
diff --git a/src/backend/access/transam/xlogutils.c b/src/backend/access/transam/xlogutils.c
index d17d660f46..fb014bed9b 100644
--- a/src/backend/access/transam/xlogutils.c
+++ b/src/backend/access/transam/xlogutils.c
@@ -8,7 +8,8 @@
  * None of this code is used during normal system operation.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/backend/access/transam/xlogutils.c
@@ -940,7 +941,7 @@ read_local_xlog_page(XLogReaderState *state, XLogRecPtr targetPagePtr,
 	 * zero-padded up to the page boundary if it's incomplete.
 	 */
 	if (!WALRead(state, cur_page, targetPagePtr, XLOG_BLCKSZ, tli,
-				 &errinfo))
+				 &errinfo, data_encrypted))
 		WALReadRaiseError(&errinfo);
 
 	/* number of valid bytes in the buffer */
diff --git a/src/backend/bootstrap/bootstrap.c b/src/backend/bootstrap/bootstrap.c
index 94ab5ca095..8695ec0a26 100644
--- a/src/backend/bootstrap/bootstrap.c
+++ b/src/backend/bootstrap/bootstrap.c
@@ -4,7 +4,8 @@
  *	  routines to support running postgres in 'bootstrap' mode
  *	bootstrap mode is used to create the initial template database
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -41,6 +42,7 @@
 #include "storage/bufmgr.h"
 #include "storage/bufpage.h"
 #include "storage/condition_variable.h"
+#include "storage/encryption.h"
 #include "storage/ipc.h"
 #include "storage/proc.h"
 #include "tcop/tcopprot.h"
@@ -56,6 +58,7 @@ uint32		bootstrap_data_checksum_version = 0;	/* No checksum */
 
 static void CheckerModeMain(void);
 static void BootstrapModeMain(void);
+static int bootstrap_getc(void);
 static void bootstrap_signals(void);
 static void ShutdownAuxiliaryProcess(int code, Datum arg);
 static Form_pg_attribute AllocateAttribute(void);
@@ -225,7 +228,7 @@ AuxiliaryProcessMain(int argc, char *argv[])
 	/* If no -x argument, we are a CheckerProcess */
 	MyAuxProcType = CheckerProcess;
 
-	while ((flag = getopt(argc, argv, "B:c:d:D:Fkr:x:X:-:")) != -1)
+	while ((flag = getopt(argc, argv, "B:c:d:D:FkKr:x:X:-:")) != -1)
 	{
 		switch (flag)
 		{
@@ -251,6 +254,22 @@ AuxiliaryProcessMain(int argc, char *argv[])
 			case 'F':
 				SetConfigOption("fsync", "false", PGC_POSTMASTER, PGC_S_ARGV);
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				/*
+				 * When auxiliary process (bootstrap) starts, the control file
+				 * does not exist yet, so command line option needs to be used
+				 * to indicate that the encryption is enabled.
+				 *
+				 * Postmaster should not pass this option. Instead, it just
+				 * sets data_encrypted according to the control file and child
+				 * processes inherit that.
+				 */
+				Assert(!IsUnderPostmaster);
+				data_encrypted = true;
+
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'k':
 				bootstrap_data_checksum_version = PG_DATA_CHECKSUM_VERSION;
 				break;
@@ -367,6 +386,34 @@ AuxiliaryProcessMain(int argc, char *argv[])
 	if (!IsUnderPostmaster)
 		InitializeMaxBackends();
 
+	/*
+	 * If data_encryption is set because of command line option, do the setup
+	 * now.
+	 *
+	 * This should only be useful for the bootstrap process. Anyone else
+	 * detects the encryption via ReadControlFile().
+	 */
+	if (data_encrypted && MyAuxProcType == BootstrapProcess)
+	{
+		int		key_length;
+
+		Assert(!IsUnderPostmaster);
+
+		/* Read the key from stdin. */
+		key_length = read_encryption_key(bootstrap_getc, NULL);
+
+		/*
+		 * User of the auxiliary process (typically initdb) should have
+		 * checked that the command returns a key of valid length. Thus we
+		 * don't need an extra command line option for it.
+		 */
+		Assert(key_length == 16 || key_length == 24 || key_length == 32);
+
+		DATA_CIPHER_SET(data_cipher, PG_CIPHER_AES_CTR_CBC, key_length);
+
+		setup_encryption();
+	}
+
 	BaseInit();
 
 	/*
@@ -546,6 +593,16 @@ BootstrapModeMain(void)
  * ----------------------------------------------------------------
  */
 
+/*
+ * Read a single character from stdin. This is a callback for
+ * read_encryption_key().
+ */
+static int
+bootstrap_getc(void)
+{
+	return getc(stdin);
+}
+
 /*
  * Set up signal handling for a bootstrap process
  */
diff --git a/src/backend/catalog/storage.c b/src/backend/catalog/storage.c
index b7fc491a68..c8ab496dce 100644
--- a/src/backend/catalog/storage.c
+++ b/src/backend/catalog/storage.c
@@ -3,6 +3,7 @@
  * storage.c
  *	  code to create and destroy physical storage for relations
  *
+ * Portions Copyright (c) 2022, CYBERTEC PostgreSQL International GmbH
  * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -302,7 +303,8 @@ RelationTruncate(Relation rel, BlockNumber nblocks)
 	fsm = smgrexists(rel->rd_smgr, FSM_FORKNUM);
 	if (fsm)
 	{
-		blocks[nforks] = FreeSpaceMapPrepareTruncateRel(rel, nblocks);
+		blocks[nforks] = FreeSpaceMapPrepareTruncateRel(rel, nblocks,
+														InvalidXLogRecPtr);
 		if (BlockNumberIsValid(blocks[nforks]))
 		{
 			forks[nforks] = FSM_FORKNUM;
@@ -315,7 +317,8 @@ RelationTruncate(Relation rel, BlockNumber nblocks)
 	vm = smgrexists(rel->rd_smgr, VISIBILITYMAP_FORKNUM);
 	if (vm)
 	{
-		blocks[nforks] = visibilitymap_prepare_truncate(rel, nblocks);
+		blocks[nforks] = visibilitymap_prepare_truncate(rel, nblocks,
+														InvalidXLogRecPtr);
 		if (BlockNumberIsValid(blocks[nforks]))
 		{
 			forks[nforks] = VISIBILITYMAP_FORKNUM;
@@ -399,7 +402,8 @@ RelationTruncate(Relation rel, BlockNumber nblocks)
 	 * possibility of corruption after a crash anyway.
 	 */
 	if (need_fsm_vacuum)
-		FreeSpaceMapVacuumRange(rel, nblocks, InvalidBlockNumber);
+		FreeSpaceMapVacuumRange(rel, nblocks, InvalidBlockNumber,
+								InvalidXLogRecPtr);
 }
 
 /*
@@ -465,13 +469,28 @@ RelationCopyStorage(SMgrRelation src, SMgrRelation dst,
 
 	for (blkno = 0; blkno < nblocks; blkno++)
 	{
+		char	*buf_read, *buf_dst;
+		Page	page_encr = NULL;
+		XLogRecPtr	lsn;
+
 		/* If we got a cancel signal during the copy of the data, quit */
 		CHECK_FOR_INTERRUPTS();
 
-		smgrread(src, forkNum, blkno, buf.data);
+		if (!data_encrypted)
+			buf_read = buf.data;
+		else
+			buf_read = encrypt_buf.data;
+
+		smgrread(src, forkNum, blkno, buf_read);
 
+		if (data_encrypted)
+		{
+			decrypt_page(buf_read, buf.data, blkno);
+			page_encr = buf_read;
+		}
 		if (!PageIsVerifiedExtended(page, blkno,
-									PIV_LOG_WARNING | PIV_REPORT_STAT))
+									PIV_LOG_WARNING | PIV_REPORT_STAT,
+									page_encr))
 			ereport(ERROR,
 					(errcode(ERRCODE_DATA_CORRUPTED),
 					 errmsg("invalid page in block %u of relation %s",
@@ -486,16 +505,38 @@ RelationCopyStorage(SMgrRelation src, SMgrRelation dst,
 		 * space.
 		 */
 		if (use_wal)
+		{
 			log_newpage(&dst->smgr_rnode.node, forkNum, blkno, page, false);
+			lsn = PageGetLSN(page);
+		}
+		else if (data_encrypted)
+			lsn = get_lsn_for_encryption();
+
+		buf_dst = (char *) page;
+
+		/*
+		 * Encrypt only if we have valid IV. It should be always except when
+		 * log_newpage() encountered an empty page - it should be safe not to
+		 * encrypt such.
+		 */
+		if (data_encrypted && !XLogRecPtrIsInvalid(lsn))
+		{
+			encrypt_page(buf_dst,
+						 encrypt_buf.data,
+						 lsn,
+						 blkno);
+
+			buf_dst = encrypt_buf.data;
+		}
 
-		PageSetChecksumInplace(page, blkno);
+		PageSetChecksumInplace(buf_dst, blkno);
 
 		/*
 		 * Now write the page.  We say skipFsync = true because there's no
 		 * need for smgr to schedule an fsync for this write; we'll do it
 		 * ourselves below.
 		 */
-		smgrextend(dst, forkNum, blkno, buf.data, true);
+		smgrextend(dst, forkNum, blkno, buf_dst, true);
 	}
 
 	/*
@@ -998,7 +1039,8 @@ smgr_redo(XLogReaderState *record)
 		if ((xlrec->flags & SMGR_TRUNCATE_FSM) != 0 &&
 			smgrexists(reln, FSM_FORKNUM))
 		{
-			blocks[nforks] = FreeSpaceMapPrepareTruncateRel(rel, xlrec->blkno);
+			blocks[nforks] = FreeSpaceMapPrepareTruncateRel(rel, xlrec->blkno,
+															lsn);
 			if (BlockNumberIsValid(blocks[nforks]))
 			{
 				forks[nforks] = FSM_FORKNUM;
@@ -1009,7 +1051,8 @@ smgr_redo(XLogReaderState *record)
 		if ((xlrec->flags & SMGR_TRUNCATE_VM) != 0 &&
 			smgrexists(reln, VISIBILITYMAP_FORKNUM))
 		{
-			blocks[nforks] = visibilitymap_prepare_truncate(rel, xlrec->blkno);
+			blocks[nforks] = visibilitymap_prepare_truncate(rel, xlrec->blkno,
+															lsn);
 			if (BlockNumberIsValid(blocks[nforks]))
 			{
 				forks[nforks] = VISIBILITYMAP_FORKNUM;
@@ -1028,7 +1071,8 @@ smgr_redo(XLogReaderState *record)
 		 */
 		if (need_fsm_vacuum)
 			FreeSpaceMapVacuumRange(rel, xlrec->blkno,
-									InvalidBlockNumber);
+									InvalidBlockNumber,
+									lsn);
 
 		FreeFakeRelcacheEntry(rel);
 	}
diff --git a/src/backend/commands/sequence.c b/src/backend/commands/sequence.c
index 98649986e1..03f783f2fb 100644
--- a/src/backend/commands/sequence.c
+++ b/src/backend/commands/sequence.c
@@ -415,6 +415,8 @@ fill_seq_with_data(Relation rel, HeapTuple tuple)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	END_CRIT_SECTION();
 
@@ -819,6 +821,8 @@ nextval_internal(Oid relid, bool check_permissions)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(page);
 
 	/* Now update sequence tuple to the intended final state */
 	seq->last_value = last;		/* last fetched number */
@@ -1014,6 +1018,8 @@ do_setval(Oid relid, int64 next, bool iscalled)
 
 		PageSetLSN(page, recptr);
 	}
+	else if (data_encrypted)
+		set_page_lsn_for_encryption(BufferGetPage(buf));
 
 	END_CRIT_SECTION();
 
diff --git a/src/backend/postmaster/pgstat.c b/src/backend/postmaster/pgstat.c
index a2f75b23b8..d31736be02 100644
--- a/src/backend/postmaster/pgstat.c
+++ b/src/backend/postmaster/pgstat.c
@@ -11,7 +11,8 @@
  *			- Add a pgstat config column to pg_database, so this
  *			  entire thing can be enabled/disabled on a per db basis.
  *
- *	Copyright (c) 2001-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2001-2022, PostgreSQL Global Development Group
  *
  *	src/backend/postmaster/pgstat.c
  * ----------
@@ -54,6 +55,7 @@
 #include "replication/slot.h"
 #include "replication/walsender.h"
 #include "storage/backendid.h"
+#include "storage/buffile.h"
 #include "storage/dsm.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
@@ -310,8 +312,12 @@ static PgStat_StatTabEntry *pgstat_get_tab_entry(PgStat_StatDBEntry *dbentry,
 												 Oid tableoid, bool create);
 static void pgstat_write_statsfiles(bool permanent, bool allDbs);
 static void pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent);
+static void pgstat_write_bytes(TransientBufFile *file, void *ptr, size_t size,
+							   bool *failed);
 static HTAB *pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep);
 static void pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash, bool permanent);
+static void pgstat_read_bytes(TransientBufFile *file, void *ptr, size_t size,
+							  bool *failed);
 static void backend_read_statsfile(void);
 
 static bool pgstat_write_statsfile_needed(void);
@@ -3202,6 +3208,9 @@ PgstatCollectorMain(int argc, char *argv[])
 	MyBackendType = B_STATS_COLLECTOR;
 	init_ps_display(NULL);
 
+	/* BufFileOpenTransient() and friends do use VFD. */
+	InitFileAccess();
+
 	/*
 	 * Read in existing stats files or initialize the stats to zero.
 	 */
@@ -3595,7 +3604,6 @@ pgstat_get_tab_entry(PgStat_StatDBEntry *dbentry, Oid tableoid, bool create)
 	return result;
 }
 
-
 /* ----------
  * pgstat_write_statsfiles() -
  *		Write the global statistics file, as well as requested DB files.
@@ -3615,18 +3623,21 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 {
 	HASH_SEQ_STATUS hstat;
 	PgStat_StatDBEntry *dbentry;
-	FILE	   *fpout;
+	TransientBufFile	   *fpout;
+	File	vfd;
 	int32		format_id;
 	const char *tmpfile = permanent ? PGSTAT_STAT_PERMANENT_TMPFILE : pgstat_stat_tmpname;
 	const char *statfile = permanent ? PGSTAT_STAT_PERMANENT_FILENAME : pgstat_stat_filename;
-	int			rc;
+	bool	failed = false;
 
 	elog(DEBUG2, "writing stats file \"%s\"", statfile);
 
 	/*
 	 * Open the statistics temp file to write out the current values.
 	 */
-	fpout = AllocateFile(tmpfile, PG_BINARY_W);
+	fpout = BufFileOpenTransient(tmpfile,
+								 O_CREAT | O_WRONLY | O_APPEND | PG_BINARY,
+								 WARNING);
 	if (fpout == NULL)
 	{
 		ereport(LOG,
@@ -3645,32 +3656,27 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 	 * Write the file header --- currently just a format ID.
 	 */
 	format_id = PGSTAT_FILE_FORMAT_ID;
-	rc = fwrite(&format_id, sizeof(format_id), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &format_id, sizeof(format_id), &failed);
 
 	/*
 	 * Write global stats struct
 	 */
-	rc = fwrite(&globalStats, sizeof(globalStats), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &globalStats, sizeof(globalStats), &failed);
 
 	/*
 	 * Write archiver stats struct
 	 */
-	rc = fwrite(&archiverStats, sizeof(archiverStats), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &archiverStats, sizeof(archiverStats), &failed);
 
 	/*
 	 * Write WAL stats struct
 	 */
-	rc = fwrite(&walStats, sizeof(walStats), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &walStats, sizeof(walStats), &failed);
 
 	/*
 	 * Write SLRU stats struct
 	 */
-	rc = fwrite(slruStats, sizeof(slruStats), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, slruStats, sizeof(slruStats), &failed);
 
 	/*
 	 * Walk through the database table.
@@ -3694,9 +3700,11 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 		 * Write out the DB entry. We don't write the tables or functions
 		 * pointers, since they're of no use to any other process.
 		 */
-		fputc('D', fpout);
-		rc = fwrite(dbentry, offsetof(PgStat_StatDBEntry, tables), 1, fpout);
-		(void) rc;				/* we'll check for error with ferror */
+		pgstat_write_bytes(fpout, "D", 1, &failed);
+		pgstat_write_bytes(fpout,
+						   dbentry,
+						   offsetof(PgStat_StatDBEntry, tables),
+						   &failed);
 	}
 
 	/*
@@ -3709,29 +3717,36 @@ pgstat_write_statsfiles(bool permanent, bool allDbs)
 		hash_seq_init(&hstat, replSlotStatHash);
 		while ((slotent = (PgStat_StatReplSlotEntry *) hash_seq_search(&hstat)) != NULL)
 		{
-			fputc('R', fpout);
-			rc = fwrite(slotent, sizeof(PgStat_StatReplSlotEntry), 1, fpout);
-			(void) rc;			/* we'll check for error with ferror */
+			pgstat_write_bytes(fpout, "R", 1, &failed);
+			pgstat_write_bytes(fpout, slotent, sizeof(PgStat_StatReplSlotEntry),
+							   &failed);
 		}
 	}
 
 	/*
 	 * No more output to be done. Close the temp file and replace the old
-	 * pgstat.stat with it.  The ferror() check replaces testing for error
-	 * after each individual fputc or fwrite above.
+	 * pgstat.stat with it.
 	 */
-	fputc('E', fpout);
+	pgstat_write_bytes(fpout, "E", 1, &failed);
 
-	if (ferror(fpout))
+	if (failed)
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
 				 errmsg("could not write temporary statistics file \"%s\": %m",
 						tmpfile)));
-		FreeFile(fpout);
+		BufFileCloseTransient(fpout);
 		unlink(tmpfile);
+		return;
 	}
-	else if (FreeFile(fpout) < 0)
+
+	/*
+	 * XXX This might PANIC, see FileClose(). Don't we need special behaviour
+	 * for statistics?
+	 */
+	vfd = BufFileTransientGetVfd(fpout);
+	BufFileCloseTransient(fpout);
+	if (!FileIsClosed(vfd))
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
@@ -3796,12 +3811,13 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	HASH_SEQ_STATUS fstat;
 	PgStat_StatTabEntry *tabentry;
 	PgStat_StatFuncEntry *funcentry;
-	FILE	   *fpout;
+	TransientBufFile	   *fpout;
+	File	vfd;
 	int32		format_id;
 	Oid			dbid = dbentry->databaseid;
-	int			rc;
 	char		tmpfile[MAXPGPATH];
 	char		statfile[MAXPGPATH];
+	bool	failed = false;
 
 	get_dbstat_filename(permanent, true, dbid, tmpfile, MAXPGPATH);
 	get_dbstat_filename(permanent, false, dbid, statfile, MAXPGPATH);
@@ -3811,7 +3827,9 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	/*
 	 * Open the statistics temp file to write out the current values.
 	 */
-	fpout = AllocateFile(tmpfile, PG_BINARY_W);
+	fpout = BufFileOpenTransient(tmpfile,
+								 O_CREAT | O_WRONLY | O_APPEND | PG_BINARY,
+								 WARNING);
 	if (fpout == NULL)
 	{
 		ereport(LOG,
@@ -3825,8 +3843,7 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	 * Write the file header --- currently just a format ID.
 	 */
 	format_id = PGSTAT_FILE_FORMAT_ID;
-	rc = fwrite(&format_id, sizeof(format_id), 1, fpout);
-	(void) rc;					/* we'll check for error with ferror */
+	pgstat_write_bytes(fpout, &format_id, sizeof(format_id), &failed);
 
 	/*
 	 * Walk through the database's access stats per table.
@@ -3834,9 +3851,14 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	hash_seq_init(&tstat, dbentry->tables);
 	while ((tabentry = (PgStat_StatTabEntry *) hash_seq_search(&tstat)) != NULL)
 	{
-		fputc('T', fpout);
-		rc = fwrite(tabentry, sizeof(PgStat_StatTabEntry), 1, fpout);
-		(void) rc;				/* we'll check for error with ferror */
+		pgstat_write_bytes(fpout, "T", 1, &failed);
+		if (failed)
+			break;
+
+		pgstat_write_bytes(fpout, tabentry, sizeof(PgStat_StatTabEntry),
+						   &failed);
+		if (failed)
+			break;
 	}
 
 	/*
@@ -3845,28 +3867,42 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	hash_seq_init(&fstat, dbentry->functions);
 	while ((funcentry = (PgStat_StatFuncEntry *) hash_seq_search(&fstat)) != NULL)
 	{
-		fputc('F', fpout);
-		rc = fwrite(funcentry, sizeof(PgStat_StatFuncEntry), 1, fpout);
-		(void) rc;				/* we'll check for error with ferror */
+		pgstat_write_bytes(fpout, "F", 1, &failed);
+		if (failed)
+			break;
+
+		pgstat_write_bytes(fpout,
+						   funcentry,
+						   sizeof(PgStat_StatFuncEntry),
+						   &failed);
+		if (failed)
+			break;
 	}
 
 	/*
 	 * No more output to be done. Close the temp file and replace the old
-	 * pgstat.stat with it.  The ferror() check replaces testing for error
-	 * after each individual fputc or fwrite above.
+	 * pgstat.stat with it.
 	 */
-	fputc('E', fpout);
+	pgstat_write_bytes(fpout, "E", 1, &failed);
 
-	if (ferror(fpout))
+	if (failed)
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
 				 errmsg("could not write temporary statistics file \"%s\": %m",
 						tmpfile)));
-		FreeFile(fpout);
+		BufFileCloseTransient(fpout);
 		unlink(tmpfile);
+		return;
 	}
-	else if (FreeFile(fpout) < 0)
+
+	/*
+	 * XXX This might PANIC, see FileClose(). Don't we need special behaviour
+	 * for statistics?
+	 */
+	vfd = BufFileTransientGetVfd(fpout);
+	BufFileCloseTransient(fpout);
+	if (!FileIsClosed(vfd))
 	{
 		ereport(LOG,
 				(errcode_for_file_access(),
@@ -3892,6 +3928,25 @@ pgstat_write_db_statsfile(PgStat_StatDBEntry *dbentry, bool permanent)
 	}
 }
 
+/*
+ * Convenience routine to write data to file and check for errors.
+ */
+static void
+pgstat_write_bytes(TransientBufFile *file, void *ptr, size_t size,
+	bool *failed)
+{
+	/* Do nothing if any previous write failed. */
+	if (*failed)
+		return;
+
+	/*
+	 * Use BufFileWriteTransient() because it handles encryption
+	 * transparently.
+	 */
+	if (BufFileWriteTransient(file, ptr, size) != size)
+		*failed = true;
+}
+
 /* ----------
  * pgstat_read_statsfiles() -
  *
@@ -3919,10 +3974,11 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	PgStat_StatDBEntry dbbuf;
 	HASHCTL		hash_ctl;
 	HTAB	   *dbhash;
-	FILE	   *fpin;
+	TransientBufFile *fpin;
 	int32		format_id;
 	bool		found;
 	const char *statfile = permanent ? PGSTAT_STAT_PERMANENT_FILENAME : pgstat_stat_filename;
+	bool	failed = false;
 	int			i;
 
 	/*
@@ -3971,7 +4027,9 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	 * not yet written the stats file the first time.  Any other failure
 	 * condition is suspicious.
 	 */
-	if ((fpin = AllocateFile(statfile, PG_BINARY_R)) == NULL)
+	if ((fpin = BufFileOpenTransient(statfile,
+									 O_RDONLY | PG_BINARY,
+									 WARNING)) == NULL)
 	{
 		if (errno != ENOENT)
 			ereport(pgStatRunningInCollector ? LOG : WARNING,
@@ -3984,8 +4042,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Verify it's of the expected format.
 	 */
-	if (fread(&format_id, 1, sizeof(format_id), fpin) != sizeof(format_id) ||
-		format_id != PGSTAT_FILE_FORMAT_ID)
+	pgstat_read_bytes(fpin, &format_id, sizeof(format_id), &failed);
+	if (failed || format_id != PGSTAT_FILE_FORMAT_ID)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -3995,7 +4053,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Read global stats struct
 	 */
-	if (fread(&globalStats, 1, sizeof(globalStats), fpin) != sizeof(globalStats))
+	pgstat_read_bytes(fpin, &globalStats, sizeof(globalStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -4016,7 +4075,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Read archiver stats struct
 	 */
-	if (fread(&archiverStats, 1, sizeof(archiverStats), fpin) != sizeof(archiverStats))
+	pgstat_read_bytes(fpin, &archiverStats, sizeof(archiverStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -4027,7 +4087,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Read WAL stats struct
 	 */
-	if (fread(&walStats, 1, sizeof(walStats), fpin) != sizeof(walStats))
+	pgstat_read_bytes(fpin, &walStats, sizeof(walStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -4038,7 +4099,8 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	/*
 	 * Read SLRU stats struct
 	 */
-	if (fread(slruStats, 1, sizeof(slruStats), fpin) != sizeof(slruStats))
+	pgstat_read_bytes(fpin, &slruStats, sizeof(slruStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -4052,15 +4114,22 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	 */
 	for (;;)
 	{
-		switch (fgetc(fpin))
+		char	c;
+
+		pgstat_read_bytes(fpin, &c, 1, &failed);
+
+		switch (c)
 		{
 				/*
 				 * 'D'	A PgStat_StatDBEntry struct describing a database
 				 * follows.
 				 */
 			case 'D':
-				if (fread(&dbbuf, 1, offsetof(PgStat_StatDBEntry, tables),
-						  fpin) != offsetof(PgStat_StatDBEntry, tables))
+				pgstat_read_bytes(fpin,
+								  &dbbuf,
+								  offsetof(PgStat_StatDBEntry, tables),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -4144,8 +4213,10 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 					PgStat_StatReplSlotEntry slotbuf;
 					PgStat_StatReplSlotEntry *slotent;
 
-					if (fread(&slotbuf, 1, sizeof(PgStat_StatReplSlotEntry), fpin)
-						!= sizeof(PgStat_StatReplSlotEntry))
+					pgstat_read_bytes(fpin, &slotbuf,
+									  sizeof(PgStat_StatReplSlotEntry),
+									  &failed);
+					if (failed)
 					{
 						ereport(pgStatRunningInCollector ? LOG : WARNING,
 								(errmsg("corrupted statistics file \"%s\"",
@@ -4186,7 +4257,7 @@ pgstat_read_statsfiles(Oid onlydb, bool permanent, bool deep)
 	}
 
 done:
-	FreeFile(fpin);
+	BufFileCloseTransient(fpin);
 
 	/* If requested to read the permanent file, also get rid of it. */
 	if (permanent)
@@ -4221,10 +4292,11 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	PgStat_StatTabEntry tabbuf;
 	PgStat_StatFuncEntry funcbuf;
 	PgStat_StatFuncEntry *funcentry;
-	FILE	   *fpin;
+	TransientBufFile	   *fpin;
 	int32		format_id;
 	bool		found;
 	char		statfile[MAXPGPATH];
+	bool	failed = false;
 
 	get_dbstat_filename(permanent, false, databaseid, statfile, MAXPGPATH);
 
@@ -4237,7 +4309,9 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	 * not yet written the stats file the first time.  Any other failure
 	 * condition is suspicious.
 	 */
-	if ((fpin = AllocateFile(statfile, PG_BINARY_R)) == NULL)
+	if ((fpin = BufFileOpenTransient(statfile,
+									 O_RDONLY | PG_BINARY,
+									 WARNING)) == NULL)
 	{
 		if (errno != ENOENT)
 			ereport(pgStatRunningInCollector ? LOG : WARNING,
@@ -4250,8 +4324,8 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	/*
 	 * Verify it's of the expected format.
 	 */
-	if (fread(&format_id, 1, sizeof(format_id), fpin) != sizeof(format_id) ||
-		format_id != PGSTAT_FILE_FORMAT_ID)
+	pgstat_read_bytes(fpin, &format_id, sizeof(format_id), &failed);
+	if (failed || format_id != PGSTAT_FILE_FORMAT_ID)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
@@ -4264,14 +4338,19 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	 */
 	for (;;)
 	{
-		switch (fgetc(fpin))
+		char	c;
+
+		pgstat_read_bytes(fpin, &c, 1, &failed);
+
+		switch (c)
 		{
 				/*
 				 * 'T'	A PgStat_StatTabEntry follows.
 				 */
 			case 'T':
-				if (fread(&tabbuf, 1, sizeof(PgStat_StatTabEntry),
-						  fpin) != sizeof(PgStat_StatTabEntry))
+				pgstat_read_bytes(fpin, &tabbuf, sizeof(PgStat_StatTabEntry),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -4304,8 +4383,11 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 				 * 'F'	A PgStat_StatFuncEntry follows.
 				 */
 			case 'F':
-				if (fread(&funcbuf, 1, sizeof(PgStat_StatFuncEntry),
-						  fpin) != sizeof(PgStat_StatFuncEntry))
+				pgstat_read_bytes(fpin,
+								  &funcbuf,
+								  sizeof(PgStat_StatFuncEntry),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
@@ -4349,7 +4431,7 @@ pgstat_read_db_statsfile(Oid databaseid, HTAB *tabhash, HTAB *funchash,
 	}
 
 done:
-	FreeFile(fpin);
+	BufFileCloseTransient(fpin);
 
 	if (permanent)
 	{
@@ -4386,15 +4468,18 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	PgStat_WalStats myWalStats;
 	PgStat_SLRUStats mySLRUStats[SLRU_NUM_ELEMENTS];
 	PgStat_StatReplSlotEntry myReplSlotStats;
-	FILE	   *fpin;
+	TransientBufFile	   *fpin;
 	int32		format_id;
 	const char *statfile = permanent ? PGSTAT_STAT_PERMANENT_FILENAME : pgstat_stat_filename;
+	bool	failed = false;
 
 	/*
 	 * Try to open the stats file.  As above, anything but ENOENT is worthy of
 	 * complaining about.
 	 */
-	if ((fpin = AllocateFile(statfile, PG_BINARY_R)) == NULL)
+	if ((fpin = BufFileOpenTransient(statfile,
+									 O_RDONLY | PG_BINARY,
+									 WARNING)) == NULL)
 	{
 		if (errno != ENOENT)
 			ereport(pgStatRunningInCollector ? LOG : WARNING,
@@ -4407,58 +4492,62 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	/*
 	 * Verify it's of the expected format.
 	 */
-	if (fread(&format_id, 1, sizeof(format_id), fpin) != sizeof(format_id) ||
-		format_id != PGSTAT_FILE_FORMAT_ID)
+	pgstat_read_bytes(fpin, &format_id, sizeof(format_id), &failed);
+	if (failed || format_id != PGSTAT_FILE_FORMAT_ID)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
 	/*
 	 * Read global stats struct
 	 */
-	if (fread(&myGlobalStats, 1, sizeof(myGlobalStats),
-			  fpin) != sizeof(myGlobalStats))
+	pgstat_read_bytes(fpin, &myGlobalStats, sizeof(myGlobalStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
 	/*
 	 * Read archiver stats struct
 	 */
-	if (fread(&myArchiverStats, 1, sizeof(myArchiverStats),
-			  fpin) != sizeof(myArchiverStats))
+	pgstat_read_bytes(fpin, &myArchiverStats, sizeof(myArchiverStats),
+					  &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
 	/*
 	 * Read WAL stats struct
 	 */
-	if (fread(&myWalStats, 1, sizeof(myWalStats), fpin) != sizeof(myWalStats))
+	pgstat_read_bytes(fpin, &myWalStats, sizeof(myWalStats), &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
 	/*
 	 * Read SLRU stats struct
 	 */
-	if (fread(mySLRUStats, 1, sizeof(mySLRUStats), fpin) != sizeof(mySLRUStats))
+	pgstat_read_bytes(fpin, mySLRUStats, sizeof(mySLRUStats),
+					  &failed);
+	if (failed)
 	{
 		ereport(pgStatRunningInCollector ? LOG : WARNING,
 				(errmsg("corrupted statistics file \"%s\"", statfile)));
-		FreeFile(fpin);
+		BufFileCloseTransient(fpin);
 		return false;
 	}
 
@@ -4471,20 +4560,27 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 	 */
 	for (;;)
 	{
-		switch (fgetc(fpin))
+		char	c;
+
+		pgstat_read_bytes(fpin, &c, 1, &failed);
+
+		switch (c)
 		{
 				/*
 				 * 'D'	A PgStat_StatDBEntry struct describing a database
 				 * follows.
 				 */
 			case 'D':
-				if (fread(&dbentry, 1, offsetof(PgStat_StatDBEntry, tables),
-						  fpin) != offsetof(PgStat_StatDBEntry, tables))
+				pgstat_read_bytes(fpin,
+								  &dbentry,
+								  offsetof(PgStat_StatDBEntry, tables),
+								  &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
 									statfile)));
-					FreeFile(fpin);
+					BufFileCloseTransient(fpin);
 					return false;
 				}
 
@@ -4505,13 +4601,14 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 				 * replication slot follows.
 				 */
 			case 'R':
-				if (fread(&myReplSlotStats, 1, sizeof(PgStat_StatReplSlotEntry), fpin)
-					!= sizeof(PgStat_StatReplSlotEntry))
+				pgstat_read_bytes(fpin, &myReplSlotStats,
+								  sizeof(PgStat_StatReplSlotEntry), &failed);
+				if (failed)
 				{
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
 									statfile)));
-					FreeFile(fpin);
+					BufFileCloseTransient(fpin);
 					return false;
 				}
 				break;
@@ -4524,17 +4621,35 @@ pgstat_read_db_statsfile_timestamp(Oid databaseid, bool permanent,
 					ereport(pgStatRunningInCollector ? LOG : WARNING,
 							(errmsg("corrupted statistics file \"%s\"",
 									statfile)));
-					FreeFile(fpin);
+					BufFileCloseTransient(fpin);
 					return false;
 				}
 		}
 	}
 
 done:
-	FreeFile(fpin);
+	BufFileCloseTransient(fpin);
 	return true;
 }
 
+/*
+ * Convenience routine to read data from file and check for errors.
+ */
+static void
+pgstat_read_bytes(TransientBufFile *file, void *ptr, size_t size,
+	bool *failed)
+{
+	/* Do nothing if any previous read failed. */
+	if (*failed)
+		return;
+
+	/*
+	 * Use BufFileReadTransient() because it handles encryption transparently.
+	 */
+	if (BufFileReadTransient(file, ptr, size) != size)
+		*failed = true;
+}
+
 /*
  * If not already done, read the statistics collector stats file into
  * some hash tables.  The results will be kept until pgstat_clear_snapshot()
diff --git a/src/backend/postmaster/postmaster.c b/src/backend/postmaster/postmaster.c
index db091b9278..728926bf84 100644
--- a/src/backend/postmaster/postmaster.c
+++ b/src/backend/postmaster/postmaster.c
@@ -32,7 +32,8 @@
  *	  clients.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -117,6 +118,7 @@
 #include "postmaster/syslogger.h"
 #include "replication/logicallauncher.h"
 #include "replication/walsender.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
 #include "storage/pg_shmem.h"
@@ -388,6 +390,14 @@ static bool LoadedSSL = false;
 static DNSServiceRef bonjour_sdref = NULL;
 #endif
 
+#ifdef USE_ENCRYPTION
+/* Is the only purpose of this backend to receive encryption key? */
+static bool key_only_backend = false;
+
+/* Has the "key only backend" received an empty key message? */
+static bool got_empty_key_msg = false;
+#endif	/* USE_ENCRYPTION */
+
 /*
  * postmaster.c - function prototypes
  */
@@ -414,11 +424,16 @@ static void PostmasterStateMachine(void);
 static void BackendInitialize(Port *port);
 static void BackendRun(Port *port) pg_attribute_noreturn();
 static void ExitPostmaster(int status) pg_attribute_noreturn();
-static int	ServerLoop(void);
+static int	ServerLoop(bool receive_encryption_key);
+static void ServerLoopCheckTimeouts(void);
 static int	BackendStartup(Port *port);
 static int	ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done);
 static void SendNegotiateProtocolVersion(List *unrecognized_protocol_options);
 static void processCancelRequest(Port *port, void *pkt);
+#ifdef USE_ENCRYPTION
+static bool processEncryptionKeyMessage(void *pkt);
+static void shareEncryptionKey(void);
+#endif	/* USE_ENCRYPTION */
 static int	initMasks(fd_set *rmask);
 static void report_fork_failure_to_client(Port *port, int errnum);
 static CAC_state canAcceptConnections(int backend_type);
@@ -525,6 +540,11 @@ typedef struct
 	bool		query_id_enabled;
 	int			max_safe_fds;
 	int			MaxBackends;
+#ifdef USE_ENCRYPTION
+	bool		data_encrypted;
+	uint8		data_cipher;
+	unsigned char encryption_key[ENCRYPTION_KEY_MAX_LENGTH];
+#endif
 #ifdef WIN32
 	HANDLE		PostmasterHandle;
 	HANDLE		initial_signal_pipe;
@@ -1403,6 +1423,58 @@ PostmasterMain(int argc, char *argv[])
 	 */
 	AddToDataDirLockFile(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);
 
+#ifdef USE_ENCRYPTION
+	/*
+	 * If encryption key is needed and we don't have it yet, call ServerLoop()
+	 * in a restricted mode which allows a client application to send us the
+	 * key. Regular client connections are not allowed yet.
+	 *
+	 * (If encryption_setup_done is true, it probably means that postmaster is
+	 * restarting after crash.)
+	 */
+	if (data_encrypted && !encryption_setup_done)
+	{
+		char	sample[ENCRYPTION_SAMPLE_SIZE];
+		int		key_length = DATA_CIPHER_GET_KEY_LENGTH(data_cipher);
+
+		/*
+		 * If the key command is in the configuration file, just run it,
+		 * otherwise let frontend application deliver it via FE/BE protocol.
+		 */
+		if (encryption_key_command)
+			run_encryption_key_command(DataDir, &key_length);
+		else
+		{
+			status = ServerLoop(true);
+
+			/* No other return code should be seen here. */
+			Assert(status == STATUS_OK);
+
+			if (!encryption_key_shmem->received ||
+				encryption_key_shmem->empty)
+				ereport(FATAL, (errmsg("Encryption key not received.")));
+
+			/*
+			 * Take a local copy of the key so that we don't have to receive
+			 * it again if restarting after a crash.
+			 */
+			memcpy(encryption_key, encryption_key_shmem,
+				   ENCRYPTION_KEY_MAX_LENGTH);
+		}
+
+		/* Finalize the setup. */
+		setup_encryption();
+
+		/* Verify the key. */
+		sample_encryption(sample);
+		if (memcmp(encryption_verification, sample, ENCRYPTION_SAMPLE_SIZE))
+			ereport(FATAL,
+					(errmsg("invalid encryption key"),
+					 errdetail("The passed encryption key does not match"
+							   " database encryption key.")));
+	}
+#endif /* USE_ENCRYPTION */
+
 	/*
 	 * We're ready to rock and roll...
 	 */
@@ -1414,7 +1486,7 @@ PostmasterMain(int argc, char *argv[])
 	/* Some workers may be scheduled to start now */
 	maybe_start_bgworkers();
 
-	status = ServerLoop();
+	status = ServerLoop(false);
 
 	/*
 	 * ServerLoop probably shouldn't ever return, but if it does, close down.
@@ -1652,28 +1724,47 @@ DetermineSleepTime(struct timeval *timeout)
 	}
 }
 
+static time_t		last_lockfile_recheck_time, last_touch_time;
+
+/*
+ * The maximum amount of time postmaster can wait for encryption key if the
+ * cluster is encrypted. It should be shorter than the time pg_ctl waits for
+ * postgres to start (60 seconds) and should not be too long so that failure
+ * to specify encryption key command is recognized soon.
+ */
+#define	MAX_WAIT_FOR_KEY_SECS	20
+
+/* When should waiting for encryption key end. */
+static TimestampTz	wait_for_keys_until = 0;
+
 /*
  * Main idle loop of postmaster
  *
+ * If receive_encryption_key is true, only launch backend(s) to receive
+ * cluster encryption key and return as soon as the key is in shared memory or
+ * MAX_WAIT_FOR_KEY_SECS elapsed.
+ *
  * NB: Needs to be called with signals blocked
  */
 static int
-ServerLoop(void)
+ServerLoop(bool receive_encryption_key)
 {
 	fd_set		readmask;
 	int			nSockets;
-	time_t		last_lockfile_recheck_time,
-				last_touch_time;
 
 	last_lockfile_recheck_time = last_touch_time = time(NULL);
 
+	/* Compute wait_for_keys_until if needed and not done yet. */
+	if (receive_encryption_key && wait_for_keys_until == 0)
+		wait_for_keys_until = PgStartTime +
+			MAX_WAIT_FOR_KEY_SECS * USECS_PER_SEC;
+
 	nSockets = initMasks(&readmask);
 
 	for (;;)
 	{
 		fd_set		rmask;
 		int			selres;
-		time_t		now;
 
 		/*
 		 * Wait for a connection request to arrive.
@@ -1704,6 +1795,27 @@ ServerLoop(void)
 			/* Needs to run with blocked signals! */
 			DetermineSleepTime(&timeout);
 
+			/*
+			 * If waiting for the encryption key, make sure
+			 * MAX_WAIT_FOR_KEY_SECS is not exceeded.
+			 */
+			if (receive_encryption_key)
+			{
+				TimestampTz	timeout_tz, timeout_end;;
+
+				timeout_tz = timeout.tv_sec * USECS_PER_SEC +
+					timeout.tv_usec;
+				timeout_end = GetCurrentTimestamp() + timeout_tz;
+
+				if (timeout_end > wait_for_keys_until)
+				{
+					timeout_tz -= (timeout_end - wait_for_keys_until);
+
+					timeout.tv_sec = timeout_tz / USECS_PER_SEC;
+					timeout.tv_usec = timeout_tz % USECS_PER_SEC;
+				}
+			}
+
 			PG_SETMASK(&UnBlockSig);
 
 			selres = select(nSockets, &rmask, NULL, NULL, &timeout);
@@ -1755,6 +1867,42 @@ ServerLoop(void)
 			}
 		}
 
+		/*
+		 * If only waiting for the encryption key, it's too early to launch
+		 * the other processes.
+		 */
+		if (receive_encryption_key)
+		{
+			/* The regular checks should take place though. */
+			ServerLoopCheckTimeouts();
+
+			/* Done if the key has been delivered. */
+			if (encryption_key_shmem->received)
+			{
+				/*
+				 * Make sure the key is read from main memory again if it had
+				 * been prefetched before processEncryptionKey() could have
+				 * written it there.
+				 */
+				pg_read_barrier();
+
+				return STATUS_OK;
+			}
+
+			/*
+			 * Do not wait for the key forever.
+			 *
+			 * Since pg_ctl sends an "empty key message" if passed no key
+			 * command, we should only get here if the cluster is being
+			 * started using a custom script which failed to send the key.
+			 */
+			if (GetCurrentTimestamp() >= wait_for_keys_until)
+				/* ok here, caller should examine the conditions in detail. */
+				return STATUS_OK;
+
+			continue;
+		}
+
 		/* If we have lost the log collector, try to start a new one */
 		if (SysLoggerPID == 0 && Logging_collector)
 			SysLoggerPID = SysLogger_Start();
@@ -1838,60 +1986,70 @@ ServerLoop(void)
 		 * us sleep at most that long; except for SIGKILL timeout which has
 		 * special-case logic there.
 		 */
-		now = time(NULL);
+		ServerLoopCheckTimeouts();
+	}
+}
 
-		/*
-		 * If we already sent SIGQUIT to children and they are slow to shut
-		 * down, it's time to send them SIGKILL.  This doesn't happen
-		 * normally, but under certain conditions backends can get stuck while
-		 * shutting down.  This is a last measure to get them unwedged.
-		 *
-		 * Note we also do this during recovery from a process crash.
-		 */
-		if ((Shutdown >= ImmediateShutdown || (FatalError && !SendStop)) &&
-			AbortStartTime != 0 &&
-			(now - AbortStartTime) >= SIGKILL_CHILDREN_AFTER_SECS)
-		{
-			/* We were gentle with them before. Not anymore */
-			ereport(LOG,
-					(errmsg("issuing SIGKILL to recalcitrant children")));
-			TerminateChildren(SIGKILL);
-			/* reset flag so we don't SIGKILL again */
-			AbortStartTime = 0;
-		}
+/*
+ * Subroutine of ServerLoop() that checks if various timeouts elapsed, and if
+ * so, takes the appropriate action.
+ */
+static void
+ServerLoopCheckTimeouts(void)
+{
+	time_t		now = time(NULL);
 
-		/*
-		 * Once a minute, verify that postmaster.pid hasn't been removed or
-		 * overwritten.  If it has, we force a shutdown.  This avoids having
-		 * postmasters and child processes hanging around after their database
-		 * is gone, and maybe causing problems if a new database cluster is
-		 * created in the same place.  It also provides some protection
-		 * against a DBA foolishly removing postmaster.pid and manually
-		 * starting a new postmaster.  Data corruption is likely to ensue from
-		 * that anyway, but we can minimize the damage by aborting ASAP.
-		 */
-		if (now - last_lockfile_recheck_time >= 1 * SECS_PER_MINUTE)
-		{
-			if (!RecheckDataDirLockFile())
-			{
-				ereport(LOG,
-						(errmsg("performing immediate shutdown because data directory lock file is invalid")));
-				kill(MyProcPid, SIGQUIT);
-			}
-			last_lockfile_recheck_time = now;
-		}
+	/*
+	 * If we already sent SIGQUIT to children and they are slow to shut down,
+	 * it's time to send them SIGKILL.  This doesn't happen normally, but
+	 * under certain conditions backends can get stuck while shutting down.
+	 * This is a last measure to get them unwedged.
+	 *
+	 * Note we also do this during recovery from a process crash.
+	 */
+	if ((Shutdown >= ImmediateShutdown || (FatalError && !SendStop)) &&
+		AbortStartTime != 0 &&
+		(now - AbortStartTime) >= SIGKILL_CHILDREN_AFTER_SECS)
+	{
+		/* We were gentle with them before. Not anymore */
+		ereport(LOG,
+				(errmsg("issuing SIGKILL to recalcitrant children")));
+		TerminateChildren(SIGKILL);
+		/* reset flag so we don't SIGKILL again */
+		AbortStartTime = 0;
+	}
 
-		/*
-		 * Touch Unix socket and lock files every 58 minutes, to ensure that
-		 * they are not removed by overzealous /tmp-cleaning tasks.  We assume
-		 * no one runs cleaners with cutoff times of less than an hour ...
-		 */
-		if (now - last_touch_time >= 58 * SECS_PER_MINUTE)
+	/*
+	 * Once a minute, verify that postmaster.pid hasn't been removed or
+	 * overwritten.  If it has, we force a shutdown.  This avoids having
+	 * postmasters and child processes hanging around after their database is
+	 * gone, and maybe causing problems if a new database cluster is created
+	 * in the same place.  It also provides some protection against a DBA
+	 * foolishly removing postmaster.pid and manually starting a new
+	 * postmaster.  Data corruption is likely to ensue from that anyway, but
+	 * we can minimize the damage by aborting ASAP.
+	 */
+	if (now - last_lockfile_recheck_time >= 1 * SECS_PER_MINUTE)
+	{
+		if (!RecheckDataDirLockFile())
 		{
-			TouchSocketFiles();
-			TouchSocketLockFiles();
-			last_touch_time = now;
+			ereport(LOG,
+					(errmsg("performing immediate shutdown because data directory lock file is invalid")));
+			kill(MyProcPid, SIGQUIT);
 		}
+		last_lockfile_recheck_time = now;
+	}
+
+	/*
+	 * Touch Unix socket and lock files every 58 minutes, to ensure that they
+	 * are not removed by overzealous /tmp-cleaning tasks.  We assume no one
+	 * runs cleaners with cutoff times of less than an hour ...
+	 */
+	if (now - last_touch_time >= 58 * SECS_PER_MINUTE)
+	{
+		TouchSocketFiles();
+		TouchSocketLockFiles();
+		last_touch_time = now;
 	}
 }
 
@@ -2024,6 +2182,44 @@ ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)
 		return STATUS_ERROR;
 	}
 
+#ifdef USE_ENCRYPTION
+	/*
+	 * Catch the encryption key message even if the cluster is not encrypted:
+	 * pg_ctl can send an empty message if was passed no key, just to let
+	 * postmaster know that it shouldn't wait for the key message (pg_ctl does
+	 * not know whether the cluster is encrypted). If we didn't catch it here,
+	 * this empty message would make the first started backend of the cluster
+	 * complain about "unsupported frontend protocol".
+	 */
+	if (proto == ENCRYPTION_KEY_MSG_CODE)
+	{
+		if (data_encrypted)
+		{
+			if (ssl_done || gss_done)
+				ereport(DEBUG1,
+						(errmsg_internal("receiving encryption key via SSL/GSSAPI")));
+
+			if (processEncryptionKeyMessage(buf))
+			{
+				/* Information to be displayed by init_ps_display(). */
+				port->user_name = pstrdup("<no user>");
+				port->database_name = pstrdup("<no database>");
+
+				/* This backend needs to be run specially. */
+				key_only_backend = true;
+
+				/*
+				 * processEncryptionKey() will finalize the key delivery as
+				 * soon as shared memory can be accessed.
+				 */
+				return STATUS_OK;
+			}
+		}
+
+		return STATUS_ERROR;
+	}
+#endif	/* USE_ENCRYPTION */
+
 	if (proto == NEGOTIATE_SSL_CODE && !ssl_done)
 	{
 		char		SSLok;
@@ -2457,6 +2653,128 @@ processCancelRequest(Port *port, void *pkt)
 					backendPID)));
 }
 
+#ifdef USE_ENCRYPTION
+/*
+ * Process a message from backend that contains the encryption key.
+ *
+ * If valid key message was received, either initialize the encryption_key
+ * variable or set got_empty_key_msg, and return true. In such a case,
+ * shareEncryptionKey() will put the encryption key into shared memory as soon
+ * as it's available or just set a shared memory flag saying that the message
+ * was empty. Return false if the message is invalid or if the current backend
+ * should not receive it.
+ */
+bool
+processEncryptionKeyMessage(void *pkt)
+{
+	EncryptionKeyMsg	*msg = (EncryptionKeyMsg *) pkt;
+
+	/* Backend to receive the key should not be launched otherwise. */
+	Assert(data_encrypted);
+
+	/*
+	 * The checks in shareEncryptionKey() would fire in this case too, but the
+	 * error message is clearer if this case is handled explicitly.
+	 */
+	if (pmState != PM_INIT)
+	{
+		ereport(DEBUG1,
+				(errmsg("postmaster received the encryption key message in state %d",
+						pmState)));
+		return false;
+	}
+
+	if (msg->version != 1)
+	{
+		ereport(COMMERROR,
+				(errmsg("unexpected version of encryption key message %d",
+					msg->version)));
+		return false;
+	}
+
+	/*
+	 * If pg_ctl sent an empty message, the encryption key command should have
+	 * already been read from postgresql.conf and processed.
+	 */
+	if (msg->empty)
+	{
+		got_empty_key_msg = true;
+		return true;
+	}
+
+	memcpy(encryption_key, msg->data, ENCRYPTION_KEY_MAX_LENGTH);
+
+	return true;
+}
+
+/*
+ * Put the contents of encryption_key into shared memory so that postmaster
+ * and its child processes can use it. Caller is responsible for
+ * encryption_key to have been initialized.
+ *
+ * processEncryptionKeyMessage() cannot access shared memory if EXEC_BACKEND
+ * mechanism is used so we split the key transfer into two phases. This is the
+ * second one.
+ *
+ * Currently there's no guarantee that only a single backend tries to deliver
+ * the key, but it's not worth trying to synchronize the access. If multiple
+ * callers try to process the same message, nothing should get broken. If some
+ * caller is delivering a wrong key (e.g. due to misconfiguration of another
+ * cluster), it does not help if it waits until processing of the correct key
+ * is finished.  If the key gets messed up, the worst case is that the server
+ * fails to start up. (No data corruption is expected.)
+ *
+ * To ensure that postmaster does not read the key before it's initialized, we
+ * use a memory barrier, see below.
+ *
+ * Client should not expect any response to this request: failure on client
+ * side indicates either broken connection, wrong key, bug in
+ * send_key_to_postmaster() or repeated call of the client - nothing to be
+ * handled easily by client code. Most of these failures need attention of the
+ * DBA.
+ */
+void
+shareEncryptionKey(void)
+{
+	Assert(key_only_backend);
+
+	if (got_empty_key_msg)
+	{
+		encryption_key_shmem->empty = true;
+		ereport(LOG,
+				(errmsg_internal("empty encryption key message received")));
+	}
+	else
+	{
+		/*
+		 * Check if someone else already initialized the key. This is not
+		 * fatal but seems to indicate misconfiguration which DBA should be
+		 * aware of. Check also encryption_setup_done because shared memory
+		 * could have been reset. As postmaster has a local copy of the key,
+		 * the new key should not be used, but it'd be inconsistent if we
+		 * didn't complain in this special case.
+		 */
+		if (encryption_key_shmem->received || encryption_setup_done)
+		{
+			ereport(COMMERROR,
+					(errmsg("received encryption key more than once")));
+			return;
+		}
+
+		ereport(LOG, (errmsg_internal("encryption key received")));
+		memcpy(encryption_key_shmem->data, encryption_key,
+			   ENCRYPTION_KEY_MAX_LENGTH);
+	}
+
+	/*
+	 * received==true should be a guarantee that the key is in the shared
+	 * memory or that "empty" is set.
+	 */
+	pg_write_barrier();
+	encryption_key_shmem->received = true;
+}
+#endif	/* USE_ENCRYPTION */
+
 /*
  * canAcceptConnections --- check to see if database state allows connections
  * of the specified type.  backend_type can be BACKEND_TYPE_NORMAL,
@@ -2479,7 +2797,14 @@ canAcceptConnections(int backend_type)
 	{
 		if (Shutdown > NoShutdown)
 			return CAC_SHUTDOWN;	/* shutdown is pending */
-		else if (!FatalError && pmState == PM_STARTUP)
+		else if (!FatalError &&
+				 /*
+				  * If the cluster is encrypted, PM_INIT should allow for
+				  * launching a special backend that merely receives the
+				  * encryption key.
+				  */
+				 ((data_encrypted && pmState == PM_INIT) ||
+				  pmState == PM_STARTUP))
 			return CAC_STARTUP; /* normal startup */
 		else if (!FatalError && pmState == PM_RECOVERY)
 			return CAC_NOTCONSISTENT;	/* not yet at consistent recovery
@@ -2828,6 +3153,16 @@ pmdie(SIGNAL_ARGS)
 				/* There should be no clients, so proceed to stop children */
 				pmState = PM_STOP_BACKENDS;
 			}
+			else if (pmState == PM_INIT && data_encrypted &&
+					 !encryption_setup_done)
+			{
+				/*
+				 * Only backends to receive encryption key may be active now,
+				 * and these should not be involved in any transactions.
+				 */
+				SignalSomeChildren(SIGTERM, BACKEND_TYPE_NORMAL);
+				pmState = PM_WAIT_BACKENDS;
+			}
 
 			/*
 			 * Now wait for online backup mode to end and backends to exit. If
@@ -2870,6 +3205,16 @@ pmdie(SIGNAL_ARGS)
 						(errmsg("aborting any active transactions")));
 				pmState = PM_STOP_BACKENDS;
 			}
+			else if (pmState == PM_INIT && data_encrypted &&
+					 !encryption_setup_done)
+			{
+				/*
+				 * Only backends to receive encryption key may be active now,
+				 * and these should not be involved in any transactions.
+				 */
+				SignalSomeChildren(SIGTERM, BACKEND_TYPE_NORMAL);
+				pmState = PM_WAIT_BACKENDS;
+			}
 
 			/*
 			 * PostmasterStateMachine will issue any necessary signals, or
@@ -4185,6 +4530,7 @@ BackendStartup(Port *port)
 {
 	Backend    *bn;				/* for backend cleanup */
 	pid_t		pid;
+	CAC_state	cac;
 
 	/*
 	 * Create backend data structure.  Better before the fork() so we can
@@ -4215,10 +4561,16 @@ BackendStartup(Port *port)
 
 	bn->cancel_key = MyCancelKey;
 
-	/* Pass down canAcceptConnections state */
-	port->canAcceptConnections = canAcceptConnections(BACKEND_TYPE_NORMAL);
+	/*
+	 * Pass down canAcceptConnections state.
+	 *
+	 * The special case of data_encrypted means that we might need special
+	 * backend to receive encryption key.
+	 */
+	cac = port->canAcceptConnections = canAcceptConnections(BACKEND_TYPE_NORMAL);
 	bn->dead_end = (port->canAcceptConnections != CAC_OK &&
-					port->canAcceptConnections != CAC_SUPERUSER);
+					port->canAcceptConnections != CAC_SUPERUSER &&
+					!(data_encrypted && cac == CAC_STARTUP));
 
 	/*
 	 * Unless it's a dead_end child, assign it a child slot number
@@ -4248,6 +4600,18 @@ BackendStartup(Port *port)
 		/* Perform additional initialization and collect startup packet */
 		BackendInitialize(port);
 
+#ifdef USE_ENCRYPTION
+		if (key_only_backend)
+		{
+			/*
+			 * Putting the encryption key into shared memory is the only thing
+			 * we're expected to do.
+			 */
+			shareEncryptionKey();
+			proc_exit(0);
+		}
+#endif	/* USE_ENCRYPTION */
+
 		/* And run the backend */
 		BackendRun(port);
 	}
@@ -5039,6 +5403,23 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores();
 
+#ifdef USE_ENCRYPTION
+		if (key_only_backend)
+		{
+			Assert(data_encrypted);
+
+			/*
+			 * Putting the encryption key into shared memory is the only thing
+			 * we're expected to do.
+			 */
+			shareEncryptionKey();
+			proc_exit(0);
+		}
+
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		/* And run the backend */
 		BackendRun(&port);		/* does not return */
 	}
@@ -5053,6 +5434,11 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores();
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		AuxiliaryProcessMain(argc - 2, argv + 2);	/* does not return */
 	}
 	if (strcmp(argv[1], "--forkavlauncher") == 0)
@@ -5066,6 +5452,12 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores();
 
+		/* XXX Do we need encryption here? */
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		AutoVacLauncherMain(argc - 2, argv + 2);	/* does not return */
 	}
 	if (strcmp(argv[1], "--forkavworker") == 0)
@@ -5079,6 +5471,11 @@ SubPostmasterMain(int argc, char *argv[])
 		/* Attach process to shared data structures */
 		CreateSharedMemoryAndSemaphores();
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		AutoVacWorkerMain(argc - 2, argv + 2);	/* does not return */
 	}
 	if (strncmp(argv[1], "--forkbgworker=", 15) == 0)
@@ -5101,12 +5498,22 @@ SubPostmasterMain(int argc, char *argv[])
 		shmem_slot = atoi(argv[1] + 15);
 		MyBgworkerEntry = BackgroundWorkerEntry(shmem_slot);
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		StartBackgroundWorker();
 	}
 	if (strcmp(argv[1], "--forkcol") == 0)
 	{
 		/* Do not want to attach to shared memory */
 
+#ifdef USE_ENCRYPTION
+		if (data_encrypted)
+			setup_encryption();
+#endif	/* USE_ENCRYPTION */
+
 		PgstatCollectorMain(argc, argv);	/* does not return */
 	}
 	if (strcmp(argv[1], "--forklog") == 0)
@@ -6212,6 +6619,11 @@ save_backend_variables(BackendParameters *param, Port *port,
 	param->max_safe_fds = max_safe_fds;
 
 	param->MaxBackends = MaxBackends;
+#ifdef USE_ENCRYPTION
+	param->data_encrypted = data_encrypted;
+	param->data_cipher = data_cipher;
+	memcpy(param->encryption_key, encryption_key, ENCRYPTION_KEY_MAX_LENGTH);
+#endif
 
 #ifdef WIN32
 	param->PostmasterHandle = PostmasterHandle;
@@ -6447,6 +6859,12 @@ restore_backend_variables(BackendParameters *param, Port *port)
 
 	MaxBackends = param->MaxBackends;
 
+#ifdef USE_ENCRYPTION
+	data_encrypted = param->data_encrypted;
+	data_cipher = param->data_cipher;
+	memcpy(encryption_key, param->encryption_key, ENCRYPTION_KEY_MAX_LENGTH);
+#endif
+
 #ifdef WIN32
 	PostmasterHandle = param->PostmasterHandle;
 	pgwin32_initial_signal_pipe = param->initial_signal_pipe;
diff --git a/src/backend/replication/basebackup.c b/src/backend/replication/basebackup.c
index d142cc2131..6c6df79189 100644
--- a/src/backend/replication/basebackup.c
+++ b/src/backend/replication/basebackup.c
@@ -3,7 +3,8 @@
  * basebackup.c
  *	  code for taking a base backup and streaming it to a standby
  *
- * Portions Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *	  src/backend/replication/basebackup.c
@@ -17,9 +18,12 @@
 #include <time.h>
 
 #include "access/xlog_internal.h"	/* for pg_start/stop_backup */
+#include "catalog/pg_class.h"
+#include "catalog/pg_control.h"
 #include "catalog/pg_type.h"
 #include "common/file_perm.h"
 #include "commands/progress.h"
+#include "common/controldata_utils.h"
 #include "lib/stringinfo.h"
 #include "libpq/libpq.h"
 #include "libpq/pqformat.h"
@@ -68,6 +72,10 @@ static bool sendFile(const char *readfilename, const char *tarfilename,
 					 backup_manifest_info *manifest, const char *spcoid);
 static void sendFileWithContent(const char *filename, const char *content,
 								backup_manifest_info *manifest);
+static void sendFileWithContentGeneric(const char *filename,
+									   const char *content,
+									   backup_manifest_info *manifest,
+									   size_t len, struct stat *statbuf);
 static int64 _tarWriteHeader(const char *filename, const char *linktarget,
 							 struct stat *statbuf, bool sizeonly);
 static int64 _tarWriteDir(const char *pathbuf, int basepathlen, struct stat *statbuf,
@@ -142,6 +150,9 @@ struct exclude_list_item
 	bool		match_prefix;
 };
 
+/* Decrypt relation files and WAL. */
+static bool decrypt = false;
+
 /*
  * The contents of these directories are removed or recreated during server
  * start so they are not included in backups.  The directories themselves are
@@ -240,6 +251,7 @@ static const struct exclude_list_item noChecksumFiles[] = {
 	{"pg_filenode.map", false},
 	{"pg_internal.init", true},
 	{"PG_VERSION", false},
+	{"kdf_params", false},
 #ifdef EXEC_BACKEND
 	{"config_exec_params", true},
 #endif
@@ -264,6 +276,10 @@ perform_base_backup(basebackup_options *opt)
 	int			datadirpathlen;
 	List	   *tablespaces = NIL;
 
+	if (decrypt && !data_encrypted)
+		ereport(NOTICE,
+				(errmsg("decryption requested but the cluster is not encrypted")));
+
 	backup_total = 0;
 	backup_streamed = 0;
 	pgstat_progress_start_command(PROGRESS_COMMAND_BASEBACKUP, InvalidOid);
@@ -438,8 +454,42 @@ perform_base_backup(basebackup_options *opt)
 							(errcode_for_file_access(),
 							 errmsg("could not stat file \"%s\": %m",
 									XLOG_CONTROL_FILE)));
-				sendFile(XLOG_CONTROL_FILE, XLOG_CONTROL_FILE, &statbuf,
-						 false, InvalidOid, &manifest, NULL);
+
+				/*
+				 * Adjust control file if the backup is not encrypted.
+				 */
+				if (decrypt && data_encrypted)
+				{
+					ControlFileData	*cfile;
+					char *cfile_raw;
+					bool	crc_ok;
+
+					Assert(statbuf.st_size == PG_CONTROL_FILE_SIZE);
+
+					cfile = get_controlfile(".", &crc_ok);
+					DATA_CIPHER_CLEAR(cfile->data_cipher);
+					memset(cfile->encryption_verification, 0,
+						   ENCRYPTION_SAMPLE_SIZE);
+
+					/* Recalculate CRC of control file */
+					INIT_CRC32C(cfile->crc);
+					COMP_CRC32C(cfile->crc, (char *) cfile,
+								offsetof(ControlFileData, crc));
+					FIN_CRC32C(cfile->crc);
+
+					cfile_raw = (char *) palloc0(PG_CONTROL_FILE_SIZE);
+					memcpy(cfile_raw, cfile, sizeof(ControlFileData));
+					sendFileWithContentGeneric(XLOG_CONTROL_FILE,
+											   cfile_raw,
+											   &manifest,
+											   PG_CONTROL_FILE_SIZE,
+											   &statbuf);
+					pfree(cfile);
+					pfree(cfile_raw);
+				}
+				else
+					sendFile(XLOG_CONTROL_FILE, XLOG_CONTROL_FILE, &statbuf,
+							 false, InvalidOid, &manifest, NULL);
 			}
 			else
 				sendTablespace(ti->path, ti->oid, false, &manifest);
@@ -594,6 +644,7 @@ perform_base_backup(basebackup_options *opt)
 			char		buf[TAR_SEND_SIZE];
 			size_t		cnt;
 			pgoff_t		len = 0;
+			uint32		seg_offset = 0;
 
 			snprintf(pathbuf, MAXPGPATH, XLOGDIR "/%s", walFileName);
 			XLogFromFileName(walFileName, &tli, &segno, wal_segment_size);
@@ -638,6 +689,38 @@ perform_base_backup(basebackup_options *opt)
 											   len, pathbuf, true)) > 0)
 			{
 				CheckXLogRemoved(segno, tli);
+
+				if (decrypt && data_encrypted)
+				{
+					if (cnt % XLOG_BLCKSZ != 0)
+						ereport(ERROR,
+								(errmsg("could not decrypt page in file "
+										"\"%s\", offset %u: read buffer size "
+										"%d is not whole multiple of %d",
+										pathbuf, seg_offset, (int) cnt,
+										XLOG_BLCKSZ)));
+
+					/*
+					 * Decrypt the data, one XLOG page at a time because this
+					 * is how it was encrypted.
+					 */
+					while (seg_offset < cnt)
+					{
+						char		tweak[TWEAK_SIZE];
+						char	*data = buf + seg_offset;
+
+						XLogEncryptionTweak(tweak, tli, segno, seg_offset);
+						decrypt_block(data,
+									  data,
+									  XLOG_BLCKSZ,
+									  tweak,
+									  InvalidBlockNumber,
+									  EDK_REL_WAL);
+
+						seg_offset += XLOG_BLCKSZ;
+					}
+				}
+
 				/* Send the chunk as a CopyData message */
 				if (pq_putmessage('d', buf, cnt))
 					ereport(ERROR,
@@ -772,6 +855,7 @@ parse_basebackup_options(List *options, basebackup_options *opt)
 	bool		o_noverify_checksums = false;
 	bool		o_manifest = false;
 	bool		o_manifest_checksums = false;
+	bool		o_decrypt = false;
 
 	MemSet(opt, 0, sizeof(*opt));
 	opt->manifest = MANIFEST_OPTION_NO;
@@ -904,6 +988,15 @@ parse_basebackup_options(List *options, basebackup_options *opt)
 								optval)));
 			o_manifest_checksums = true;
 		}
+		else if (strcmp(defel->defname, "decrypt") == 0)
+		{
+			if (o_decrypt)
+				ereport(ERROR,
+						(errcode(ERRCODE_SYNTAX_ERROR),
+						 errmsg("duplicate option \"%s\"", defel->defname)));
+			decrypt = true;
+			o_decrypt = true;
+		}
 		else
 			elog(ERROR, "option \"%s\" not recognized",
 				 defel->defname);
@@ -1095,23 +1188,11 @@ SendXlogRecPtrResult(XLogRecPtr ptr, TimeLineID tli)
 	pq_puttextmessage('C', "SELECT");
 }
 
-/*
- * Inject a file with given name and content in the output tar stream.
- */
 static void
 sendFileWithContent(const char *filename, const char *content,
 					backup_manifest_info *manifest)
 {
 	struct stat statbuf;
-	int			pad,
-				len;
-	pg_checksum_context checksum_ctx;
-
-	if (pg_checksum_init(&checksum_ctx, manifest->checksum_type) < 0)
-		elog(ERROR, "could not initialize checksum of file \"%s\"",
-			 filename);
-
-	len = strlen(content);
 
 	/*
 	 * Construct a stat struct for the backup_label file we're injecting in
@@ -1127,11 +1208,35 @@ sendFileWithContent(const char *filename, const char *content,
 #endif
 	statbuf.st_mtime = time(NULL);
 	statbuf.st_mode = pg_file_create_mode;
-	statbuf.st_size = len;
+	statbuf.st_size = strlen(content);
+
+	sendFileWithContentGeneric(filename, content, manifest, 0, &statbuf);
+}
 
-	_tarWriteHeader(filename, NULL, &statbuf, false);
+/*
+ * Inject a file with given name and content in the output tar stream.
+ *
+ * If "len" is zero, content is considered a NULL-terminated string.
+ */
+static void
+sendFileWithContentGeneric(const char *filename, const char *content,
+						   backup_manifest_info *manifest,
+						   size_t len, struct stat *statbuf)
+{
+	int			pad;
+	pg_checksum_context checksum_ctx;
+
+	if (len == 0)
+		len = strlen(content);
+
+	if (pg_checksum_init(&checksum_ctx, manifest->checksum_type) < 0)
+		elog(ERROR, "could not initialize checksum of file \"%s\"",
+			 filename);
+
+	_tarWriteHeader(filename, NULL, statbuf, false);
 	/* Send the contents as a CopyData message */
 	pq_putmessage('d', content, len);
+
 	update_basebackup_progress(len);
 
 	/* Pad to a multiple of the tar block size. */
@@ -1150,7 +1255,7 @@ sendFileWithContent(const char *filename, const char *content,
 			 filename);
 
 	AddFileToBackupManifest(manifest, NULL, filename, len,
-							(pg_time_t) statbuf.st_mtime, &checksum_ctx);
+							(pg_time_t) statbuf->st_mtime, &checksum_ctx);
 }
 
 /*
@@ -1305,6 +1410,25 @@ sendDir(const char *path, int basepathlen, bool sizeonly, List *tablespaces,
 			}
 		}
 
+		/*
+		 * KDF_PARAMS_FILE should only be excluded if the backup will be
+		 * decrypted.
+		 */
+		if (decrypt && data_encrypted)
+		{
+			char	*fn;
+
+			fn = last_dir_separator(KDF_PARAMS_FILE);
+			Assert(fn != NULL);
+			fn++;
+
+			if (strcmp(de->d_name, fn) == 0)
+			{
+				elog(DEBUG1, "file \"%s\" excluded from backup", de->d_name);
+				excludeFound = true;
+			}
+		}
+
 		if (excludeFound)
 			continue;
 
@@ -1599,6 +1723,9 @@ sendFile(const char *readfilename, const char *tarfilename,
 	PageHeader	phdr;
 	int			segmentno = 0;
 	char	   *segmentpath;
+	bool		decrypt_files = decrypt && data_encrypted;
+	bool	decrypt_file = false;
+	bool	verify_checksums = !noverify_checksums && DataChecksumsEnabled();
 	bool		verify_checksum = false;
 	pg_checksum_context checksum_ctx;
 
@@ -1618,7 +1745,11 @@ sendFile(const char *readfilename, const char *tarfilename,
 
 	_tarWriteHeader(tarfilename, NULL, statbuf, false);
 
-	if (!noverify_checksums && DataChecksumsEnabled())
+	/*
+	 * Encryption can be applied to pages for which checksum can be computed
+	 * and only to those.
+	 */
+	if (verify_checksums || decrypt_files)
 	{
 		char	   *filename;
 
@@ -1631,7 +1762,8 @@ sendFile(const char *readfilename, const char *tarfilename,
 
 		if (is_checksummed_file(readfilename, filename))
 		{
-			verify_checksum = true;
+			verify_checksum = verify_checksums;
+			decrypt_file = decrypt_files;
 
 			/*
 			 * Cut off at the segment boundary (".") to get the segment number
@@ -1678,20 +1810,29 @@ sendFile(const char *readfilename, const char *tarfilename,
 		 */
 		Assert(TAR_SEND_SIZE % BLCKSZ == 0);
 
-		if (verify_checksum && (cnt % BLCKSZ != 0))
+		if ((verify_checksum || decrypt_file) && (cnt % BLCKSZ != 0))
 		{
-			ereport(WARNING,
-					(errmsg("could not verify checksum in file \"%s\", block "
-							"%u: read buffer size %d and page size %d "
-							"differ",
-							readfilename, blkno, (int) cnt, BLCKSZ)));
+			const char	*action;
+			int	elevel;
+
+			action = verify_checksum ? "verify checksum" : "decrypt page";
+			elevel = verify_checksum ? WARNING : ERROR;
+
+			ereport(elevel,
+					(errmsg("could not %s in file \"%s\", block "
+							"%d: read buffer size %d is not whole "
+							"multiple of %d ",
+							action, readfilename, blkno, (int) cnt,
+							BLCKSZ)));
 			verify_checksum = false;
 		}
 
-		if (verify_checksum)
+		if (verify_checksum || decrypt_file)
 		{
 			for (i = 0; i < cnt / BLCKSZ; i++)
 			{
+				BlockNumber	blkno_global = blkno + segmentno * RELSEG_SIZE;
+
 				page = buf + BLCKSZ * i;
 
 				/*
@@ -1702,9 +1843,10 @@ sendFile(const char *readfilename, const char *tarfilename,
 				 * this case. We also skip completely new pages, since they
 				 * don't have a checksum yet.
 				 */
-				if (!PageIsNew(page) && PageGetLSN(page) < startptr)
+				if (verify_checksum && !PageIsNew(page) &&
+					PageGetLSN(page) < startptr)
 				{
-					checksum = pg_checksum_page((char *) page, blkno + segmentno * RELSEG_SIZE);
+					checksum = pg_checksum_page((char *) page, blkno_global);
 					phdr = (PageHeader) page;
 					if (phdr->pd_checksum != checksum)
 					{
@@ -1766,6 +1908,21 @@ sendFile(const char *readfilename, const char *tarfilename,
 											"be reported", readfilename)));
 					}
 				}
+
+				/*
+				 * Decrypt the page if needed.
+				 */
+				if (decrypt_file)
+				{
+					decrypt_page(page, page, blkno_global);
+
+					/*
+					 * Compute new checksum for the decrypted page.
+					 */
+					if (DataChecksumsEnabled())
+						PageSetChecksumInplace(page, blkno_global);
+				}
+
 				block_retry = false;
 				blkno++;
 			}
diff --git a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
index 6eaa84a031..5a89cbd899 100644
--- a/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
+++ b/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
@@ -6,7 +6,8 @@
  * loaded as a dynamic module to avoid linking the main server binary with
  * libpq.
  *
- * Portions Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *
  *
  * IDENTIFICATION
@@ -464,6 +465,10 @@ libpqrcv_startstreaming(WalReceiverConn *conn,
 		appendStringInfo(&cmd, " TIMELINE %u",
 						 options->proto.physical.startpointTLI);
 
+	/* Request decryption of the stream if appropriate. */
+	if (!options->logical && options->proto.physical.decrypt)
+		appendStringInfo(&cmd, " DECRYPT");
+
 	/* Start streaming. */
 	res = libpqrcv_PQexec(conn->streamConn, cmd.data);
 	pfree(cmd.data);
diff --git a/src/backend/replication/logical/reorderbuffer.c b/src/backend/replication/logical/reorderbuffer.c
index 271a74c690..366f7fc92a 100644
--- a/src/backend/replication/logical/reorderbuffer.c
+++ b/src/backend/replication/logical/reorderbuffer.c
@@ -99,6 +99,7 @@
 #include "replication/slot.h"
 #include "replication/snapbuild.h"	/* just for SnapBuildSnapDecRefcount */
 #include "storage/bufmgr.h"
+#include "storage/buffile.h"
 #include "storage/fd.h"
 #include "storage/sinval.h"
 #include "utils/builtins.h"
@@ -131,21 +132,13 @@ typedef struct ReorderBufferTupleCidEnt
 	CommandId	combocid;		/* just for debugging */
 } ReorderBufferTupleCidEnt;
 
-/* Virtual file descriptor with file offset tracking */
-typedef struct TXNEntryFile
-{
-	File		vfd;			/* -1 when the file is closed */
-	off_t		curOffset;		/* offset for next write or read. Reset to 0
-								 * when vfd is opened. */
-} TXNEntryFile;
-
 /* k-way in-order change iteration support structures */
 typedef struct ReorderBufferIterTXNEntry
 {
 	XLogRecPtr	lsn;
 	ReorderBufferChange *change;
 	ReorderBufferTXN *txn;
-	TXNEntryFile file;
+	TransientBufFile *file;
 	XLogSegNo	segno;
 } ReorderBufferIterTXNEntry;
 
@@ -246,11 +239,17 @@ static void ReorderBufferExecuteInvalidations(uint32 nmsgs, SharedInvalidationMe
 static void ReorderBufferCheckMemoryLimit(ReorderBuffer *rb);
 static void ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn);
 static void ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-										 int fd, ReorderBufferChange *change);
+							 TransientBufFile *file, ReorderBufferChange *change);
+static void ReorderBufferWriteData(TransientBufFile *file, void *ptr, size_t size,
+					   ReorderBufferTXN *txn);
 static Size ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
-										TXNEntryFile *file, XLogSegNo *segno);
+							TransientBufFile **file, XLogSegNo *segno);
 static void ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-									   char *change);
+						   TransientBufFile **file);
+static ReorderBufferTupleBuf *ReorderBufferRestoreTuple(ReorderBuffer *rb,
+						  TransientBufFile *file);
+static void ReorderBufferReadData(TransientBufFile *file, void *ptr, size_t size,
+					  bool *no_data_p);
 static void ReorderBufferRestoreCleanup(ReorderBuffer *rb, ReorderBufferTXN *txn);
 static void ReorderBufferTruncateTXN(ReorderBuffer *rb, ReorderBufferTXN *txn,
 									 bool txn_prepared);
@@ -342,8 +341,6 @@ ReorderBufferAllocate(void)
 	buffer->by_txn_last_xid = InvalidTransactionId;
 	buffer->by_txn_last_txn = NULL;
 
-	buffer->outbuf = NULL;
-	buffer->outbufsize = 0;
 	buffer->size = 0;
 
 	buffer->spillTxns = 0;
@@ -1255,7 +1252,7 @@ ReorderBufferIterTXNInit(ReorderBuffer *rb, ReorderBufferTXN *txn,
 
 	for (off = 0; off < state->nr_txns; off++)
 	{
-		state->entries[off].file.vfd = -1;
+		state->entries[off].file = NULL;
 		state->entries[off].segno = 0;
 	}
 
@@ -1437,8 +1434,8 @@ ReorderBufferIterTXNFinish(ReorderBuffer *rb,
 
 	for (off = 0; off < state->nr_txns; off++)
 	{
-		if (state->entries[off].file.vfd != -1)
-			FileClose(state->entries[off].file.vfd);
+		if (state->entries[off].file)
+			BufFileCloseTransient(state->entries[off].file);
 	}
 
 	/* free memory we might have "leaked" in the last *Next call */
@@ -3347,24 +3344,6 @@ ReorderBufferXidHasBaseSnapshot(ReorderBuffer *rb, TransactionId xid)
  * ---------------------------------------
  */
 
-/*
- * Ensure the IO buffer is >= sz.
- */
-static void
-ReorderBufferSerializeReserve(ReorderBuffer *rb, Size sz)
-{
-	if (!rb->outbufsize)
-	{
-		rb->outbuf = MemoryContextAlloc(rb->context, sz);
-		rb->outbufsize = sz;
-	}
-	else if (rb->outbufsize < sz)
-	{
-		rb->outbuf = repalloc(rb->outbuf, sz);
-		rb->outbufsize = sz;
-	}
-}
-
 /*
  * Find the largest transaction (toplevel or subxact) to evict (spill to disk).
  *
@@ -3533,9 +3512,10 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 {
 	dlist_iter	subtxn_i;
 	dlist_mutable_iter change_i;
-	int			fd = -1;
+	TransientBufFile *file = NULL;
 	XLogSegNo	curOpenSegNo = 0;
 	Size		spilled = 0;
+
 	Size		size = txn->size;
 
 	elog(DEBUG2, "spill %u changes in XID %u to disk",
@@ -3561,13 +3541,13 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 		 * store in segment in which it belongs by start lsn, don't split over
 		 * multiple segments tho
 		 */
-		if (fd == -1 ||
+		if (file == NULL ||
 			!XLByteInSeg(change->lsn, curOpenSegNo, wal_segment_size))
 		{
 			char		path[MAXPGPATH];
 
-			if (fd != -1)
-				CloseTransientFile(fd);
+			if (file)
+				BufFileCloseTransient(file);
 
 			XLByteToSeg(change->lsn, curOpenSegNo, wal_segment_size);
 
@@ -3579,16 +3559,12 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 										curOpenSegNo);
 
 			/* open segment, create it if necessary */
-			fd = OpenTransientFile(path,
-								   O_CREAT | O_WRONLY | O_APPEND | PG_BINARY);
-
-			if (fd < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not open file \"%s\": %m", path)));
+			file = BufFileOpenTransient(path,
+										O_CREAT | O_WRONLY | O_APPEND | PG_BINARY,
+										ERROR);
 		}
 
-		ReorderBufferSerializeChange(rb, txn, fd, change);
+		ReorderBufferSerializeChange(rb, txn, file, change);
 		dlist_delete(&change->node);
 		ReorderBufferReturnChange(rb, change, true);
 
@@ -3613,8 +3589,8 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
 	txn->nentries_mem = 0;
 	txn->txn_flags |= RBTXN_IS_SERIALIZED;
 
-	if (fd != -1)
-		CloseTransientFile(fd);
+	if (file)
+		BufFileCloseTransient(file);
 }
 
 /*
@@ -3622,15 +3598,13 @@ ReorderBufferSerializeTXN(ReorderBuffer *rb, ReorderBufferTXN *txn)
  */
 static void
 ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-							 int fd, ReorderBufferChange *change)
+							 TransientBufFile *file, ReorderBufferChange *change)
 {
-	ReorderBufferDiskChange *ondisk;
+	ReorderBufferDiskChange hdr;
 	Size		sz = sizeof(ReorderBufferDiskChange);
 
-	ReorderBufferSerializeReserve(rb, sz);
-
-	ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-	memcpy(&ondisk->change, change, sizeof(ReorderBufferChange));
+	memcpy((char *) &hdr + offsetof(ReorderBufferDiskChange, change),
+		   change, sizeof(ReorderBufferChange));
 
 	switch (change->action)
 	{
@@ -3640,7 +3614,6 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 		case REORDER_BUFFER_CHANGE_DELETE:
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:
 			{
-				char	   *data;
 				ReorderBufferTupleBuf *oldtup,
 						   *newtup;
 				Size		oldlen = 0;
@@ -3663,84 +3636,71 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 					sz += newlen;
 				}
 
-				/* make sure we have enough space */
-				ReorderBufferSerializeReserve(rb, sz);
-
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr, sizeof(ReorderBufferDiskChange),
+									   txn);
 
 				if (oldlen)
 				{
-					memcpy(data, &oldtup->tuple, sizeof(HeapTupleData));
-					data += sizeof(HeapTupleData);
-
-					memcpy(data, oldtup->tuple.t_data, oldlen);
-					data += oldlen;
+					ReorderBufferWriteData(file, &oldtup->tuple,
+										   sizeof(HeapTupleData), txn);
+					ReorderBufferWriteData(file, oldtup->tuple.t_data, oldlen,
+										   txn);
 				}
 
 				if (newlen)
 				{
-					memcpy(data, &newtup->tuple, sizeof(HeapTupleData));
-					data += sizeof(HeapTupleData);
-
-					memcpy(data, newtup->tuple.t_data, newlen);
-					data += newlen;
+					ReorderBufferWriteData(file, &newtup->tuple,
+										   sizeof(HeapTupleData), txn);
+					ReorderBufferWriteData(file, newtup->tuple.t_data, newlen,
+										   txn);
 				}
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_MESSAGE:
 			{
-				char	   *data;
 				Size		prefix_size = strlen(change->data.msg.prefix) + 1;
 
 				sz += prefix_size + change->data.msg.message_size +
 					sizeof(Size) + sizeof(Size);
-				ReorderBufferSerializeReserve(rb, sz);
-
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
 
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr,
+									   sizeof(ReorderBufferDiskChange),
+									   txn);
 
 				/* write the prefix including the size */
-				memcpy(data, &prefix_size, sizeof(Size));
-				data += sizeof(Size);
-				memcpy(data, change->data.msg.prefix,
-					   prefix_size);
-				data += prefix_size;
+				ReorderBufferWriteData(file, &prefix_size, sizeof(Size), txn);
+				ReorderBufferWriteData(file, change->data.msg.prefix,
+									   prefix_size, txn);
 
 				/* write the message including the size */
-				memcpy(data, &change->data.msg.message_size, sizeof(Size));
-				data += sizeof(Size);
-				memcpy(data, change->data.msg.message,
-					   change->data.msg.message_size);
-				data += change->data.msg.message_size;
+				ReorderBufferWriteData(file, &change->data.msg.message_size,
+									   sizeof(Size), txn);
+				ReorderBufferWriteData(file, change->data.msg.message,
+									   change->data.msg.message_size, txn);
 
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INVALIDATION:
 			{
-				char	   *data;
 				Size		inval_size = sizeof(SharedInvalidationMessage) *
 				change->data.inval.ninvalidations;
 
 				sz += inval_size;
 
-				ReorderBufferSerializeReserve(rb, sz);
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-				memcpy(data, change->data.inval.invalidations, inval_size);
-				data += inval_size;
-
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr,
+									   sizeof(ReorderBufferDiskChange),
+									   txn);
+				ReorderBufferWriteData(file, change->data.inval.invalidations,
+									   inval_size,
+									   txn);
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:
 			{
 				Snapshot	snap;
-				char	   *data;
 
 				snap = change->data.snapshot;
 
@@ -3748,78 +3708,50 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 					sizeof(TransactionId) * snap->xcnt +
 					sizeof(TransactionId) * snap->subxcnt;
 
-				/* make sure we have enough space */
-				ReorderBufferSerializeReserve(rb, sz);
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr,
+									   sizeof(ReorderBufferDiskChange), txn);
 
-				memcpy(data, snap, sizeof(SnapshotData));
-				data += sizeof(SnapshotData);
+				ReorderBufferWriteData(file, snap, sizeof(SnapshotData), txn);
 
 				if (snap->xcnt)
-				{
-					memcpy(data, snap->xip,
-						   sizeof(TransactionId) * snap->xcnt);
-					data += sizeof(TransactionId) * snap->xcnt;
-				}
+					ReorderBufferWriteData(file, snap->xip,
+										   sizeof(TransactionId) * snap->xcnt,
+										   txn);
 
 				if (snap->subxcnt)
-				{
-					memcpy(data, snap->subxip,
-						   sizeof(TransactionId) * snap->subxcnt);
-					data += sizeof(TransactionId) * snap->subxcnt;
-				}
+					ReorderBufferWriteData(file, snap->subxip,
+										   sizeof(TransactionId) * snap->subxcnt,
+										   txn);
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_TRUNCATE:
 			{
 				Size		size;
-				char	   *data;
 
 				/* account for the OIDs of truncated relations */
 				size = sizeof(Oid) * change->data.truncate.nrelids;
 				sz += size;
 
-				/* make sure we have enough space */
-				ReorderBufferSerializeReserve(rb, sz);
-
-				data = ((char *) rb->outbuf) + sizeof(ReorderBufferDiskChange);
-				/* might have been reallocated above */
-				ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-
-				memcpy(data, change->data.truncate.relids, size);
-				data += size;
+				hdr.size = sz;
+				ReorderBufferWriteData(file, &hdr, sizeof(ReorderBufferDiskChange),
+									   txn);
 
+				ReorderBufferWriteData(file, change->data.truncate.relids, size,
+									   txn);
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:
 		case REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:
 		case REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:
+			hdr.size = sz;
+			ReorderBufferWriteData(file, &hdr, sizeof(ReorderBufferDiskChange),
+								   txn);
 			/* ReorderBufferChange contains everything important */
 			break;
 	}
 
-	ondisk->size = sz;
-
-	errno = 0;
-	pgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE);
-	if (write(fd, rb->outbuf, ondisk->size) != ondisk->size)
-	{
-		int			save_errno = errno;
-
-		CloseTransientFile(fd);
-
-		/* if write didn't set errno, assume problem is no disk space */
-		errno = save_errno ? save_errno : ENOSPC;
-		ereport(ERROR,
-				(errcode_for_file_access(),
-				 errmsg("could not write to data file for XID %u: %m",
-						txn->xid)));
-	}
-	pgstat_report_wait_end();
-
 	/*
 	 * Keep the transaction's final_lsn up to date with each change we send to
 	 * disk, so that ReorderBufferRestoreCleanup works correctly.  (We used to
@@ -3830,8 +3762,21 @@ ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 	 */
 	if (txn->final_lsn < change->lsn)
 		txn->final_lsn = change->lsn;
+}
 
-	Assert(ondisk->change.action == change->action);
+/*
+ * Wrapper for BufFileWriteTransient() that raises ERROR if the whole chunk
+ * was not written. XXX Should this be a macro?
+ */
+static void
+ReorderBufferWriteData(TransientBufFile *file, void *ptr, size_t size,
+					   ReorderBufferTXN *txn)
+{
+	if (BufFileWriteTransient(file, ptr, size) != size)
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not write to data file for XID %u: %m",
+						txn->xid)));
 }
 
 /* Returns true, if the output plugin supports streaming, false, otherwise. */
@@ -4074,12 +4019,11 @@ ReorderBufferChangeSize(ReorderBufferChange *change)
  */
 static Size
 ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
-							TXNEntryFile *file, XLogSegNo *segno)
+							TransientBufFile **file, XLogSegNo *segno)
 {
 	Size		restored = 0;
 	XLogSegNo	last_segno;
 	dlist_mutable_iter cleanup_iter;
-	File	   *fd = &file->vfd;
 
 	Assert(txn->first_lsn != InvalidXLogRecPtr);
 	Assert(txn->final_lsn != InvalidXLogRecPtr);
@@ -4100,12 +4044,9 @@ ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
 
 	while (restored < max_changes_in_memory && *segno <= last_segno)
 	{
-		int			readBytes;
-		ReorderBufferDiskChange *ondisk;
-
 		CHECK_FOR_INTERRUPTS();
 
-		if (*fd == -1)
+		if (*file == NULL)
 		{
 			char		path[MAXPGPATH];
 
@@ -4122,86 +4063,24 @@ ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
 			ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,
 										*segno);
 
-			*fd = PathNameOpenFile(path, O_RDONLY | PG_BINARY);
-
-			/* No harm in resetting the offset even in case of failure */
-			file->curOffset = 0;
-
-			if (*fd < 0 && errno == ENOENT)
+			*file = BufFileOpenTransient(path, O_RDONLY | PG_BINARY, ERROR);
+			if (*file == NULL)
 			{
-				*fd = -1;
+				Assert(errno == ENOENT);
 				(*segno)++;
 				continue;
 			}
-			else if (*fd < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not open file \"%s\": %m",
-								path)));
 		}
 
-		/*
-		 * Read the statically sized part of a change which has information
-		 * about the total size. If we couldn't read a record, we're at the
-		 * end of this file.
-		 */
-		ReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange));
-		readBytes = FileRead(file->vfd, rb->outbuf,
-							 sizeof(ReorderBufferDiskChange),
-							 file->curOffset, WAIT_EVENT_REORDER_BUFFER_READ);
-
-		/* eof */
-		if (readBytes == 0)
+		ReorderBufferRestoreChange(rb, txn, file);
+		if (*file)
+			restored++;
+		else
 		{
-			FileClose(*fd);
-			*fd = -1;
+			/* No data could be restored. */
 			(*segno)++;
 			continue;
 		}
-		else if (readBytes < 0)
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: %m")));
-		else if (readBytes != sizeof(ReorderBufferDiskChange))
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: read %d instead of %u bytes",
-							readBytes,
-							(uint32) sizeof(ReorderBufferDiskChange))));
-
-		file->curOffset += readBytes;
-
-		ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-
-		ReorderBufferSerializeReserve(rb,
-									  sizeof(ReorderBufferDiskChange) + ondisk->size);
-		ondisk = (ReorderBufferDiskChange *) rb->outbuf;
-
-		readBytes = FileRead(file->vfd,
-							 rb->outbuf + sizeof(ReorderBufferDiskChange),
-							 ondisk->size - sizeof(ReorderBufferDiskChange),
-							 file->curOffset,
-							 WAIT_EVENT_REORDER_BUFFER_READ);
-
-		if (readBytes < 0)
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: %m")));
-		else if (readBytes != ondisk->size - sizeof(ReorderBufferDiskChange))
-			ereport(ERROR,
-					(errcode_for_file_access(),
-					 errmsg("could not read from reorderbuffer spill file: read %d instead of %u bytes",
-							readBytes,
-							(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))));
-
-		file->curOffset += readBytes;
-
-		/*
-		 * ok, read a full change from disk, now restore it into proper
-		 * in-memory format
-		 */
-		ReorderBufferRestoreChange(rb, txn, rb->outbuf);
-		restored++;
 	}
 
 	return restored;
@@ -4211,25 +4090,36 @@ ReorderBufferRestoreChanges(ReorderBuffer *rb, ReorderBufferTXN *txn,
  * Convert change from its on-disk format to in-memory format and queue it onto
  * the TXN's ->changes list.
  *
- * Note: although "data" is declared char*, at entry it points to a
- * maxalign'd buffer, making it safe in most of this function to assume
- * that the pointed-to data is suitably aligned for direct access.
+ * If no data was found in the file, close it and set *file to NULL.
  */
 static void
 ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
-						   char *data)
+						   TransientBufFile **file)
 {
-	ReorderBufferDiskChange *ondisk;
+	ReorderBufferDiskChange ondisk;
+	bool		no_data;
 	ReorderBufferChange *change;
 
-	ondisk = (ReorderBufferDiskChange *) data;
+	/*
+	 * Read the statically sized part of a change which has information about
+	 * the total size. If we couldn't read a record, we're at the end of this
+	 * file.
+	 */
+	ReorderBufferReadData(*file, &ondisk, sizeof(ReorderBufferDiskChange),
+						  &no_data);
+
+	/* eof */
+	if (no_data)
+	{
+		BufFileCloseTransient(*file);
+		*file = NULL;
+		return;
+	}
 
 	change = ReorderBufferGetChange(rb);
 
 	/* copy static part */
-	memcpy(change, &ondisk->change, sizeof(ReorderBufferChange));
-
-	data += sizeof(ReorderBufferDiskChange);
+	memcpy(change, &ondisk.change, sizeof(ReorderBufferChange));
 
 	/* restore individual stuff */
 	switch (change->action)
@@ -4240,50 +4130,10 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 		case REORDER_BUFFER_CHANGE_DELETE:
 		case REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:
 			if (change->data.tp.oldtuple)
-			{
-				uint32		tuplelen = ((HeapTuple) data)->t_len;
-
-				change->data.tp.oldtuple =
-					ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);
-
-				/* restore ->tuple */
-				memcpy(&change->data.tp.oldtuple->tuple, data,
-					   sizeof(HeapTupleData));
-				data += sizeof(HeapTupleData);
-
-				/* reset t_data pointer into the new tuplebuf */
-				change->data.tp.oldtuple->tuple.t_data =
-					ReorderBufferTupleBufData(change->data.tp.oldtuple);
-
-				/* restore tuple data itself */
-				memcpy(change->data.tp.oldtuple->tuple.t_data, data, tuplelen);
-				data += tuplelen;
-			}
+				change->data.tp.oldtuple = ReorderBufferRestoreTuple(rb, *file);
 
 			if (change->data.tp.newtuple)
-			{
-				/* here, data might not be suitably aligned! */
-				uint32		tuplelen;
-
-				memcpy(&tuplelen, data + offsetof(HeapTupleData, t_len),
-					   sizeof(uint32));
-
-				change->data.tp.newtuple =
-					ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);
-
-				/* restore ->tuple */
-				memcpy(&change->data.tp.newtuple->tuple, data,
-					   sizeof(HeapTupleData));
-				data += sizeof(HeapTupleData);
-
-				/* reset t_data pointer into the new tuplebuf */
-				change->data.tp.newtuple->tuple.t_data =
-					ReorderBufferTupleBufData(change->data.tp.newtuple);
-
-				/* restore tuple data itself */
-				memcpy(change->data.tp.newtuple->tuple.t_data, data, tuplelen);
-				data += tuplelen;
-			}
+				change->data.tp.newtuple = ReorderBufferRestoreTuple(rb, *file);
 
 			break;
 		case REORDER_BUFFER_CHANGE_MESSAGE:
@@ -4291,22 +4141,20 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 				Size		prefix_size;
 
 				/* read prefix */
-				memcpy(&prefix_size, data, sizeof(Size));
-				data += sizeof(Size);
+				ReorderBufferReadData(*file, &prefix_size, sizeof(Size), NULL);
 				change->data.msg.prefix = MemoryContextAlloc(rb->context,
 															 prefix_size);
-				memcpy(change->data.msg.prefix, data, prefix_size);
+				ReorderBufferReadData(*file, change->data.msg.prefix,
+									  prefix_size, NULL);
 				Assert(change->data.msg.prefix[prefix_size - 1] == '\0');
-				data += prefix_size;
 
 				/* read the message */
-				memcpy(&change->data.msg.message_size, data, sizeof(Size));
-				data += sizeof(Size);
+				ReorderBufferReadData(*file, &change->data.msg.message_size,
+									  sizeof(Size), NULL);
 				change->data.msg.message = MemoryContextAlloc(rb->context,
 															  change->data.msg.message_size);
-				memcpy(change->data.msg.message, data,
-					   change->data.msg.message_size);
-				data += change->data.msg.message_size;
+				ReorderBufferReadData(*file, change->data.msg.message,
+									  change->data.msg.message_size, NULL);
 
 				break;
 			}
@@ -4319,29 +4167,32 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 					MemoryContextAlloc(rb->context, inval_size);
 
 				/* read the message */
-				memcpy(change->data.inval.invalidations, data, inval_size);
+				ReorderBufferReadData(*file, change->data.inval.invalidations,
+									  inval_size, NULL);
 
 				break;
 			}
 		case REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:
 			{
-				Snapshot	oldsnap;
+				SnapshotData oldsnap;
 				Snapshot	newsnap;
 				Size		size;
 
-				oldsnap = (Snapshot) data;
+				ReorderBufferReadData(*file, &oldsnap, sizeof(SnapshotData), NULL);
 
 				size = sizeof(SnapshotData) +
-					sizeof(TransactionId) * oldsnap->xcnt +
-					sizeof(TransactionId) * (oldsnap->subxcnt + 0);
+					sizeof(TransactionId) * oldsnap.xcnt +
+					sizeof(TransactionId) * (oldsnap.subxcnt + 0);
 
 				change->data.snapshot = MemoryContextAllocZero(rb->context, size);
 
 				newsnap = change->data.snapshot;
 
-				memcpy(newsnap, data, size);
+				memcpy(newsnap, &oldsnap, sizeof(SnapshotData));
 				newsnap->xip = (TransactionId *)
 					(((char *) newsnap) + sizeof(SnapshotData));
+				ReorderBufferReadData(*file, newsnap->xip,
+									  size - sizeof(SnapshotData), NULL);
 				newsnap->subxip = newsnap->xip + newsnap->xcnt;
 				newsnap->copied = true;
 				break;
@@ -4353,7 +4204,9 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 
 				relids = ReorderBufferGetRelids(rb,
 												change->data.truncate.nrelids);
-				memcpy(relids, data, change->data.truncate.nrelids * sizeof(Oid));
+				ReorderBufferReadData(*file, relids,
+									  change->data.truncate.nrelids * sizeof(Oid),
+									  NULL);
 				change->data.truncate.relids = relids;
 
 				break;
@@ -4380,6 +4233,77 @@ ReorderBufferRestoreChange(ReorderBuffer *rb, ReorderBufferTXN *txn,
 									ReorderBufferChangeSize(change));
 }
 
+/*
+ * Convert heap tuple from its on-disk format to in-memory format.
+ */
+static ReorderBufferTupleBuf *
+ReorderBufferRestoreTuple(ReorderBuffer *rb, TransientBufFile *file)
+{
+	HeapTupleData tupdata;
+	uint32		tuplelen;
+	ReorderBufferTupleBuf *result;
+
+	ReorderBufferReadData(file, &tupdata, sizeof(HeapTupleData), NULL);
+	tuplelen = tupdata.t_len;
+
+	result = ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);
+
+	/* restore ->tuple */
+	memcpy(&result->tuple, &tupdata, sizeof(HeapTupleData));
+
+	/* reset t_data pointer into the new tuplebuf */
+	result->tuple.t_data = ReorderBufferTupleBufData(result);
+
+	/* restore tuple data itself */
+	ReorderBufferReadData(file, result->tuple.t_data, tuplelen, NULL);
+
+	return result;
+}
+
+/*
+ * Wrapper for BufFileReadTransient() that raises ERROR if the expected amount
+ * of bytes was not read.
+ *
+ * If valid pointer is passed for no_data_p, set *no_data_p to indicate
+ * whether zero bytes was read. If NULL is passed, do not tolerate missing
+ * data.
+ */
+static void
+ReorderBufferReadData(TransientBufFile *file, void *ptr, size_t size,
+					  bool *no_data_p)
+{
+	int			readBytes;
+
+	/*
+	 * Caller should not request zero bytes. This assumption simplifies
+	 * setting of *no_data_p below.
+	 */
+	Assert(size > 0);
+
+	if ((readBytes = BufFileReadTransient(file, ptr, size)) != size)
+	{
+		if (no_data_p)
+			*no_data_p = readBytes == 0;
+
+		/*
+		 * It is o.k. to receive exactly zero bytes if caller passed valid
+		 * no_data_p.
+		 */
+		if (no_data_p && *no_data_p)
+			return;
+
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not read from reorderbuffer spill file: read %d instead of %u bytes",
+						readBytes, (uint32) size)));
+	}
+	else if (no_data_p)
+	{
+		/* Given that size is non-zero, readBytes must be non-zero too. */
+		*no_data_p = false;
+	}
+}
+
 /*
  * Remove all on-disk stored for the passed in transaction.
  */
diff --git a/src/backend/replication/repl_gram.y b/src/backend/replication/repl_gram.y
index 802c0ad0a6..fe197fcb23 100644
--- a/src/backend/replication/repl_gram.y
+++ b/src/backend/replication/repl_gram.y
@@ -3,6 +3,7 @@
  *
  * repl_gram.y				- Parser for the replication commands
  *
+ * Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
  * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -75,6 +76,7 @@ Node *replication_parse_result;
 %token K_WAL
 %token K_TABLESPACE_MAP
 %token K_NOVERIFY_CHECKSUMS
+%token K_DECRYPT
 %token K_TIMELINE
 %token K_PHYSICAL
 %token K_LOGICAL
@@ -94,6 +96,7 @@ Node *replication_parse_result;
 %type <list>	base_backup_opt_list
 %type <defelt>	base_backup_opt
 %type <uintval>	opt_timeline
+%type <boolval> opt_decrypt
 %type <list>	plugin_options plugin_opt_list
 %type <defelt>	plugin_opt_elem
 %type <node>	plugin_opt_arg
@@ -154,7 +157,7 @@ var_name:	IDENT	{ $$ = $1; }
 /*
  * BASE_BACKUP [LABEL '<label>'] [PROGRESS] [FAST] [WAL] [NOWAIT]
  * [MAX_RATE %d] [TABLESPACE_MAP] [NOVERIFY_CHECKSUMS]
- * [MANIFEST %s] [MANIFEST_CHECKSUMS %s]
+ * [MANIFEST %s] [MANIFEST_CHECKSUMS %s] [DECRYPT]
  */
 base_backup:
 			K_BASE_BACKUP base_backup_opt_list
@@ -223,6 +226,11 @@ base_backup_opt:
 				  $$ = makeDefElem("manifest_checksums",
 								   (Node *)makeString($2), -1);
 				}
+			| K_DECRYPT
+				{
+				  $$ = makeDefElem("decrypt",
+								   (Node *)makeInteger(true), -1);
+				}
 			;
 
 create_replication_slot:
@@ -302,10 +310,10 @@ drop_replication_slot:
 			;
 
 /*
- * START_REPLICATION [SLOT slot] [PHYSICAL] %X/%X [TIMELINE %d]
+ * START_REPLICATION [SLOT slot] [PHYSICAL] %X/%X [TIMELINE %d] [DECRYPT]
  */
 start_replication:
-			K_START_REPLICATION opt_slot opt_physical RECPTR opt_timeline
+			K_START_REPLICATION opt_slot opt_physical RECPTR opt_timeline opt_decrypt
 				{
 					StartReplicationCmd *cmd;
 
@@ -314,6 +322,7 @@ start_replication:
 					cmd->slotname = $2;
 					cmd->startpoint = $4;
 					cmd->timeline = $5;
+					cmd->decrypt = $6;
 					$$ = (Node *) cmd;
 				}
 			;
@@ -380,6 +389,10 @@ opt_timeline:
 				| /* EMPTY */			{ $$ = 0; }
 			;
 
+opt_decrypt:
+			K_DECRYPT						{ $$ = true; }
+			| /* EMPTY */					{ $$ = false; }
+			;
 
 plugin_options:
 			'(' plugin_opt_list ')'			{ $$ = $2; }
diff --git a/src/backend/replication/repl_scanner.l b/src/backend/replication/repl_scanner.l
index 8a075e2d92..d973f0ee8e 100644
--- a/src/backend/replication/repl_scanner.l
+++ b/src/backend/replication/repl_scanner.l
@@ -4,6 +4,7 @@
  * repl_scanner.l
  *	  a lexical scanner for the replication commands
  *
+ * Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
  * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
@@ -118,6 +119,7 @@ MAX_RATE		{ return K_MAX_RATE; }
 WAL			{ return K_WAL; }
 TABLESPACE_MAP			{ return K_TABLESPACE_MAP; }
 NOVERIFY_CHECKSUMS	{ return K_NOVERIFY_CHECKSUMS; }
+DECRYPT	{ return K_DECRYPT; }
 TIMELINE			{ return K_TIMELINE; }
 START_REPLICATION	{ return K_START_REPLICATION; }
 CREATE_REPLICATION_SLOT		{ return K_CREATE_REPLICATION_SLOT; }
diff --git a/src/backend/replication/walreceiver.c b/src/backend/replication/walreceiver.c
index 4831a259c4..0c4e6af777 100644
--- a/src/backend/replication/walreceiver.c
+++ b/src/backend/replication/walreceiver.c
@@ -39,7 +39,8 @@
  * specific parts are in the libpqwalreceiver module. It's loaded
  * dynamically to avoid linking the server with libpq.
  *
- * Portions Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *
  *
  * IDENTIFICATION
@@ -327,6 +328,15 @@ WalReceiverMain(void)
 		 */
 		primary_sysid = walrcv_identify_system(wrconn, &primaryTLI);
 
+		/*
+		 * If we (the slave) are not encrypted, ask master to decrypt the data
+		 * - it will just ignore the decryption if it's unencrypted too. If we
+		 * are encrypted, we expect the primary to be encrypted too, using the
+		 * same key - it'd be too tricky to ask the primary to (re)encrypt
+		 * data using particular key.
+		 */
+		options.proto.physical.decrypt = !data_encrypted;
+
 		snprintf(standby_sysid, sizeof(standby_sysid), UINT64_FORMAT,
 				 GetSystemIdentifier());
 		if (strcmp(primary_sysid, standby_sysid) != 0)
diff --git a/src/backend/replication/walsender.c b/src/backend/replication/walsender.c
index 28f0a29473..b53c31159e 100644
--- a/src/backend/replication/walsender.c
+++ b/src/backend/replication/walsender.c
@@ -37,7 +37,8 @@
  * record, wait for it to be replicated to the standby, and then exit.
  *
  *
- * Portions Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *	  src/backend/replication/walsender.c
@@ -77,6 +78,7 @@
 #include "replication/walsender.h"
 #include "replication/walsender_private.h"
 #include "storage/condition_variable.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/ipc.h"
 #include "storage/pmsignal.h"
@@ -562,6 +564,8 @@ SendTimeLineHistory(TimeLineHistoryCmd *cmd)
 	pq_endmessage(&buf);
 }
 
+static bool decrypt_stream = false;
+
 /*
  * Handle START_REPLICATION command.
  *
@@ -740,6 +744,20 @@ StartReplication(StartReplicationCmd *cmd)
 		/* Main loop of walsender */
 		replication_active = true;
 
+		if (cmd->decrypt)
+		{
+			if (data_encrypted)
+				decrypt_stream = true;
+			else
+			{
+				ereport(NOTICE,
+						(errmsg("decryption requested but the cluster is not encrypted")));
+				decrypt_stream = false;
+			}
+		}
+		else
+			decrypt_stream = false;
+
 		WalSndLoop(XLogSendPhysical);
 
 		replication_active = false;
@@ -842,7 +860,8 @@ logical_read_xlog_page(XLogReaderState *state, XLogRecPtr targetPagePtr, int req
 				 state->seg.ws_tli, /* Pass the current TLI because only
 									 * WalSndSegmentOpen controls whether new
 									 * TLI is needed. */
-				 &errinfo))
+				 &errinfo,
+				 data_encrypted))
 		WALReadRaiseError(&errinfo);
 
 	/*
@@ -2583,6 +2602,7 @@ XLogSendPhysical(void)
 	Size		nbytes;
 	XLogSegNo	segno;
 	WALReadError errinfo;
+	TimeLineID	tli_req;
 
 	/* If requested switch the WAL sender to the stopping state. */
 	if (got_STOPPING)
@@ -2797,8 +2817,8 @@ XLogSendPhysical(void)
 	 * calls.
 	 */
 	enlargeStringInfo(&output_message, nbytes);
-
 retry:
+	tli_req = sendTimeLine;
 	if (!WALRead(xlogreader,
 				 &output_message.data[output_message.len],
 				 startptr,
@@ -2806,9 +2826,87 @@ retry:
 				 xlogreader->seg.ws_tli,	/* Pass the current TLI because
 											 * only WalSndSegmentOpen controls
 											 * whether new TLI is needed. */
-				 &errinfo))
+				 &errinfo,
+				 decrypt_stream))
 		WALReadRaiseError(&errinfo);
 
+	/*
+	 * As its comment explains, WalSndSegmentOpen() can open segment in a TLI
+	 * newer than the requested one. Since the TLI is used in the encryption
+	 * IV, we've got to decrypt the data and encrypt it while taking the new
+	 * TLI into account.
+	 */
+	if (data_encrypted && !decrypt_stream && tli_req != xlogreader->seg.ws_tli)
+	{
+		XLogRecPtr	reencr_ptr = startptr;
+		int	reencr_nbytes = nbytes;
+		int	skip = 0;
+		char	*data_ptr;
+		WALOpenSegment *seg = &xlogreader->seg;
+
+		/*
+		 * The WALRead() call above shouldn't have crossed more than one
+		 * segment boundary.
+		 */
+		Assert(nbytes < wal_segment_size);
+
+		/*
+		 * If the segment boundary is crossed, only the data from the second
+		 * segment need the re-encryption.
+		 */
+		if (reencr_ptr / wal_segment_size !=
+			(reencr_ptr + nbytes) / wal_segment_size)
+		{
+			skip = wal_segment_size - XLogSegmentOffset(reencr_ptr,
+														wal_segment_size);
+			reencr_ptr += skip;
+			reencr_nbytes -= skip;
+		}
+
+		/*
+		 * WALRead() should have read something from the new segment after
+		 * having it opened.
+		 */
+		Assert(reencr_nbytes > 0);
+
+		data_ptr = &output_message.data[output_message.len] + skip;
+
+		/* Process one page at a time. */
+		while (reencr_nbytes > 0)
+		{
+			PGAlignedXLogBlock buffer;
+			char		tweak[TWEAK_SIZE];
+			int	page_off = reencr_ptr % XLOG_BLCKSZ;
+			int	seg_off = (reencr_ptr - page_off) % wal_segment_size;
+			int	this_page = Min(XLOG_BLCKSZ - page_off, reencr_nbytes);
+
+			memcpy(buffer.data + page_off, data_ptr, this_page);
+			/* For decryption, use the TLI of the file actually read. */
+			XLogEncryptionTweak(tweak, seg->ws_tli, seg->ws_segno, seg_off);
+			decrypt_block(buffer.data,
+						  buffer.data,
+						  XLOG_BLCKSZ,
+						  tweak,
+						  InvalidBlockNumber,
+						  EDK_REL_WAL);
+
+			/* For encryption, use the TLI the receiver expects. */
+			XLogEncryptionTweak(tweak, tli_req, seg->ws_segno, seg_off);
+			encrypt_block(buffer.data,
+						  buffer.data,
+						  XLOG_BLCKSZ,
+						  tweak,
+						  InvalidXLogRecPtr,
+						  InvalidBlockNumber,
+						  EDK_REL_WAL);
+			memcpy(data_ptr, buffer.data + page_off, this_page);
+
+			reencr_ptr += this_page;
+			data_ptr += this_page;
+			reencr_nbytes -= this_page;
+		}
+	}
+
 	/* See logical_read_xlog_page(). */
 	XLByteToSeg(startptr, segno, xlogreader->segcxt.ws_segsize);
 	CheckXLogRemoved(segno, xlogreader->seg.ws_tli);
diff --git a/src/backend/storage/buffer/bufmgr.c b/src/backend/storage/buffer/bufmgr.c
index d2eb69b5b0..928bf2c678 100644
--- a/src/backend/storage/buffer/bufmgr.c
+++ b/src/backend/storage/buffer/bufmgr.c
@@ -3,7 +3,8 @@
  * bufmgr.c
  *	  buffer manager interface routines
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -991,6 +992,10 @@ ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
 		/* new buffers are zero-filled */
 		MemSet((char *) bufBlock, 0, BLCKSZ);
 		/* don't set checksum for all-zero page */
+		/*
+		 * Encryption: no need to set LSN (to become an IV) because
+		 * zero-filled page won't be encrypted.
+		 */
 		smgrextend(smgr, forkNum, blockNum, (char *) bufBlock, false);
 
 		/*
@@ -1012,11 +1017,26 @@ ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
 		{
 			instr_time	io_start,
 						io_time;
+			Page	bufBlockEncr = NULL;
+			Page	bufRead;
+
+			if (!data_encrypted)
+				bufRead = bufBlock;
+			else
+				bufRead = (Page) encrypt_buf.data;
 
 			if (track_io_timing)
 				INSTR_TIME_SET_CURRENT(io_start);
 
-			smgrread(smgr, forkNum, blockNum, (char *) bufBlock);
+			smgrread(smgr, forkNum, blockNum, bufRead);
+
+			if (data_encrypted)
+			{
+				decrypt_page(bufRead,
+							 bufBlock,
+							 blockNum);
+				bufBlockEncr = bufRead;
+			}
 
 			if (track_io_timing)
 			{
@@ -1028,7 +1048,8 @@ ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,
 
 			/* check for garbage data */
 			if (!PageIsVerifiedExtended((Page) bufBlock, blockNum,
-										PIV_LOG_WARNING | PIV_REPORT_STAT))
+										PIV_LOG_WARNING | PIV_REPORT_STAT,
+										bufBlockEncr))
 			{
 				if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)
 				{
@@ -1589,7 +1610,11 @@ MarkBufferDirty(Buffer buffer)
 
 	if (BufferIsLocal(buffer))
 	{
-		MarkLocalBufferDirty(buffer);
+		/*
+		 * The caller of MarkBufferDirty () is responsible for setting the
+		 * LSN.
+		 */
+		MarkLocalBufferDirty(buffer, false);
 		return;
 	}
 
@@ -2907,6 +2932,48 @@ FlushBuffer(BufferDesc *buf, SMgrRelation reln)
 	 */
 	bufBlock = BufHdrGetBlock(buf);
 
+	if (data_encrypted)
+	{
+		/*
+		 * If permanent relation happens not to have valid LSN, it's probably
+		 * a new page and so it's o.k. not to encrypt that. We cannot assign
+		 * regular LSN (by inserting a new XLOG_NOOP record) at this stage
+		 * anyway.
+		 */
+		if (!XLogRecPtrIsInvalid(recptr))
+		{
+			encrypt_page(bufBlock, encrypt_buf.data, recptr,
+						 buf->tag.blockNum);
+		}
+		else
+		{
+			/*
+			 * Copy the data into a local buffer to make sure the LSN cannot
+			 * be changed concurrently (by MarkBufferDirtyHint()).
+			 */
+			memcpy(encrypt_buf.data, bufBlock, BLCKSZ);
+
+			/*
+			 * If the LSN changed while we were copying it, the only possible
+			 * reason should be MarkBufferDirtyHint() because the buffer is
+			 * locked in shared mode. We don't expect hints to be set on an
+			 * empty page, so error out. If this assumption was wrong, we'd
+			 * have to encrypt the page.
+			 */
+			if (!XLogRecPtrIsInvalid(PageGetLSN(encrypt_buf.data)))
+				ereport(ERROR,
+						(errmsg("LSN of an empty page changed concurrently")));
+
+			/*
+			 * Now that we're sure that the LSN is invalid and no one cannot
+			 * change our local copy during the write, we're also sure that
+			 * encryption is not applicable.
+			 */
+		}
+
+		bufBlock = encrypt_buf.data;
+	}
+
 	/*
 	 * Update page checksum if desired.  Since we have only shared lock on the
 	 * buffer, other processes might be updating hint bits in it, so we must
@@ -3046,8 +3113,12 @@ BufferGetLSNAtomic(Buffer buffer)
 
 	/*
 	 * If we don't need locking for correctness, fastpath out.
+	 *
+	 * If data_encrypted, then MarkBufferDirtyHint() can change the LSN while
+	 * the caller has only share lock on the buffer, so the fastpath is not
+	 * usable.
 	 */
-	if (!XLogHintBitIsNeeded() || BufferIsLocal(buffer))
+	if (!(XLogHintBitIsNeeded() || data_encrypted) || BufferIsLocal(buffer))
 		return PageGetLSN(page);
 
 	/* Make sure we've got a real buffer, and that we hold a pin on it. */
@@ -3571,8 +3642,22 @@ FlushRelationBuffers(Relation rel)
 				errcallback.previous = error_context_stack;
 				error_context_stack = &errcallback;
 
-				PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
+				if (data_encrypted)
+				{
+					XLogRecPtr	lsn = PageGetLSN(localpage);
 
+					if (!XLogRecPtrIsInvalid(lsn))
+					{
+						encrypt_page((char *) localpage,
+									 encrypt_buf.data,
+									 lsn,
+									 bufHdr->tag.blockNum);
+
+						localpage = encrypt_buf.data;
+					}
+				}
+
+				PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
 				smgrwrite(rel->rd_smgr,
 						  bufHdr->tag.forkNum,
 						  bufHdr->tag.blockNum,
@@ -3868,6 +3953,17 @@ IncrBufferRefCount(Buffer buffer)
  *	  buffer's content lock.
  * 3. This function does not guarantee that the buffer is always marked dirty
  *	  (due to a race condition), so it cannot be used for important changes.
+ *
+ * The function also handles generation of LSN when it's needed as the
+ * encryption IV. The problem is that the buffer can be written to disk
+ * anytime after this function has finished, so the function needs to
+ * guarantee an unique LSN to be set. Alternatively, caller can be required to
+ * set the LSN before he ever calls the function, but in such a case he'd have
+ * to predict whether the function will set the LSN too or not.
+ *
+ * Note that the encryption-specific LSN is not generated during
+ * recovery. Caller should set the LSN in such a case, *before* the actual
+ * call.
  */
 void
 MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
@@ -3880,7 +3976,26 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 
 	if (BufferIsLocal(buffer))
 	{
-		MarkLocalBufferDirty(buffer);
+		bool	set_lsn = false;
+
+		/* LSN is used as the encryption IV. */
+		if (data_encrypted)
+		{
+			/*
+			 * It's safer to return without marking the buffer dirty than to
+			 * go ahead without setting the LSN (a new LSN cannot be generated
+			 * during recovery anyway). The point is that the recovery can end
+			 * anytime after RecoveryInProgress() has returned true, so if we
+			 * only skip setting the LSN, then the buffer can be written to
+			 * disk w/o LSN, and therefore unencrypted.
+			 */
+			if (RecoveryInProgress())
+				return;
+
+			set_lsn = true;
+		}
+
+		MarkLocalBufferDirty(buffer, set_lsn);
 		return;
 	}
 
@@ -3908,6 +4023,7 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 		bool		dirtied = false;
 		bool		delayChkpt = false;
 		uint32		buf_state;
+		bool	need_fpi;
 
 		/*
 		 * If we need to protect hint bit updates from torn writes, WAL-log a
@@ -3918,8 +4034,9 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 		 * We don't check full_page_writes here because that logic is included
 		 * when we call XLogInsert() since the value changes dynamically.
 		 */
-		if (XLogHintBitIsNeeded() &&
-			(pg_atomic_read_u32(&bufHdr->state) & BM_PERMANENT))
+		need_fpi = XLogHintBitIsNeeded() &&
+			(pg_atomic_read_u32(&bufHdr->state) & BM_PERMANENT);
+		if (need_fpi || data_encrypted)
 		{
 			/*
 			 * If we must not write WAL, due to a relfilenode-specific
@@ -3955,11 +4072,23 @@ MarkBufferDirtyHint(Buffer buffer, bool buffer_std)
 			 * It's possible we may enter here without an xid, so it is
 			 * essential that CreateCheckpoint waits for virtual transactions
 			 * rather than full transactionids.
+			 *
+			 * Encryption alone should not be the reason for FPI.
+			 */
+			if (need_fpi)
+			{
+				Assert(!MyProc->delayChkpt);
+				MyProc->delayChkpt = true;
+				delayChkpt = true;
+				lsn = XLogSaveBufferForHint(buffer, buffer_std);
+			}
+
+			/*
+			 * Callers rely on us to generate LSN for the sake of encryption
+			 * IV.
 			 */
-			Assert(!MyProc->delayChkpt);
-			MyProc->delayChkpt = true;
-			delayChkpt = true;
-			lsn = XLogSaveBufferForHint(buffer, buffer_std);
+			if (XLogRecPtrIsInvalid(lsn) && data_encrypted)
+				lsn = get_lsn_for_encryption();
 		}
 
 		buf_state = LockBufHdr(bufHdr);
diff --git a/src/backend/storage/buffer/localbuf.c b/src/backend/storage/buffer/localbuf.c
index 04b3558ea3..e31dffe52f 100644
--- a/src/backend/storage/buffer/localbuf.c
+++ b/src/backend/storage/buffer/localbuf.c
@@ -4,7 +4,8 @@
  *	  local buffer manager. Fast buffer manager for temporary tables,
  *	  which never need to be WAL-logged or checkpointed, etc.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994-5, Regents of the University of California
  *
  *
@@ -16,10 +17,12 @@
 #include "postgres.h"
 
 #include "access/parallel.h"
+#include "access/xlog.h"
 #include "catalog/catalog.h"
 #include "executor/instrument.h"
 #include "storage/buf_internals.h"
 #include "storage/bufmgr.h"
+#include "storage/encryption.h"
 #include "utils/guc.h"
 #include "utils/memutils.h"
 #include "utils/resowner_private.h"
@@ -217,9 +220,22 @@ LocalBufferAlloc(SMgrRelation smgr, ForkNumber forkNum, BlockNumber blockNum,
 		/* Find smgr relation for buffer */
 		oreln = smgropen(bufHdr->tag.rnode, MyBackendId);
 
-		PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
-
 		/* And write... */
+		if (data_encrypted)
+		{
+			XLogRecPtr	lsn;
+
+			/* Generate fake LSN to become the encryption IV. */
+			lsn = get_lsn_for_encryption();
+
+			encrypt_page((char *) localpage,
+						 encrypt_buf.data,
+						 lsn,
+						 bufHdr->tag.blockNum);
+
+			localpage = encrypt_buf.data;
+		}
+		PageSetChecksumInplace(localpage, bufHdr->tag.blockNum);
 		smgrwrite(oreln,
 				  bufHdr->tag.forkNum,
 				  bufHdr->tag.blockNum,
@@ -283,7 +299,7 @@ LocalBufferAlloc(SMgrRelation smgr, ForkNumber forkNum, BlockNumber blockNum,
  *	  mark a local buffer dirty
  */
 void
-MarkLocalBufferDirty(Buffer buffer)
+MarkLocalBufferDirty(Buffer buffer, bool set_lsn)
 {
 	int			bufid;
 	BufferDesc *bufHdr;
@@ -301,6 +317,14 @@ MarkLocalBufferDirty(Buffer buffer)
 
 	bufHdr = GetLocalBufferDescriptor(bufid);
 
+	if (set_lsn)
+	{
+		Block	bufBlock = LocalBufHdrGetBlock(bufHdr);
+		XLogRecPtr	lsn = get_lsn_for_encryption();
+
+		PageSetLSN(bufBlock, lsn);
+	}
+
 	buf_state = pg_atomic_read_u32(&bufHdr->state);
 
 	if (!(buf_state & BM_DIRTY))
diff --git a/src/backend/storage/file/Makefile b/src/backend/storage/file/Makefile
index 5e1291bf2d..638782225e 100644
--- a/src/backend/storage/file/Makefile
+++ b/src/backend/storage/file/Makefile
@@ -17,6 +17,7 @@ OBJS = \
 	copydir.o \
 	fd.o \
 	reinit.o \
-	sharedfileset.o
+	sharedfileset.o \
+	encryption.o
 
 include $(top_srcdir)/src/backend/common.mk
diff --git a/src/backend/storage/file/README.encryption b/src/backend/storage/file/README.encryption
new file mode 100644
index 0000000000..2853e78c85
--- /dev/null
+++ b/src/backend/storage/file/README.encryption
@@ -0,0 +1,172 @@
+src/backend/storage/file/README.encryption
+
+Transparent Cluster Encryption
+==============================
+
+When creating a new cluster (instance), user can choose to have his data
+encrypted on disk. If this feature is active, data is encrypted before it's
+written to disk and decrypted after it has been read. The data is always
+unencrypted in memory. The following characteristics should be considered by
+anyone who is interested in the feature:
+
+	1. The encryption is transparent from application's point of view.
+
+	2. A single key is used to encrypt the whole cluster.
+
+The full instance encryption feature helps to ensure data confidentiality,
+especially when user cannot rely on confidentiality at filesystem level. On
+the other hand, it does not ensure data integrity, i.e. it does not help to
+detect whether an adversary wrote his cipher data to the disk. The ciphers
+used here do not protect data integrity: we encrypt one pages (typically of
+size 8 kB) at a time, so the attacker can replace the whole page. However if
+the attacker only changes part of the page, this can be detected if data
+checksums feature is enabled. And specifically for WAL, each WAL record has
+its own checksum.
+
+Relations
+---------
+
+AES cipher in CTR mode [2] is used to encrypt relation files, one relation
+block (page) at a time. Since CTR is effectively a stream cipher, we can
+consider each page to be a separate stream.
+
+One particular advantage of the CTR mode is that initialization vector (IV) of
+given encryption blocks can be determined independently from other blocks, so
+both encryption and decryption of a single page can be performed by multiple
+CPUs in parallel.
+
+Page LSN is stored unencrypted, see the section on initialization vector
+(tweak) below.
+
+Page checksum is also unencrypted so that it can be computed after encryption,
+right before the page is written to disk.
+
+WAL
+---
+
+The specific problem of WAL is that record must not be changed once it has
+been flushed to disk. However if we used a block cipher, and if a new WAL
+record started in the same encryption block in which the previous record ends,
+that encryption block would become completely different after the next run of
+encryption of the containing page. Torn write of such a block (e.g. if page
+boundary crosses the encryption block) is likely to make decryption produce
+garbage, which will also appear in the already-flushed record.
+
+Therefore we encrypt WAL using a stream cipher, or rather block cipher in
+stream mode of operation. Stream cipher uses XOR operation to combine a "key
+stream" with the input stream, and it does not matter if the length of the
+input stream is aligned to any value. In particular, the CTR mode [2] was
+chosen because it allows for both read and write operations to be performed by
+multiple CPUs.
+
+The WAL is encrypted / decrypted one WAL page (typically 8 kB) at a time, so
+rather than a single stream, the encrypted WAL is actually a sequence of
+per-page streams.
+
+Since stream ciphers are susceptible to "reused key attack" [4], we must
+ensure that the unused part of the last WAL page (filled with zeroes) is
+never encrypted.
+
+Temporary files
+---------------
+
+BufFileWrite() and BufFileRead() functions (see buffile.c) hide the encryption
+/ decryption from caller. The encryption / decryption processes one buffer at
+a time so that the buffers can be retrieved independent from each other.
+
+If the encryption is enabled, the following requirements need to be taken into
+account:
+
+1. The file buffer cannot be positioned at arbitrary offset of the file. If
+the encryption routine starts at some position of the file, decryption must
+not start elsewhere because there's no way to determine which initialization
+vector was used internally for the corresponding encryption blocks during
+encryption. It makes sense to position the buffer at file offset, that is
+whole multiple of buffer size.
+
+2. Since temporary file or its part can be rewritten, we either need to derive
+a new IV for each write or to avoid using stream cipher (see [4]). The earlier
+is difficult because both temporary files and "auxiliary files" are
+implemented in the same module buffile.c (in order to eliminate code
+duplication) and because it's hard to generate an unique IV for each write
+into auxiliary file, see explanation below. Therefore we use the AES-CBC
+cipher [3] for temporary files.
+
+3. In general, the useful (written) data does not fill whole multiple of
+encryption blocks, but we must write the whole blocks for decryption to
+succeed (this is because we use block cipher, as explained above). That
+implies that we need to fill the unused part of the last block with zeroes and
+also remember the amount of useful bytes in the segment file.  (In fact we
+align the segment file size to file buffers instead of encryption blocks,
+which makes the implementation simpler.)
+
+Auxiliary files
+---------------
+
+To store other kinds of data encrypted than the ones above, developers are
+advised to use BufFileWriteTransient() and BufFileReadTransient() functions
+(also located in buffile.c). These are especially useful if some data
+structure should be written to an encrypted file and user does not want to
+care about encryption specific details.
+
+Since these files can be closed and reopened again, we need to derive the
+tweak w/o using any in-memory metadata - such metadata is essentially lost
+when the file is closed. If we stored any kind of metadata into the file, it'd
+make the implementation rather tricky. Howver w/o storing the metadata, we
+cannot easily derive a new tweak if some block gets rewritten. Therefore we
+use the AES-CBC cipher for auxiliary files: unlike stream cipher, this cipher
+is not vulnerable to "reused key attack" [4].
+
+Serialization of data changes during logical decoding (reorderbuffer.c) is the
+typical use case for this API. Another use case is encryption of statistics
+(pgstat.c).
+
+Initialization vector (IV), encryption tweak
+--------------------------------------------
+
+Besides the input data and the key, both block and stream cipher used for the
+postgres cluster encryption require an initialization vector. It should make
+analysis of the encrypted data more difficult. Also according to [1], the same
+data should be encrypted differently if located elsewhere on the disk. Term
+"encryption tweak" is more common in the context of disk encryption.
+
+When encrypting relations, each encryption unit (i.e. page) has an unique
+tweak, which consists of page LSN and block number. Since the tweak is needed
+for decryption, we leave the LSN unencrypted.
+
+WAL encryption tweak consists of timeline, segment number and offset at which
+the WAL page starts in the segment. The "reencryption" takes place when WAL
+page is copied from one timeline to another, typicially at the end of
+recovery.
+
+As for temporary files, PID of the owning backend, file / fileset number and
+block number (where block is of the same size as a relation page) within the
+file provide sufficient uniqueness, so we use these to generate the tweak.
+
+Auxiliary files can be used for different purposes, so each caller is
+responsible for the tweak initialization. See the source code for details.
+
+Replication
+-----------
+
+During streaming replication, the walsender process sends the WAL encrypted
+and walreceiver just writes it. Decryption is performed before the slave
+cluster tries to apply the changes. That implies that the same encryption key
+must be used both master and slave.
+
+As for logical replication, the only change introduced by this feature is that
+the WAL has to be decrypted before the contained data changes can be
+decoded. The data changes are transferred to the subscribing database /
+cluster unencrypted, so both master and slave can use different encryption
+keys.
+
+References
+----------
+
+[1] https://en.wikipedia.org/wiki/Disk_encryption_theory
+
+[2] https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)
+
+[3] https://en.wikipedia.org/wiki/Disk_encryption_theory#Cipher-block_chaining_(CBC)
+
+[4] https://en.wikipedia.org/wiki/Stream_cipher_attacks#Reused_key_attack
diff --git a/src/backend/storage/file/buffile.c b/src/backend/storage/file/buffile.c
index a4be5fe513..2b99a2e1dd 100644
--- a/src/backend/storage/file/buffile.c
+++ b/src/backend/storage/file/buffile.c
@@ -3,7 +3,8 @@
  * buffile.c
  *	  Management of large buffered temporary files.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -45,22 +46,139 @@
 
 #include "postgres.h"
 
+#include <unistd.h>
+
 #include "commands/tablespace.h"
+#include "common/string.h"
 #include "executor/instrument.h"
 #include "miscadmin.h"
 #include "pgstat.h"
 #include "storage/buf_internals.h"
 #include "storage/buffile.h"
 #include "storage/fd.h"
+#include "utils/datetime.h"
 #include "utils/resowner.h"
 
 /*
- * We break BufFiles into gigabyte-sized segments, regardless of RELSEG_SIZE.
- * The reason is that we'd like large BufFiles to be spread across multiple
- * tablespaces when available.
+ * Unlike PG core, we implement these parameters as GUC so that crossing of
+ * segment boundaries can be tested easily. Note also that we derive
+ * buffile_max_filesize from buffile_seg_blocks, not the other way round. It'd
+ * be weird to let user set buffile_max_filesize directly because it's usually
+ * adjusted in an encrypted cluster (see assign_buffile_seg_blocks()).
+ */
+int buffile_seg_blocks	=	BUFFILE_SEG_BLOCKS;
+int buffile_max_filesize	=  MAX_PHYSICAL_FILESIZE(BUFFILE_SEG_BLOCKS);
+
+/*
+ * The following is only relevant to encrypted cluster.
+ *
+ * To make sure that BufFileLogicalToPhysicalPos() and
+ * BufFilePhysicalToLogicalPos() can handle segment file boundaries despite
+ * BufFileAppend() creates holes in the temporary file, we ensure that user
+ * can only write a whole multiple of BLCKSZ-sized chunks of payload into a
+ * segment file.
+ *
+ * Thus buffile_seg_blocks_logical is the number of BLCKSZ chunks that the
+ * user can write into a segment file. When computing the value, we also
+ * adjust buffile_max_filesize (see assign_buffile_seg_blocks()) so that the
+ * segment file does not accept any data beyond the last "logical
+ * block". (Actually we encrypt BLCKSZ bytes at a time, so the unused part of
+ * the last "physical" buffer will be written to disk too.)
+ *
+ * The fact that the first logical block of the next segment file is at the
+ * beginning of that file also allows BufFileAppend() to return a (logical)
+ * block number that can be passed to BufFileSeekBlock(). Otherwise
+ * BufFileSeekBlock() would think that the desired physical position is in the
+ * hole created by BufFileAppend().
+ */
+int buffile_seg_blocks_logical	=	BUFFILE_SEG_BLOCKS;
+
+/* Have we already run BufFileAdjustConfiguration()? */
+static bool	conf_adjusted = false;
+
+/*
+ * Compute buffile_max_filesize and buffile_seg_blocks_logical out of
+ * buffile_seg_blocks.
+ */
+void
+BufFileAdjustConfiguration(int buffile_seg_blocks)
+{
+	if (!data_encrypted)
+	{
+		buffile_max_filesize = MAX_PHYSICAL_FILESIZE(buffile_seg_blocks);
+		buffile_seg_blocks_logical = buffile_seg_blocks;
+	}
+	else
+	{
+		off_t	useful, last_block_usage;
+		int		blocks;
+
+		/*
+		 * The useful space, including the incomplete last chunk of BLCKSZ
+		 * bytes.
+		 */
+		useful = buffile_seg_blocks * (BLCKSZ - SizeOfBufFilePageHeader);
+		/* Round down to a multiple of BLCKSZ - only this part can be used. */
+		useful -= useful % BLCKSZ;
+		/* Fully used (physical) blocks needed. */
+		blocks = useful / (BLCKSZ - SizeOfBufFilePageHeader);
+		/* Space needed in the last (only partially used) physical block. */
+		last_block_usage = useful % (BLCKSZ - SizeOfBufFilePageHeader);
+
+		/* Compute the physical offset. */
+		buffile_max_filesize = blocks * BLCKSZ;
+		if (last_block_usage > 0)
+			buffile_max_filesize += SizeOfBufFilePageHeader +
+				last_block_usage;
+
+		/* How many chunks can the user write? */
+		buffile_seg_blocks_logical = useful / BLCKSZ;
+	}
+}
+
+/*
+ * Fields that both BufFile and TransientBufFile structures need. It must be
+ * the first field of those structures.
+ */
+typedef struct BufFileCommon
+{
+	bool		dirty;			/* does buffer need to be written? */
+	int			pos;			/* next read/write position in buffer */
+	int			nbytes;			/* total # of valid bytes in buffer */
+
+	/*
+	 * "current pos" is position of start of buffer within the logical file.
+	 * Position as seen by user of BufFile is (curFile, curOffset + pos).
+	 */
+	int			curFile;		/* file index (0..n) part of current pos,
+								 * always zero for TransientBufFile */
+	off_t		curOffset;		/* offset part of current pos */
+
+	bool		readOnly;		/* has the file been set to read only? */
+
+	bool		append;			/* should new data be appended to the end? */
+
+	PGAlignedBlock buffer;
+} BufFileCommon;
+
+/*
+ * The convention is that in an encrypted file, nbytes should be exactly
+ * SizeOfBufFilePageHeader if no data could be loaded.
+ */
+#define BUFFER_IS_EMPTY(file) ((file)->nbytes <= 0 || \
+							   (data_encrypted && (file)->nbytes == SizeOfBufFilePageHeader))
+
+/*
+ * Sometimes it's useful to cache the segment size, so wrap the file
+ * descriptor and the size into this structure.
  */
-#define MAX_PHYSICAL_FILESIZE	0x40000000
-#define BUFFILE_SEG_SIZE		(MAX_PHYSICAL_FILESIZE / BLCKSZ)
+typedef struct BufFileSegment
+{
+	File	vfd;
+	uint64	size;
+} BufFileSegment;
+
+#define	InvalidSegmentSize	0xffffffffffffffff
 
 /*
  * This data structure represents a buffered file that consists of one or
@@ -69,13 +187,13 @@
  */
 struct BufFile
 {
+	BufFileCommon common;		/* Common fields, see above. */
+
 	int			numFiles;		/* number of physical files in set */
-	/* all files except the last have length exactly MAX_PHYSICAL_FILESIZE */
-	File	   *files;			/* palloc'd array with numFiles entries */
+
+	BufFileSegment	*files;			/* palloc'd array with numFiles entries */
 
 	bool		isInterXact;	/* keep open over transactions? */
-	bool		dirty;			/* does buffer need to be written? */
-	bool		readOnly;		/* has the file been set to read only? */
 
 	SharedFileSet *fileset;		/* space for segment files if shared */
 	const char *name;			/* name of this BufFile if shared */
@@ -86,42 +204,95 @@ struct BufFile
 	 * because after creation we only repalloc our arrays larger.)
 	 */
 	ResourceOwner resowner;
+};
 
-	/*
-	 * "current pos" is position of start of buffer within the logical file.
-	 * Position as seen by user of BufFile is (curFile, curOffset + pos).
-	 */
-	int			curFile;		/* file index (0..n) part of current pos */
-	off_t		curOffset;		/* offset part of current pos */
-	int			pos;			/* next read/write position in buffer */
-	int			nbytes;			/* total # of valid bytes in buffer */
-	PGAlignedBlock buffer;
+/*
+ * Buffered variant of a transient file. Unlike BufFile this is simpler in
+ * several ways: 1) it's not split into segments, 2) there's no need of seek,
+ * 3) there's no need to combine read and write access.
+ *
+ * XXX "Transient" refers to the fact that this kind of file was initially
+ * used to encrypt files that PG core accessed via OpenTransientFile /
+ * CloseTransientFile. However, since commit d2070380, PG core uses
+ * PathNameOpenFile in reorderbuffer.c., so it was changed here too. Should
+ * this structure and related functions be renamed?
+ */
+struct TransientBufFile
+{
+	/* Common fields, see above. */
+	BufFileCommon common;
+
+	/* The underlying file. */
+	BufFileSegment	file;;
+	char		*path;
+	int		elevel;
 };
 
+/*
+ * This counter is used to generate the encryption tweak, see
+ * BufFileTweak().
+ */
+static	uint64	blocks_written = 0;
+
 static BufFile *makeBufFileCommon(int nfiles);
 static BufFile *makeBufFile(File firstfile);
 static void extendBufFile(BufFile *file);
 static void BufFileLoadBuffer(BufFile *file);
 static void BufFileDumpBuffer(BufFile *file);
-static void BufFileFlush(BufFile *file);
+static void BufFileDumpBufferEncrypted(BufFile *file, bool last_in_segment);
+static void BufFileFlush(BufFileCommon *file, bool is_transient);
 static File MakeNewSharedSegment(BufFile *file, int segment);
 
+static void BufFileTweak(char *tweak, BufFileCommon *file);
+static int64 BufFileSegmentSize(BufFileSegment *seg);
+static bool BufFileLastBlock(BufFileCommon *file, int *numSegments);
+
+static void BufFileLoadBufferTransient(TransientBufFile *file);
+static void BufFileDumpBufferTransient(TransientBufFile *file);
+
+static size_t BufFileReadCommon(BufFileCommon *file, void *ptr, size_t size,
+								int *numSegments);
+static size_t BufFileWriteCommon(BufFileCommon *file, void *ptr, size_t size,
+								 bool is_transient);
+static int16 BufFileGetUsefulBytes(File segment, off_t offset,
+								   PGAlignedBlock *buffer);
+static void BufFileAdjustUsefulBytes(BufFileCommon *file,
+									 BufFileSegment *segments,
+									 int elevel);
+
 /*
  * Create BufFile and perform the common initialization.
  */
 static BufFile *
 makeBufFileCommon(int nfiles)
 {
-	BufFile    *file = (BufFile *) palloc(sizeof(BufFile));
+	BufFile    *file = (BufFile *) palloc0(sizeof(BufFile));
+	BufFileCommon *fcommon = &file->common;
+
+	/*
+	 * Make sure that BufFileAdjustConfiguration() has been run before the
+	 * first use of temporary file. The GUC assign_hook will call the function
+	 * whenever buffile_seg_blocks gets changed, however it does not help
+	 * during startup: when the GUC subsystem is initialized, data_encrypted
+	 * is still false.
+	 */
+	if (data_encrypted && !conf_adjusted)
+	{
+		BufFileAdjustConfiguration(buffile_seg_blocks);
+		conf_adjusted = true;
+	}
+
+	fcommon->dirty = false;
+	fcommon->curFile = 0;
+	fcommon->curOffset = 0L;
+	if (!data_encrypted)
+		fcommon->pos = fcommon->nbytes = 0;
+	else
+		fcommon->pos = fcommon->nbytes = SizeOfBufFilePageHeader;
 
 	file->numFiles = nfiles;
 	file->isInterXact = false;
-	file->dirty = false;
 	file->resowner = CurrentResourceOwner;
-	file->curFile = 0;
-	file->curOffset = 0L;
-	file->pos = 0;
-	file->nbytes = 0;
 
 	return file;
 }
@@ -135,9 +306,10 @@ makeBufFile(File firstfile)
 {
 	BufFile    *file = makeBufFileCommon(1);
 
-	file->files = (File *) palloc(sizeof(File));
-	file->files[0] = firstfile;
-	file->readOnly = false;
+	file->files = (BufFileSegment *) palloc(sizeof(BufFileSegment));
+	file->files[0].vfd = firstfile;
+	file->files[0].size = InvalidSegmentSize;
+	file->common.readOnly = false;
 	file->fileset = NULL;
 	file->name = NULL;
 
@@ -166,15 +338,17 @@ extendBufFile(BufFile *file)
 
 	CurrentResourceOwner = oldowner;
 
-	file->files = (File *) repalloc(file->files,
-									(file->numFiles + 1) * sizeof(File));
-	file->files[file->numFiles] = pfile;
+	file->files = (BufFileSegment *) repalloc(file->files,
+											  (file->numFiles + 1) * sizeof(BufFileSegment));
+	file->files[file->numFiles].vfd = pfile;
+	file->files[file->numFiles].size = InvalidSegmentSize;
+
 	file->numFiles++;
 }
 
 /*
  * Create a BufFile for a new temporary file (which will expand to become
- * multiple temporary files if more than MAX_PHYSICAL_FILESIZE bytes are
+ * multiple temporary files if more than buffile_max_filesize bytes are
  * written to it).
  *
  * If interXact is true, the temp file will not be automatically deleted
@@ -266,9 +440,10 @@ BufFileCreateShared(SharedFileSet *fileset, const char *name)
 	file = makeBufFileCommon(1);
 	file->fileset = fileset;
 	file->name = pstrdup(name);
-	file->files = (File *) palloc(sizeof(File));
-	file->files[0] = MakeNewSharedSegment(file, 0);
-	file->readOnly = false;
+	file->files = (BufFileSegment *) palloc(sizeof(BufFileSegment));
+	file->files[0].vfd = MakeNewSharedSegment(file, 0);
+	file->files[0].size = InvalidSegmentSize;
+	file->common.readOnly = false;
 
 	return file;
 }
@@ -286,10 +461,10 @@ BufFileOpenShared(SharedFileSet *fileset, const char *name, int mode)
 	BufFile    *file;
 	char		segment_name[MAXPGPATH];
 	Size		capacity = 16;
-	File	   *files;
+	BufFileSegment   *files;
 	int			nfiles = 0;
 
-	files = palloc(sizeof(File) * capacity);
+	files = palloc(sizeof(BufFileSegment) * capacity);
 
 	/*
 	 * We don't know how many segments there are, so we'll probe the
@@ -301,13 +476,15 @@ BufFileOpenShared(SharedFileSet *fileset, const char *name, int mode)
 		if (nfiles + 1 > capacity)
 		{
 			capacity *= 2;
-			files = repalloc(files, sizeof(File) * capacity);
+			files = repalloc(files, sizeof(BufFileSegment) * capacity);
 		}
 		/* Try to load a segment. */
 		SharedSegmentName(segment_name, name, nfiles);
-		files[nfiles] = SharedFileSetOpen(fileset, segment_name, mode);
-		if (files[nfiles] <= 0)
+		files[nfiles].vfd = SharedFileSetOpen(fileset, segment_name, mode);
+		if (files[nfiles].vfd <= 0)
 			break;
+		files[nfiles].size = InvalidSegmentSize;
+
 		++nfiles;
 
 		CHECK_FOR_INTERRUPTS();
@@ -324,11 +501,21 @@ BufFileOpenShared(SharedFileSet *fileset, const char *name, int mode)
 						segment_name, name)));
 
 	file = makeBufFileCommon(nfiles);
+
 	file->files = files;
-	file->readOnly = (mode == O_RDONLY) ? true : false;
+	file->common.readOnly = (mode == O_RDONLY) ? true : false;
 	file->fileset = fileset;
 	file->name = pstrdup(name);
 
+	/*
+	 * Load the buffer if needed.
+	 *
+	 * BufFileReadCommon() could do that lazily but it'd get more complex
+	 * because initially nbytes is not a multiple of BLCKSZ.
+	 */
+	if (data_encrypted)
+		BufFileLoadBuffer(file);
+
 	return file;
 }
 
@@ -380,10 +567,10 @@ BufFileExportShared(BufFile *file)
 	Assert(file->fileset != NULL);
 
 	/* It's probably a bug if someone calls this twice. */
-	Assert(!file->readOnly);
+	Assert(!file->common.readOnly);
 
-	BufFileFlush(file);
-	file->readOnly = true;
+	BufFileFlush(&file->common, false);
+	file->common.readOnly = true;
 }
 
 /*
@@ -397,10 +584,10 @@ BufFileClose(BufFile *file)
 	int			i;
 
 	/* flush any unwritten data */
-	BufFileFlush(file);
+	BufFileFlush(&file->common, false);
 	/* close and delete the underlying file(s) */
 	for (i = 0; i < file->numFiles; i++)
-		FileClose(file->files[i]);
+		FileClose(file->files[i].vfd);
 	/* release the buffer space */
 	pfree(file->files);
 	pfree(file);
@@ -410,45 +597,54 @@ BufFileClose(BufFile *file)
  * BufFileLoadBuffer
  *
  * Load some data into buffer, if possible, starting from curOffset.
- * At call, must have dirty = false, pos and nbytes = 0.
+ * At call, must have dirty = false, nbytes = 0.
  * On exit, nbytes is number of bytes loaded.
  */
 static void
 BufFileLoadBuffer(BufFile *file)
 {
-	File		thisfile;
+	BufFileCommon	*f = &file->common;
+	BufFileSegment		*thisfile;
+
+	/*
+	 * Only whole multiple of BLCKSZ can be encrypted / decrypted.
+	 */
+	Assert(f->curOffset % BLCKSZ == 0 || !data_encrypted);
 
 	/*
 	 * Advance to next component file if necessary and possible.
 	 */
-	if (file->curOffset >= MAX_PHYSICAL_FILESIZE &&
-		file->curFile + 1 < file->numFiles)
+	if (f->curOffset >= buffile_max_filesize &&
+		f->curFile + 1 < file->numFiles)
 	{
-		file->curFile++;
-		file->curOffset = 0L;
+		f->curFile++;
+		f->curOffset = 0L;
 	}
 
 	/*
 	 * Read whatever we can get, up to a full bufferload.
 	 */
-	thisfile = file->files[file->curFile];
-	file->nbytes = FileRead(thisfile,
-							file->buffer.data,
-							sizeof(file->buffer),
-							file->curOffset,
-							WAIT_EVENT_BUFFILE_READ);
-	if (file->nbytes < 0)
-	{
-		file->nbytes = 0;
+	thisfile = &file->files[f->curFile];
+	f->nbytes = FileRead(thisfile->vfd,
+						 f->buffer.data,
+						 sizeof(f->buffer),
+						 f->curOffset,
+						 WAIT_EVENT_BUFFILE_READ);
+	if (f->nbytes < 0)
+	{
+		f->nbytes = 0;
 		ereport(ERROR,
 				(errcode_for_file_access(),
 				 errmsg("could not read file \"%s\": %m",
-						FilePathName(thisfile))));
+						FilePathName(thisfile->vfd))));
 	}
 
 	/* we choose not to advance curOffset here */
 
-	if (file->nbytes > 0)
+	if (data_encrypted)
+		BufFileAdjustUsefulBytes(f, file->files, ERROR);
+
+	if (f->nbytes > 0)
 		pgBufferUsage.temp_blks_read++;
 }
 
@@ -464,53 +660,60 @@ BufFileDumpBuffer(BufFile *file)
 {
 	int			wpos = 0;
 	int			bytestowrite;
-	File		thisfile;
+	BufFileSegment		*thisfile;
 
 	/*
 	 * Unlike BufFileLoadBuffer, we must dump the whole buffer even if it
 	 * crosses a component-file boundary; so we need a loop.
 	 */
-	while (wpos < file->nbytes)
+	while (wpos < file->common.nbytes)
 	{
 		off_t		availbytes;
 
 		/*
 		 * Advance to next component file if necessary and possible.
 		 */
-		if (file->curOffset >= MAX_PHYSICAL_FILESIZE)
+		if (file->common.curOffset >= buffile_max_filesize)
 		{
-			while (file->curFile + 1 >= file->numFiles)
+			while (file->common.curFile + 1 >= file->numFiles)
 				extendBufFile(file);
-			file->curFile++;
-			file->curOffset = 0L;
+			file->common.curFile++;
+			file->common.curOffset = 0L;
 		}
 
 		/*
 		 * Determine how much we need to write into this file.
 		 */
-		bytestowrite = file->nbytes - wpos;
-		availbytes = MAX_PHYSICAL_FILESIZE - file->curOffset;
+		bytestowrite = file->common.nbytes - wpos;
+		availbytes = buffile_max_filesize - file->common.curOffset;
 
 		if ((off_t) bytestowrite > availbytes)
 			bytestowrite = (int) availbytes;
 
-		thisfile = file->files[file->curFile];
-		bytestowrite = FileWrite(thisfile,
-								 file->buffer.data + wpos,
+		thisfile = &file->files[file->common.curFile];
+		bytestowrite = FileWrite(thisfile->vfd,
+								 file->common.buffer.data + wpos,
 								 bytestowrite,
-								 file->curOffset,
-								 WAIT_EVENT_BUFFILE_WRITE);
+								 file->common.curOffset,
+								 WAIT_EVENT_BUFFILE_WRITE,
+								 ERROR);
 		if (bytestowrite <= 0)
 			ereport(ERROR,
 					(errcode_for_file_access(),
 					 errmsg("could not write to file \"%s\": %m",
-							FilePathName(thisfile))));
-		file->curOffset += bytestowrite;
+							FilePathName(thisfile->vfd))));
+
+		/* Set or update the cached size. */
+		if (thisfile->size == InvalidSegmentSize ||
+			(file->common.curOffset + bytestowrite) > thisfile->size)
+			thisfile->size = file->common.curOffset + bytestowrite;
+
+		file->common.curOffset += bytestowrite;
 		wpos += bytestowrite;
 
 		pgBufferUsage.temp_blks_written++;
 	}
-	file->dirty = false;
+	file->common.dirty = false;
 
 	/*
 	 * At this point, curOffset has been advanced to the end of the buffer,
@@ -518,62 +721,148 @@ BufFileDumpBuffer(BufFile *file)
 	 * logical file position, ie, original value + pos, in case that is less
 	 * (as could happen due to a small backwards seek in a dirty buffer!)
 	 */
-	file->curOffset -= (file->nbytes - file->pos);
-	if (file->curOffset < 0)	/* handle possible segment crossing */
+	file->common.curOffset -= (file->common.nbytes - file->common.pos);
+	if (file->common.curOffset < 0) /* handle possible segment crossing */
 	{
-		file->curFile--;
-		Assert(file->curFile >= 0);
-		file->curOffset += MAX_PHYSICAL_FILESIZE;
+		file->common.curFile--;
+		Assert(file->common.curFile >= 0);
+		file->common.curOffset += buffile_max_filesize;
 	}
 
 	/*
 	 * Now we can set the buffer empty without changing the logical position
 	 */
-	file->pos = 0;
-	file->nbytes = 0;
+	file->common.pos = 0;
+	file->common.nbytes = 0;
 }
 
 /*
- * BufFileRead
+ * BufFileDumpBufferEncrypted
  *
- * Like fread() except we assume 1-byte element size and report I/O errors via
- * ereport().
+ * Encrypt buffer and dump it. The functionality is sufficiently different
+ * from BufFileDumpBuffer to be implemented as a separate function. The most
+ * notable difference is that no loop is needed here.
+ *
+ * last_in_segment tells that this should be the last buffer in the segment
+ * file, i.e. curOffset should be advanced even if the buffer is not
+ * full. Pass false if you don't know/care.
  */
-size_t
-BufFileRead(BufFile *file, void *ptr, size_t size)
+static void
+BufFileDumpBufferEncrypted(BufFile *file, bool last_in_segment)
 {
-	size_t		nread = 0;
-	size_t		nthistime;
+	int			bytestowrite;
+	BufFileSegment		*thisfile;
+	BufFilePageHeader	*hdr;
+
+	/*
+	 * Caller's responsibility.
+	 */
+	Assert(file->common.pos <= file->common.nbytes);
 
-	BufFileFlush(file);
+	/*
+	 * See comments in BufFileLoadBuffer();
+	 */
+	Assert(file->common.curOffset % BLCKSZ == 0);
 
-	while (size > 0)
+	/*
+	 * Advance to next component file if necessary and possible.
+	 */
+	if (file->common.curOffset >= buffile_max_filesize)
 	{
-		if (file->pos >= file->nbytes)
-		{
-			/* Try to load more data into buffer. */
-			file->curOffset += file->pos;
-			file->pos = 0;
-			file->nbytes = 0;
-			BufFileLoadBuffer(file);
-			if (file->nbytes <= 0)
-				break;			/* no more data available */
-		}
+		while (file->common.curFile + 1 >= file->numFiles)
+			extendBufFile(file);
+		file->common.curFile++;
+		file->common.curOffset = 0L;
+	}
 
-		nthistime = file->nbytes - file->pos;
-		if (nthistime > size)
-			nthistime = size;
-		Assert(nthistime > 0);
+	/*
+	 * Keep curOffset aligned to BLCKSZ.
+	 *
+	 * Unlike BufFileDumpBuffer(), we don't have to check here how much data
+	 * is available in the segment. According to the code above, currOffset
+	 * should be lower than buffile_max_filesize by non-zero multiple of
+	 * BLCKSZ.
+	 */
+	bytestowrite = BLCKSZ;
 
-		memcpy(ptr, file->buffer.data + file->pos, nthistime);
+	/*
+	 * Fill-in the page header and encrypt everything except for the IV.
+	 */
+	hdr = (BufFilePageHeader *) file->common.buffer.data;
+	BufFileTweak(hdr->tweak, &file->common);
+	Assert(file->common.nbytes >= SizeOfBufFilePageHeader);
+	hdr->nbytes = file->common.nbytes;
+	encrypt_block(file->common.buffer.data + TWEAK_SIZE,
+				  encrypt_buf.data + TWEAK_SIZE,
+				  BLCKSZ - TWEAK_SIZE,
+				  hdr->tweak,
+				  InvalidXLogRecPtr,
+				  InvalidBlockNumber,
+				  EDK_BUFFILE);
+	/* Copy the encrypted tweak. */
+	memcpy(encrypt_buf.data, hdr->tweak, TWEAK_SIZE);
+
+	thisfile = &file->files[file->common.curFile];
+	bytestowrite = FileWrite(thisfile->vfd,
+							 encrypt_buf.data,
+							 bytestowrite,
+							 file->common.curOffset,
+							 WAIT_EVENT_BUFFILE_WRITE,
+							 ERROR);
+
+	/* Set or update the cached size. */
+	if (thisfile->size == InvalidSegmentSize ||
+		(file->common.curOffset + bytestowrite) > thisfile->size)
+		thisfile->size = file->common.curOffset + bytestowrite;
+
+	if (bytestowrite <= 0 || bytestowrite != BLCKSZ)
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not write to file \"%s\": %m",
+						FilePathName(thisfile->vfd))));
 
-		file->pos += nthistime;
-		ptr = (void *) ((char *) ptr + nthistime);
-		size -= nthistime;
-		nread += nthistime;
+	file->common.curOffset += bytestowrite;
+
+	/* Wasn't last_in_segment passed for non-last buffer? */
+	Assert(file->common.curOffset >= buffile_max_filesize ||
+		   !last_in_segment);
+
+	pgBufferUsage.temp_blks_written++;
+	/* For encryption purposes, see BufFileTweak().*/
+	blocks_written++;
+
+	file->common.dirty = false;
+
+	if (file->common.pos >= BLCKSZ || last_in_segment)
+	{
+		Assert(file->common.pos == BLCKSZ || last_in_segment);
+
+		/*
+		 * curOffset points to the beginning of the next buffer, so just reset
+		 * pos and nbytes.
+		 */
+		file->common.pos = file->common.nbytes = SizeOfBufFilePageHeader;
+	}
+	else
+	{
+		/*
+		 * Move curOffset to the beginning of the just-written buffer so it
+		 * stays at BLCKSZ boundary, and preserve pos.
+		 */
+		file->common.curOffset -= BLCKSZ;
 	}
+}
 
-	return nread;
+/*
+ * BufFileRead
+ *
+ * Like fread() except we assume 1-byte element size and report I/O errors via
+ * ereport().
+ */
+size_t
+BufFileRead(BufFile *file, void *ptr, size_t size)
+{
+	return BufFileReadCommon(&file->common, ptr, size, &file->numFiles);
 }
 
 /*
@@ -582,43 +871,10 @@ BufFileRead(BufFile *file, void *ptr, size_t size)
  * Like fwrite() except we assume 1-byte element size and report errors via
  * ereport().
  */
-void
+size_t
 BufFileWrite(BufFile *file, void *ptr, size_t size)
 {
-	size_t		nthistime;
-
-	Assert(!file->readOnly);
-
-	while (size > 0)
-	{
-		if (file->pos >= BLCKSZ)
-		{
-			/* Buffer full, dump it out */
-			if (file->dirty)
-				BufFileDumpBuffer(file);
-			else
-			{
-				/* Hmm, went directly from reading to writing? */
-				file->curOffset += file->pos;
-				file->pos = 0;
-				file->nbytes = 0;
-			}
-		}
-
-		nthistime = BLCKSZ - file->pos;
-		if (nthistime > size)
-			nthistime = size;
-		Assert(nthistime > 0);
-
-		memcpy(file->buffer.data + file->pos, ptr, nthistime);
-
-		file->dirty = true;
-		file->pos += nthistime;
-		if (file->nbytes < file->pos)
-			file->nbytes = file->pos;
-		ptr = (void *) ((char *) ptr + nthistime);
-		size -= nthistime;
-	}
+	return BufFileWriteCommon(&file->common, ptr, size, false);
 }
 
 /*
@@ -627,12 +883,34 @@ BufFileWrite(BufFile *file, void *ptr, size_t size)
  * Like fflush(), except that I/O errors are reported with ereport().
  */
 static void
-BufFileFlush(BufFile *file)
+BufFileFlush(BufFileCommon *file, bool is_transient)
 {
-	if (file->dirty)
-		BufFileDumpBuffer(file);
+	if (!file->dirty)
+		return;
+
+	if (!is_transient)
+	{
+		if (!data_encrypted)
+			BufFileDumpBuffer((BufFile *) file);
+		else
+			BufFileDumpBufferEncrypted((BufFile *) file, false);
 
-	Assert(!file->dirty);
+		Assert(!file->dirty);
+	}
+	else
+	{
+		TransientBufFile *tf = (TransientBufFile *) file;
+
+		BufFileDumpBufferTransient(tf);
+
+		if (file->dirty)
+		{
+			/* Only reached if tf->elevel < ERROR */
+			ereport(tf->elevel,
+					(errcode_for_file_access(),
+					 errmsg("could not flush file \"%s\": %m", tf->path)));
+		}
+	}
 }
 
 /*
@@ -651,12 +929,41 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 {
 	int			newFile;
 	off_t		newOffset;
+	BufFileSegment	*lastSeg;
+	bool		end_of_segment = false;
 
 	switch (whence)
 	{
 		case SEEK_SET:
 			if (fileno < 0)
 				return EOF;
+
+			if (data_encrypted)
+			{
+				off_t	pos_log, pos_phys;
+
+				/*
+				 * The caller thinks that all BLCKSZ bytes in the block are
+				 * usable for the data, so compute the real position in our
+				 * file in which each page contains some metadata
+				 * (BufFilePageHeader).
+				 */
+				pos_log = (off_t) fileno * BYTES_PER_SEGMENT_LOGICAL;
+
+				/*
+				 * We don't expect anyone to seek back more than the file
+				 * size, otherwise it'd be less trivial to handle negative
+				 * offset.
+				 */
+				Assert(abs(offset) <= pos_log || offset >= 0);
+
+				pos_log += offset;
+				pos_phys = BufFileLogicalToPhysicalPos(pos_log);
+
+				fileno = pos_phys / BYTES_PER_SEGMENT;
+				offset = pos_phys % BYTES_PER_SEGMENT;
+			}
+
 			newFile = fileno;
 			newOffset = offset;
 			break;
@@ -667,37 +974,83 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 			 * fileno. Note that large offsets (> 1 GB) risk overflow in this
 			 * add, unless we have 64-bit off_t.
 			 */
-			newFile = file->curFile;
-			newOffset = (file->curOffset + file->pos) + offset;
+			if (!data_encrypted)
+			{
+				newFile = file->common.curFile;
+				newOffset = (file->common.curOffset + file->common.pos) + offset;
+			}
+			else
+			{
+				off_t	pos_log, pos_phys;
+
+				/* 'offset' is the logical position, so treat it accordingly */
+				pos_phys = file->common.curFile * BYTES_PER_SEGMENT +
+					file->common.curOffset + file->common.pos;
+				pos_log = BufFilePhysicalToLogicalPos(pos_phys);
+
+				/*
+				 * We don't expect anyone to seek back more than the file
+				 * size, otherwise it'd be less trivial to handle negative
+				 * offset.
+				 */
+				Assert(abs(offset) <= pos_log || offset >= 0);
+
+				pos_log += offset;
+				pos_phys = BufFileLogicalToPhysicalPos(pos_log);
+
+				newFile = pos_phys / BYTES_PER_SEGMENT;
+				newOffset = pos_phys % BYTES_PER_SEGMENT;
+			}
 			break;
 		case SEEK_END:
 
+			/* Non-zero position is currently not supported. */
+			Assert(fileno == 0 && offset == 0);
+
 			/*
 			 * The file size of the last file gives us the end offset of that
 			 * file.
 			 */
 			newFile = file->numFiles - 1;
-			newOffset = FileSize(file->files[file->numFiles - 1]);
-			if (newOffset < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not determine size of temporary file \"%s\" from BufFile \"%s\": %m",
-								FilePathName(file->files[file->numFiles - 1]),
-								file->name)));
+			lastSeg = &file->files[file->numFiles - 1];
+			newOffset = BufFileSegmentSize(lastSeg);
+
+			if (data_encrypted)
+			{
+				/*
+				 * Reading/writing of an encrypted file starts at block
+				 * boundary.
+				 */
+				Assert(newOffset % BLCKSZ == 0);
+
+				/* Adjust the end offset of the segment file. */
+				if (newOffset > 0)
+				{
+					PGAlignedBlock	buffer;
+
+					newOffset -= BLCKSZ;
+					newOffset += BufFileGetUsefulBytes(lastSeg->vfd, newOffset,
+													   &buffer);
+				}
+			}
 			break;
 		default:
 			elog(ERROR, "invalid whence: %d", whence);
 			return EOF;
 	}
-	while (newOffset < 0)
+	/* Negative offset for data_encrypted had to be handled already. */
+	if (!data_encrypted)
 	{
-		if (--newFile < 0)
-			return EOF;
-		newOffset += MAX_PHYSICAL_FILESIZE;
+		while (newOffset < 0)
+		{
+			if (--newFile < 0)
+				return EOF;
+			newOffset += buffile_max_filesize;
+		}
 	}
-	if (newFile == file->curFile &&
-		newOffset >= file->curOffset &&
-		newOffset <= file->curOffset + file->nbytes)
+	if (newFile == file->common.curFile &&
+		newOffset >= file->common.curOffset &&
+		newOffset <= file->common.curOffset + file->common.nbytes)
 	{
 		/*
 		 * Seek is to a point within existing buffer; we can just adjust
@@ -705,11 +1058,11 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 		 * whether reading or writing, but buffer remains dirty if we were
 		 * writing.
 		 */
-		file->pos = (int) (newOffset - file->curOffset);
+		file->common.pos = (int) (newOffset - file->common.curOffset);
 		return 0;
 	}
 	/* Otherwise, must reposition buffer, so flush any dirty data */
-	BufFileFlush(file);
+	BufFileFlush(&file->common, false);
 
 	/*
 	 * At this point and no sooner, check for seek past last segment. The
@@ -717,33 +1070,87 @@ BufFileSeek(BufFile *file, int fileno, off_t offset, int whence)
 	 * not work (at least not with this code).
 	 */
 
-	/* convert seek to "start of next seg" to "end of last seg" */
-	if (newFile == file->numFiles && newOffset == 0)
+	/*
+	 * Convert seek to "start of next seg" to "end of last seg". If
+	 * data_encrypted, the page header itself is not a reason to increment
+	 * newFile right now.
+	 */
+	if (newFile == file->numFiles &&
+		(newOffset == 0 ||
+		 (data_encrypted && newOffset == SizeOfBufFilePageHeader)))
 	{
 		newFile--;
-		newOffset = MAX_PHYSICAL_FILESIZE;
+		newOffset = buffile_max_filesize;
+		end_of_segment = true;
 	}
-	while (newOffset > MAX_PHYSICAL_FILESIZE)
+	while (newOffset > buffile_max_filesize)
 	{
 		if (++newFile >= file->numFiles)
 			return EOF;
-		newOffset -= MAX_PHYSICAL_FILESIZE;
+		newOffset -= buffile_max_filesize;
 	}
 	if (newFile >= file->numFiles)
 		return EOF;
 	/* Seek is OK! */
-	file->curFile = newFile;
-	file->curOffset = newOffset;
-	file->pos = 0;
-	file->nbytes = 0;
+	file->common.curFile = newFile;
+	if (!data_encrypted)
+	{
+		file->common.curOffset = newOffset;
+		file->common.pos = 0;
+		file->common.nbytes = 0;
+	}
+	else
+	{
+		/* Now we can finally account for the header. */
+		if (end_of_segment)
+			newOffset = BYTES_PER_SEGMENT + SizeOfBufFilePageHeader;
+
+		/* Offset of an encrypted buffer must be a multiple of BLCKSZ. */
+		file->common.pos = newOffset % BLCKSZ;
+		file->common.curOffset = newOffset - file->common.pos;
+		/* BufFileLoadBuffer() will set nbytes. */
+
+		/*
+		 * Load and decrypt the existing part of the buffer. Since curOffset
+		 * must be at block boundary (as opposed to setting it to newOffset),
+		 * we need to load the data between curOffset and newOffset, otherwise
+		 * we could overwrite this part with what the unrelated data we
+		 * currently have in the buffer.
+		 */
+		BufFileLoadBuffer(file);
+
+		if (BUFFER_IS_EMPTY(&file->common))
+		{
+			/*
+			 * The data requested is not in the file, but this is not an
+			 * error.
+			 */
+			return 0;
+		}
+	}
 	return 0;
 }
 
 void
 BufFileTell(BufFile *file, int *fileno, off_t *offset)
 {
-	*fileno = file->curFile;
-	*offset = file->curOffset + file->pos;
+	if (!data_encrypted)
+	{
+		*fileno = file->common.curFile;
+		*offset = file->common.curOffset + file->common.pos;
+	}
+	else
+	{
+		off_t	pos_phys, pos_log;
+
+		/* Caller should only be interested in the logical offset. */
+		pos_phys = file->common.curFile * BYTES_PER_SEGMENT +
+			file->common.curOffset + file->common.pos;
+		pos_log = BufFilePhysicalToLogicalPos(pos_phys);
+
+		*fileno = pos_log / BYTES_PER_SEGMENT_LOGICAL;
+		*offset = pos_log % BYTES_PER_SEGMENT_LOGICAL;
+	}
 }
 
 /*
@@ -760,28 +1167,68 @@ BufFileTell(BufFile *file, int *fileno, off_t *offset)
 int
 BufFileSeekBlock(BufFile *file, long blknum)
 {
-	return BufFileSeek(file,
-					   (int) (blknum / BUFFILE_SEG_SIZE),
-					   (off_t) (blknum % BUFFILE_SEG_SIZE) * BLCKSZ,
-					   SEEK_SET);
+	if (!data_encrypted)
+		return BufFileSeek(file,
+						   (int) (blknum / buffile_seg_blocks),
+						   (off_t) (blknum % buffile_seg_blocks) * BLCKSZ,
+						   SEEK_SET);
+	else
+		return BufFileSeek(file,
+						   (int) (blknum / buffile_seg_blocks_logical),
+						   (off_t) (blknum % buffile_seg_blocks_logical) * BLCKSZ,
+						   SEEK_SET);
 }
 
-#ifdef NOT_USED
-/*
- * BufFileTellBlock --- block-oriented tell
- *
- * Any fractional part of a block in the current seek position is ignored.
- */
-long
-BufFileTellBlock(BufFile *file)
+static void
+BufFileTweak(char *tweak, BufFileCommon *file)
 {
-	long		blknum;
+	pid_t		pid = MyProcPid;
+	char	*c = tweak;
+
+	/* Any unused bytes should always be defined. */
+	memset(tweak, 0, TWEAK_SIZE);
 
-	blknum = (file->curOffset + file->pos) / BLCKSZ;
-	blknum += file->curFile * BUFFILE_SEG_SIZE;
-	return blknum;
+	StaticAssertStmt(sizeof(pid) + sizeof(blocks_written) <= TWEAK_SIZE,
+					 "tweak components do not fit into TWEAK_SIZE");
+
+	/*
+	 * The tweak consists of PID of the backend and the number of blocks
+	 * written by the backend so far.
+	 */
+	memcpy(c, &pid, sizeof(pid));
+	c += sizeof(pid);
+	memcpy(c, &blocks_written, sizeof(blocks_written));
 }
 
+#ifdef NOT_USED
+/*
+ * BufFileTellBlock --- block-oriented tell
+ *
+ * Any fractional part of a block in the current seek position is ignored.
+ */
+long
+BufFileTellBlock(BufFile *file)
+{
+	long		blknum;
+
+	if (!data_encrypted)
+	{
+		blknum = (file->common.curOffset + file->common.pos) / BLCKSZ;
+		blknum += file->common.curFile * buffile_seg_blocks;
+		return blknum;
+	}
+	else
+	{
+		off_t	pos_phys, pos_log;
+
+		/* Caller should only be interested in the logical offset. */
+		pos_phys = file->common.curFile * BYTES_PER_SEGMENT +
+			file->common.curOffset + file->common.pos;
+		pos_log = BufFilePhysicalToLogicalPos(pos_phys);
+
+		return pos_log / BLCKSZ;
+	}
+}
 #endif
 
 /*
@@ -793,21 +1240,108 @@ BufFileTellBlock(BufFile *file)
 int64
 BufFileSize(BufFile *file)
 {
+	BufFileSegment	*lastFile = &file->files[file->numFiles - 1];
 	int64		lastFileSize;
-
-	Assert(file->fileset != NULL);
+	off_t	size;
 
 	/* Get the size of the last physical file. */
-	lastFileSize = FileSize(file->files[file->numFiles - 1]);
-	if (lastFileSize < 0)
+	lastFileSize = BufFileSegmentSize(lastFile);
+
+	if (!data_encrypted)
+		size = ((file->numFiles - 1) * (int64) buffile_max_filesize) +
+			lastFileSize;
+	else
+	{
+		/* Caller should only be interested in the logical size. */
+		if (lastFileSize > 0)
+		{
+			PGAlignedBlock	buffer;
+			off_t	last_page, size_phys;
+			int	nbytes;
+
+
+			Assert(lastFileSize % BLCKSZ == 0);
+			last_page = lastFileSize - BLCKSZ;
+			nbytes = BufFileGetUsefulBytes(lastFile->vfd, last_page, &buffer);
+			size_phys = last_page + nbytes;
+			lastFileSize = BufFilePhysicalToLogicalPos(size_phys);
+		}
+
+		size = (file->numFiles - 1) * BYTES_PER_SEGMENT_LOGICAL +
+			lastFileSize;
+	}
+
+	return size;
+}
+
+/*
+ * Return value of given segment size. Check the file only if the size is not
+ * cached.
+ */
+static int64
+BufFileSegmentSize(BufFileSegment *seg)
+{
+	off_t	size;
+
+	if (seg->size != InvalidSegmentSize)
+		return seg->size;
+
+	size = FileSize(seg->vfd);
+	if (size < 0)
 		ereport(ERROR,
 				(errcode_for_file_access(),
-				 errmsg("could not determine size of temporary file \"%s\" from BufFile \"%s\": %m",
-						FilePathName(file->files[file->numFiles - 1]),
-						file->name)));
+				 errmsg("could not determine size of temporary file \"%s\": %m",
+						FilePathName(seg->vfd))));
 
-	return ((file->numFiles - 1) * (int64) MAX_PHYSICAL_FILESIZE) +
-		lastFileSize;
+	seg->size = size;
+	return size;
+}
+
+/*
+ * Check whether the buffer contains the last block of the temporary file.
+ *
+ * The meaning of numSegments is as the comment of BufFileReadCommon()
+ * explains.
+ */
+static bool
+BufFileLastBlock(BufFileCommon *file, int *numSegments)
+{
+	bool is_transient = numSegments == NULL;
+
+	/* Should only be called on an encrypted file. */
+	Assert(data_encrypted);
+
+	if (is_transient || (file->curFile + 1) == *numSegments)
+	{
+		uint64	seg_size;
+		BufFileSegment	*seg;
+
+		/* The last segment, need to check the size. */
+
+		if (!is_transient)
+		{
+			BufFile	*bf = (BufFile *) file;
+
+			seg = &bf->files[file->curFile];
+		}
+		else
+		{
+			TransientBufFile	*tf = (TransientBufFile *) file;
+
+			seg = &tf->file;
+		}
+		seg_size = BufFileSegmentSize(seg);
+
+		/* Last block in the file/segment? */
+		if ((file->curOffset + BLCKSZ) >= seg_size)
+			return true;
+		else
+			/* Lower than last block. */
+			return false;
+	}
+	else
+		/* Lower than the last segment. */
+		return false;
 }
 
 /*
@@ -819,11 +1353,10 @@ BufFileSize(BufFile *file)
  * called here first.  Resource owners for source and target must match,
  * too.
  *
- * This operation works by manipulating lists of segment files, so the
- * file content is always appended at a MAX_PHYSICAL_FILESIZE-aligned
- * boundary, typically creating empty holes before the boundary.  These
- * areas do not contain any interesting data, and cannot be read from by
- * caller.
+ * This operation works by manipulating lists of segment files, so the file
+ * content is always appended at a buffile_max_filesize-aligned boundary,
+ * typically creating empty holes before the boundary.  These areas do not
+ * contain any interesting data, and cannot be read from by caller.
  *
  * Returns the block number within target where the contents of source
  * begins.  Caller should apply this as an offset when working off block
@@ -832,27 +1365,757 @@ BufFileSize(BufFile *file)
 long
 BufFileAppend(BufFile *target, BufFile *source)
 {
-	long		startBlock = target->numFiles * BUFFILE_SEG_SIZE;
+	long		startBlock;
 	int			newNumFiles = target->numFiles + source->numFiles;
 	int			i;
 
+	if (!data_encrypted)
+		startBlock = target->numFiles * buffile_seg_blocks;
+	else
+		startBlock = target->numFiles * buffile_seg_blocks_logical;
+
 	Assert(target->fileset != NULL);
-	Assert(source->readOnly);
-	Assert(!source->dirty);
+	Assert(source->common.readOnly);
+	Assert(!source->common.dirty);
 	Assert(source->fileset != NULL);
 
 	if (target->resowner != source->resowner)
 		elog(ERROR, "could not append BufFile with non-matching resource owner");
 
-	target->files = (File *)
-		repalloc(target->files, sizeof(File) * newNumFiles);
+	target->files = (BufFileSegment *)
+		repalloc(target->files, sizeof(BufFileSegment) * newNumFiles);
 	for (i = target->numFiles; i < newNumFiles; i++)
 		target->files[i] = source->files[i - target->numFiles];
+
 	target->numFiles = newNumFiles;
 
 	return startBlock;
 }
 
+/*
+ * Open TransientBufFile at given path or create one if it does not
+ * exist. User will be allowed either to write to the file or to read from it,
+ * according to fileFlags, but not both.
+ */
+TransientBufFile *
+BufFileOpenTransient(const char *path, int fileFlags, int elevel)
+{
+	bool		readOnly;
+	bool		append = false;
+	TransientBufFile *file;
+	BufFileCommon *fcommon;
+	File		vfd;
+
+	/* Either read or write mode, but not both. */
+	Assert((fileFlags & O_RDWR) == 0);
+
+	/* Check whether user wants read or write access. */
+	readOnly = (fileFlags & O_WRONLY) == 0;
+
+	if (data_encrypted)
+	{
+		/*
+		 * In the encryption case, even if user will only be allowed to write,
+		 * internally we also need to read, see below.
+		 */
+		fileFlags &= ~O_WRONLY;
+		fileFlags |= O_RDWR;
+
+		/*
+		 * We can only emulate the append behavior by setting curOffset to
+		 * file size because if the underlying file was opened in append mode,
+		 * we could not rewrite the old value of file->common.useful[0] with
+		 * data.
+		 */
+		if (fileFlags & O_APPEND)
+		{
+			append = true;
+			fileFlags &= ~O_APPEND;
+		}
+	}
+
+	/*
+	 * Append mode for read access is not useful, so don't bother implementing
+	 * it.
+	 */
+	Assert(!(readOnly && append));
+
+	errno = 0;
+	vfd = PathNameOpenFile(path, fileFlags);
+	if (vfd < 0)
+	{
+		/*
+		 * If the file is not there, caller should be able to handle the
+		 * condition on his own.
+		 */
+		if (errno == ENOENT)
+			return NULL;
+
+		ereport(elevel,
+				(errcode_for_file_access(),
+				 errmsg("could not open file \"%s\": %m", path)));
+		return NULL;
+	}
+
+	file = (TransientBufFile *) palloc0(sizeof(TransientBufFile));
+	fcommon = &file->common;
+	fcommon->dirty = false;
+	if (!data_encrypted)
+		fcommon->pos = fcommon->nbytes = 0;
+	else
+		fcommon->pos = fcommon->nbytes = SizeOfBufFilePageHeader;
+	fcommon->readOnly = readOnly;
+	fcommon->append = append;
+	fcommon->curFile = 0;
+	file->file.vfd = vfd;
+	file->file.size = InvalidSegmentSize;
+	file->path = pstrdup(path);
+	file->elevel = elevel;
+
+	if (fcommon->append)
+	{
+		/* Position the buffer at the end of the file. */
+		fcommon->curOffset = BufFileSegmentSize(&file->file);
+	}
+	else
+		fcommon->curOffset = 0L;
+
+	/*
+	 * When reading, or when writing in the append mode, we need to consider
+	 * the current status of the file.
+	 */
+	if (data_encrypted && (fcommon->append || readOnly))
+	{
+		Assert(fcommon->curOffset % BLCKSZ == 0);
+
+		if (fcommon->curOffset > 0)
+		{
+			/* Load the last block. */
+			fcommon->curOffset -= BLCKSZ;
+		}
+		BufFileLoadBufferTransient(file);
+		if (file->common.nbytes < 0)
+			return NULL;
+
+		if (fcommon->append && fcommon->nbytes > 0)
+		{
+			Assert(fcommon->nbytes >= SizeOfBufFilePageHeader);
+			fcommon->pos = fcommon->nbytes;
+		}
+	}
+
+	return file;
+}
+
+/*
+ * Close a TransientBufFile.
+ */
+void
+BufFileCloseTransient(TransientBufFile *file)
+{
+	/* Flush any unwritten data. */
+	if (!file->common.readOnly &&
+		file->common.dirty && file->common.nbytes > 0)
+	{
+		BufFileDumpBufferTransient(file);
+
+		if (file->common.dirty)
+		{
+			/* Raise WARNING deliberately, even if file->elevel is ERROR. */
+			ereport(WARNING,
+					(errcode_for_file_access(),
+					 errmsg("could not flush file \"%s\": %m", file->path)));
+		}
+	}
+
+	FileClose(file->file.vfd);
+
+	pfree(file->path);
+	pfree(file);
+}
+
+File
+BufFileTransientGetVfd(TransientBufFile *file)
+{
+	return file->file.vfd;
+}
+
+/*
+ * Load some data into buffer, if possible, starting from file->offset.  At
+ * call, must have dirty = false, pos and nbytes = 0.  On exit, nbytes is
+ * number of bytes loaded.
+ */
+static void
+BufFileLoadBufferTransient(TransientBufFile *file)
+{
+	Assert(!file->common.dirty);
+
+	/*
+	 * Read whatever we can get, up to a full bufferload.
+	 */
+	file->common.nbytes = FileRead(file->file.vfd,
+								   file->common.buffer.data,
+								   sizeof(file->common.buffer),
+								   file->common.curOffset,
+								   WAIT_EVENT_BUFFILE_READ);
+
+	if (file->common.nbytes < 0)
+	{
+		ereport(file->elevel,
+				(errcode_for_file_access(),
+				 errmsg("could not read file \"%s\": %m",
+						FilePathName(file->file.vfd))));
+		return;
+	}
+	/* we choose not to advance offset here */
+
+	if (!data_encrypted)
+		return;
+
+	BufFileAdjustUsefulBytes(&file->common, NULL, file->elevel);
+}
+
+/*
+ * Write contents of a transient file buffer to disk.
+ */
+static void
+BufFileDumpBufferTransient(TransientBufFile *file)
+{
+	BufFileSegment	*seg;
+	int			bytestowrite,
+				nwritten;
+	char	   *write_ptr;
+
+	/* This function should only be needed during write access ... */
+	Assert(!file->common.readOnly);
+
+	/* ... and if there's some work to do. */
+	Assert(file->common.dirty);
+	Assert(file->common.nbytes > 0);
+
+	if (!data_encrypted)
+	{
+		write_ptr = file->common.buffer.data;
+		bytestowrite = file->common.nbytes;
+	}
+	else
+	{
+		BufFilePageHeader	*hdr;
+
+		/*
+		 * Encrypt the whole buffer, see comments of BufFilePageHeader.
+		 */
+		hdr = (BufFilePageHeader *) file->common.buffer.data;
+		BufFileTweak(hdr->tweak, &file->common);
+		Assert(file->common.nbytes >= SizeOfBufFilePageHeader);
+		hdr->nbytes = file->common.nbytes;
+		encrypt_block(file->common.buffer.data + TWEAK_SIZE,
+					  encrypt_buf.data + TWEAK_SIZE,
+					  BLCKSZ - TWEAK_SIZE,
+					  hdr->tweak,
+					  InvalidXLogRecPtr,
+					  InvalidBlockNumber,
+					  EDK_BUFFILE);
+		/* Copy the encrypted tweak. */
+		memcpy(encrypt_buf.data, hdr->tweak, TWEAK_SIZE);
+
+		write_ptr = encrypt_buf.data;
+		bytestowrite = BLCKSZ;
+	}
+
+	seg = &file->file;
+	nwritten = FileWrite(seg->vfd,
+						 write_ptr,
+						 bytestowrite,
+						 file->common.curOffset,
+						 WAIT_EVENT_BUFFILE_WRITE,
+						 file->elevel);
+
+	/* For encryption purposes, see BufFileTweak().*/
+	blocks_written++;
+
+	/* Set or update the cached size. */
+	if (seg->size == InvalidSegmentSize ||
+		(file->common.curOffset + nwritten) > seg->size)
+		seg->size = file->common.curOffset + nwritten;
+
+	/* if write didn't set errno, assume problem is no disk space */
+	if (nwritten != bytestowrite)
+	{
+		ereport(file->elevel,
+				(errcode_for_file_access(),
+				 errmsg("could not write to file \"%s\": %m",
+						FilePathName(seg->vfd))));
+		return;
+	}
+
+	file->common.curOffset += nwritten;
+	file->common.dirty = false;
+
+	if (!data_encrypted)
+		file->common.pos = file->common.nbytes = 0;
+	else
+		file->common.pos = file->common.nbytes = SizeOfBufFilePageHeader;
+}
+
+/*
+ * Like BufFileRead() except it receives pointer to TransientBufFile.
+ */
+size_t
+BufFileReadTransient(TransientBufFile *file, void *ptr, size_t size)
+{
+	return BufFileReadCommon(&file->common, ptr, size, NULL);
+}
+
+/*
+ * Like BufFileWrite() except it receives pointer to TransientBufFile.
+ */
+size_t
+BufFileWriteTransient(TransientBufFile *file, void *ptr, size_t size)
+{
+	return BufFileWriteCommon(&file->common, ptr, size, true);
+}
+
+/*
+ * BufFileWriteCommon
+ *
+ * Functionality needed by both BufFileRead() and BufFileReadTransient().
+ *
+ * numSegments is a pointer to the number of segment files of a temporary
+ * file, or NULL if the file is a "transient" file (which always consists of a
+ * single segment).
+ */
+static size_t
+BufFileReadCommon(BufFileCommon *file, void *ptr, size_t size,
+				  int *numSegments)
+{
+	size_t		nread = 0;
+	size_t		nthistime;
+	bool is_transient = numSegments == NULL;
+
+	/*
+	 * For encrypted data, even BufFileSeek() tries to load the buffer, so if
+	 * the buffer is empty now, there's nothing to read.
+	 */
+	if (data_encrypted && BUFFER_IS_EMPTY(file))
+		return nread;
+
+	BufFileFlush(file, is_transient);
+	if (file->dirty)
+	{
+		TransientBufFile	*tf = (TransientBufFile *) file;
+		Assert(is_transient);
+
+		/* Only reached if tf->elevel < ERROR */
+		ereport(tf->elevel,
+				(errcode_for_file_access(),
+				 errmsg("could not flush file \"%s\": %m", tf->path)));
+		return nread;
+	}
+
+
+	while (size > 0)
+	{
+		if (file->pos >= file->nbytes)
+		{
+			/*
+			 * In the data_encrypted case, curOffset should always stay at
+			 * BLCKSZ boundary.
+			 */
+			Assert(file->curOffset % BLCKSZ == 0 || !data_encrypted);
+
+			/*
+			 * Try to load more data into the buffer.
+			 *
+			 * In an encrypted file we should only advance if the current
+			 * block is not the last one in the file. Otherwise, we might skip
+			 * unused space in the block and the next write would create a
+			 * hole.
+			 */
+			if (!data_encrypted || !BufFileLastBlock(file, numSegments))
+			{
+				if (!data_encrypted)
+					file->curOffset += file->pos;
+				else
+					file->curOffset += BLCKSZ;
+				file->pos = !data_encrypted ? 0 : SizeOfBufFilePageHeader;
+
+				if (!is_transient)
+					BufFileLoadBuffer((BufFile *) file);
+				else
+				{
+					BufFileLoadBufferTransient((TransientBufFile *) file);
+					/* Only reached if elevel < ERROR. */
+					if (file->nbytes < 0)
+						break;
+				}
+
+				if (BUFFER_IS_EMPTY(file))
+					break;		/* no more data available */
+			}
+			else
+			{
+				/*
+				 * Last block of an encrypted file. Now that we've ran out of
+				 * this block's data, there's no more data available.
+				 */
+				break;
+			}
+		}
+
+		nthistime = file->nbytes - file->pos;
+
+		if (nthistime > size)
+			nthistime = size;
+		Assert(nthistime > 0);
+
+		memcpy(ptr, file->buffer.data + file->pos, nthistime);
+
+		file->pos += nthistime;
+		ptr = (void *) ((char *) ptr + nthistime);
+		size -= nthistime;
+		nread += nthistime;
+	}
+
+	return nread;
+}
+
+/*
+ * BufFileWriteCommon
+ *
+ * Functionality needed by both BufFileWrite() and BufFileWriteTransient().
+ */
+static size_t
+BufFileWriteCommon(BufFileCommon *file, void *ptr, size_t size,
+				   bool is_transient)
+{
+	size_t		nwritten = 0;
+	size_t		nthistime;
+	bool		last_in_seg = false;
+
+	Assert(!file->readOnly);
+
+	while (size > 0)
+	{
+		if (file->pos >= BLCKSZ || last_in_seg)
+		{
+			/* Buffer full, dump it out */
+			if (file->dirty)
+			{
+				if (!is_transient)
+				{
+					if (!data_encrypted)
+						BufFileDumpBuffer((BufFile *)file);
+					else
+					{
+#ifdef USE_ASSERT_CHECKING
+						int	fileno = file->curFile;
+#endif
+						int	off = file->curOffset;
+
+						BufFileDumpBufferEncrypted((BufFile *) file,
+												   last_in_seg);
+						last_in_seg = false;
+
+						/*
+						 * If overwriting, load the next buffer first. Since
+						 * (unlike the unencrypted case) we only dump the
+						 * whole buffers so w/o the load the next dump could
+						 * overwrite even the part of the file that should
+						 * stay unchanged.
+						 */
+						if (!file->append && file->curOffset != off)
+						{
+							/*
+							 * curOffset must have advanced to the next block,
+							 * possibly in the next segment file.
+							 */
+							Assert(file->curOffset == (off + BLCKSZ) ||
+								   ((file->curFile == (fileno + 1)) &&
+									file->curOffset == BLCKSZ));
+
+							BufFileLoadBuffer((BufFile *) file);
+						}
+					}
+				}
+				else
+				{
+					BufFileDumpBufferTransient((TransientBufFile *) file);
+					/* Only reached if elevel < ERROR */
+					if (file->dirty)
+						return nwritten;
+				}
+			}
+			else
+			{
+				/* Hmm, went directly from reading to writing? */
+				Assert(!last_in_seg);
+				Assert(file->pos == BLCKSZ);
+
+				file->curOffset += file->pos;
+				if (!data_encrypted)
+					file->pos = file->nbytes = 0;
+				else
+				{
+					if (!is_transient)
+					{
+						/*
+						 * Load the next buffer so that we don't corrupt the
+						 * existing contents.
+						 */
+						file->pos = SizeOfBufFilePageHeader;
+						BufFileLoadBuffer((BufFile *) file);
+					}
+					else
+					{
+						/*
+						 * For transient file we can get here if an existing
+						 * file was opened for writing in append mode.
+						 */
+						file->pos = file->nbytes = SizeOfBufFilePageHeader;
+					}
+				}
+			}
+
+			/*
+			 * If curOffset changed above, it should still meet the assumption
+			 * that buffer is the I/O unit for encrypted data.
+			 */
+			Assert(file->curOffset % BLCKSZ == 0 || !data_encrypted);
+		}
+
+		nthistime = BLCKSZ - file->pos;
+		if (nthistime > size)
+			nthistime = size;
+		Assert(nthistime > 0);
+
+		/*
+		 * Close the segment if its last logical block ends here. (Transient
+		 * files consist of a single segment so this is not relevant).
+		 */
+		if (data_encrypted && !is_transient)
+		{
+			off_t	next_off;
+
+			/*
+			 * If curFile hasn't been incremented yet, curOffset may still be
+			 * beyond the end of the last dumped buffer. Therefore use modulo.
+			 */
+			next_off = file->curOffset % BYTES_PER_SEGMENT + file->pos;
+
+			/*
+			 * buffile_max_filesize should accommodate exactly
+			 * BYTES_PER_SEGMENT_LOGICAL bytes of payload. Do not try to write
+			 * more into the segment even if part of the last block stays
+			 * unused.
+			 */
+			if (next_off + nthistime > buffile_max_filesize)
+			{
+				nthistime = buffile_max_filesize - next_off;
+				last_in_seg = true;
+
+				/*
+				 * If buffile_max_filesize bytes are already there, flush the
+				 * buffer immediately, or just advance to the next one if
+				 * already flushed.
+				 */
+				if (nthistime == 0)
+				{
+					if (file->dirty)
+						/* BufFileDumpBufferEncrypted will do the rest. */
+						continue;
+					else
+					{
+						file->curOffset += BLCKSZ;
+						file->pos = file->nbytes = SizeOfBufFilePageHeader;
+						/* The problem of the last block is solved now. */
+						last_in_seg = false;
+						/*
+						 * Load the existing contents of the next buffer so
+						 * that the next flush does not corrupt it.
+						 */
+						BufFileLoadBuffer((BufFile *) file);
+					}
+				}
+			}
+		}
+
+		memcpy(file->buffer.data + file->pos, ptr, nthistime);
+
+		file->dirty = true;
+		file->pos += nthistime;
+		if (file->nbytes < file->pos)
+			file->nbytes = file->pos;
+
+		ptr = (void *) ((char *) ptr + nthistime);
+		size -= nthistime;
+		nwritten += nthistime;
+	}
+
+	return nwritten;
+}
+
+/*
+ * Retrieve the BufFilePageHeader.nbytes field from the page of 'segment' file
+ * which starts at 'offset'. The whole page we get the information from will
+ * end up in the memory pointed to by 'buffer'.
+ */
+static int16
+BufFileGetUsefulBytes(File segment, off_t offset, PGAlignedBlock *buffer)
+{
+	BufFilePageHeader	*hdr;
+	char	*data = buffer->data;
+
+	/* Encrypted file is flushed one buffer at a time. */
+	Assert(offset % BLCKSZ == 0);
+
+	/*
+	 * Read the information on bytes used in the last page of the
+	 * segment.
+	 */
+	if (FileRead(segment,
+				 data,
+				 BLCKSZ,
+				 offset,
+				 WAIT_EVENT_BUFFILE_READ) != sizeof(*buffer))
+		ereport(ERROR,
+				(errcode_for_file_access(),
+				 errmsg("could not read the page from BufFile \"%s\" at offset %zu: %m",
+						FilePathName(segment), offset)));;
+
+	/* Get the number of useful bytes in the last buffer. */
+	hdr = (BufFilePageHeader *) buffer;
+	decrypt_block(data + TWEAK_SIZE,
+				  data + TWEAK_SIZE,
+				  BLCKSZ - TWEAK_SIZE,
+				  hdr->tweak,
+				  InvalidBlockNumber,
+				  EDK_BUFFILE);
+
+	return hdr->nbytes;
+}
+
+/*
+ * After the buffer has been loaded, adjust the usage info if trailing part is
+ * actually not used. The point is that BLCKSZ bytes is always written if the
+ * file is encrypted.
+ *
+ * 'segments' is an array of file segments, or NULL for a transient file.
+ */
+static void
+BufFileAdjustUsefulBytes(BufFileCommon *file, BufFileSegment *segments,
+						 int elevel)
+{
+	BufFilePageHeader	*hdr;
+	bool is_transient = segments == NULL;
+
+	/* This function is only needed for encrypted files. */
+	Assert(data_encrypted);
+
+	/*
+	 * Only the whole blocks are written/read in the data_encrypted case.
+	 */
+	if (file->nbytes % BLCKSZ != 0 || file->curOffset % BLCKSZ != 0)
+	{
+		ereport(elevel,
+				(errmsg("incorrect size of encrypted BufFile")));
+		/* Mark the buffer contents invalid. */
+		file->nbytes = -1;
+		return;
+	}
+
+	if (file->nbytes == 0)
+	{
+		/* Maintain the convention that nbytes accounts for the header. */
+		file->nbytes = SizeOfBufFilePageHeader;
+
+		/*
+		 * If the caller couldn't read any data, we should erase the existing
+		 * contents. We might be past the end of the file due to seek now, and
+		 * therefore the next write is not guaranteed to overwrite the leading
+		 * part of the buffer.
+		 */
+		memset(file->buffer.data + file->nbytes, 0, BLCKSZ - file->nbytes);
+	}
+	else if (!is_transient && IsAllZero(file->buffer.data, BLCKSZ))
+	{
+		/*
+		 * Looks like a hole due to lseek() - user should really see zeroes,
+		 * so do not lower file->nbytes. This should not happen to a transient
+		 * file as it does not support lseek().
+		 */
+	}
+	else
+	{
+		/* Decrypt the buffer. */
+		hdr = (BufFilePageHeader *) file->buffer.data;
+		decrypt_block(file->buffer.data + TWEAK_SIZE,
+					  file->buffer.data + TWEAK_SIZE,
+					  BLCKSZ - TWEAK_SIZE,
+					  hdr->tweak,
+					  InvalidBlockNumber,
+					  EDK_BUFFILE);
+
+		/* Isn't the header corrupt? */
+		if (hdr->nbytes > file->nbytes ||
+			hdr->nbytes < SizeOfBufFilePageHeader)
+		{
+			ereport(elevel,
+					(errmsg("encrypted BufFile has corrupt page header")));
+			/* Mark the buffer contents invalid. */
+			file->nbytes = -1;
+			return;
+		}
+
+		/* Adjust the usage information if needed. */
+		if (hdr->nbytes < file->nbytes)
+		{
+			if (!is_transient)
+			{
+				uint64	seg_size;
+
+				/* Check the size of the current physical file. */
+				seg_size = BufFileSegmentSize(&segments[file->curFile]);
+
+				/* Is the current buffer at the end of the segment file? */
+				if (file->curOffset + BLCKSZ < seg_size)
+				{
+					/*
+					 * Not at the end, so it should be a hole created by
+					 * lseek(). All the data beyond hdr->nbytes should be
+					 * zeroes.
+					 */
+					MemSet(file->buffer.data + hdr->nbytes, 0,
+						   BLCKSZ - hdr->nbytes);
+
+					/*
+					 * The zeroes should be available to the user, so do not
+					 * lower file->nbytes.
+					 */
+				}
+				else
+				{
+					Assert(file->curOffset + BLCKSZ == seg_size);
+
+					/*
+					 * We're at the end of the segment. Data beyond
+					 * hdr->nbytes should only be padding up to BLCKSZ.
+					 */
+					file->nbytes = hdr->nbytes;
+				}
+			}
+			else
+			{
+				/*
+				 * There's no lseek for transient files, so there should be no
+				 * holes in it. Thus we should be at the end of the file.
+				 */
+				file->nbytes = hdr->nbytes;
+			}
+		}
+	}
+}
+
 /*
  * Truncate a BufFile created by BufFileCreateShared up to the given fileno and
  * the offset.
@@ -861,11 +2124,30 @@ void
 BufFileTruncateShared(BufFile *file, int fileno, off_t offset)
 {
 	int			numFiles = file->numFiles;
-	int			newFile = fileno;
-	off_t		newOffset = file->curOffset;
+	int			newFile;
+	off_t		newOffset;
 	char		segment_name[MAXPGPATH];
 	int			i;
 
+	if (data_encrypted)
+	{
+		off_t	pos_log, pos_phys;
+
+		/*
+		 * The caller thinks that all BLCKSZ bytes in the block are usable for
+		 * the data, so compute the real position in our file in which each
+		 * page contains some metadata (BufFilePageHeader).
+		 */
+		pos_log = (off_t) fileno * BYTES_PER_SEGMENT_LOGICAL + offset;
+		pos_phys = BufFileLogicalToPhysicalPos(pos_log);
+
+		fileno = pos_phys / BYTES_PER_SEGMENT;
+		offset = pos_phys % BYTES_PER_SEGMENT;
+	}
+
+	newFile = fileno;
+	newOffset = file->common.curOffset;
+
 	/*
 	 * Loop over all the files up to the given fileno and remove the files
 	 * that are greater than the fileno and truncate the given file up to the
@@ -877,14 +2159,14 @@ BufFileTruncateShared(BufFile *file, int fileno, off_t offset)
 		if ((i != fileno || offset == 0) && i != 0)
 		{
 			SharedSegmentName(segment_name, file->name, i);
-			FileClose(file->files[i]);
+			FileClose(file->files[i].vfd);
 			if (!SharedFileSetDelete(file->fileset, segment_name, true))
 				ereport(ERROR,
 						(errcode_for_file_access(),
 						 errmsg("could not delete shared fileset \"%s\": %m",
 								segment_name)));
 			numFiles--;
-			newOffset = MAX_PHYSICAL_FILESIZE;
+			newOffset = BYTES_PER_SEGMENT;
 
 			/*
 			 * This is required to indicate that we have deleted the given
@@ -895,12 +2177,84 @@ BufFileTruncateShared(BufFile *file, int fileno, off_t offset)
 		}
 		else
 		{
-			if (FileTruncate(file->files[i], offset,
-							 WAIT_EVENT_BUFFILE_TRUNCATE) < 0)
-				ereport(ERROR,
-						(errcode_for_file_access(),
-						 errmsg("could not truncate file \"%s\": %m",
-								FilePathName(file->files[i]))));
+			if (!data_encrypted)
+			{
+				if (FileTruncate(file->files[i].vfd, offset,
+								 WAIT_EVENT_BUFFILE_TRUNCATE) < 0)
+					ereport(ERROR,
+							(errcode_for_file_access(),
+							 errmsg("could not truncate file \"%s\": %m",
+									FilePathName(file->files[i].vfd))));
+				file->files[i].size = offset;
+			}
+			else
+			{
+				off_t	offset_phys;
+				BufFileSegment	*thisfile = &file->files[i];
+
+				/* Encrypted file can only be truncated at block boundary. */
+				if (offset % BLCKSZ == 0)
+					offset_phys = offset;
+				else
+					offset_phys = offset - offset % BLCKSZ + BLCKSZ;
+
+				if (FileTruncate(thisfile->vfd, offset_phys,
+								 WAIT_EVENT_BUFFILE_TRUNCATE) < 0)
+					ereport(ERROR,
+							(errcode_for_file_access(),
+							 errmsg("could not truncate file \"%s\": %m",
+									FilePathName(thisfile->vfd))));
+				thisfile->size = offset_phys;
+
+				/*
+				 * If only part of the last page should remain valid, update
+				 * the page header.
+				 */
+				if (offset_phys != offset)
+				{
+					PGAlignedBlock	buffer;
+					int		nbytes;
+					off_t	off_page = offset - offset % BLCKSZ;
+					int	nbytes_new = offset % BLCKSZ;
+
+					nbytes = BufFileGetUsefulBytes(thisfile->vfd, off_page,
+												   &buffer);
+					if (nbytes_new < nbytes)
+					{
+						BufFilePageHeader	*hdr;
+						int	written;
+
+						/*
+						 * Update the header, encrypt the page again and write
+						 * it.
+						 */
+						hdr = (BufFilePageHeader *) buffer.data;
+						hdr->nbytes = nbytes_new;
+						encrypt_block(buffer.data + TWEAK_SIZE,
+									  buffer.data + TWEAK_SIZE,
+									  BLCKSZ - TWEAK_SIZE,
+									  hdr->tweak,
+									  InvalidXLogRecPtr,
+									  InvalidBlockNumber,
+									  EDK_BUFFILE);
+						written = FileWrite(thisfile->vfd,
+											buffer.data,
+											BLCKSZ,
+											off_page,
+											WAIT_EVENT_BUFFILE_WRITE,
+											ERROR);
+						if (written <= 0 || written != BLCKSZ)
+							ereport(ERROR,
+									(errcode_for_file_access(),
+									 errmsg("could not write to file \"%s\": %m",
+											FilePathName(thisfile->vfd))));
+					}
+					else if (nbytes_new >= nbytes)
+						ereport(ERROR,
+								(errmsg("could not truncate file \"%s\", it's already smaller than the requested size",
+										FilePathName(thisfile->vfd))));
+				}
+			}
 			newOffset = offset;
 		}
 	}
@@ -911,39 +2265,70 @@ BufFileTruncateShared(BufFile *file, int fileno, off_t offset)
 	 * If the truncate point is within existing buffer then we can just adjust
 	 * pos within buffer.
 	 */
-	if (newFile == file->curFile &&
-		newOffset >= file->curOffset &&
-		newOffset <= file->curOffset + file->nbytes)
+	if (newFile == file->common.curFile &&
+		newOffset >= file->common.curOffset &&
+		newOffset <= file->common.curOffset + file->common.nbytes)
 	{
 		/* No need to reset the current pos if the new pos is greater. */
-		if (newOffset <= file->curOffset + file->pos)
-			file->pos = (int) (newOffset - file->curOffset);
+		if (newOffset <= file->common.curOffset + file->common.pos)
+			file->common.pos = (int) (newOffset - file->common.curOffset);
 
 		/* Adjust the nbytes for the current buffer. */
-		file->nbytes = (int) (newOffset - file->curOffset);
+		file->common.nbytes = (int) (newOffset - file->common.curOffset);
 	}
-	else if (newFile == file->curFile &&
-			 newOffset < file->curOffset)
+	else if (newFile == file->common.curFile &&
+			 newOffset < file->common.curOffset)
 	{
 		/*
 		 * The truncate point is within the existing file but prior to the
 		 * current position, so we can forget the current buffer and reset the
 		 * current position.
 		 */
-		file->curOffset = newOffset;
-		file->pos = 0;
-		file->nbytes = 0;
+		if (!data_encrypted)
+		{
+			file->common.curOffset = newOffset;
+			file->common.pos = 0;
+			file->common.nbytes = 0;
+		}
+		else
+		{
+			/* Encrypted buffer must start at block boundary. */
+			file->common.pos = newOffset % BLCKSZ;
+			file->common.curOffset = newOffset - file->common.pos;
+
+			/*
+			 * Unlike the unencrypted code path, which allows the buffer to
+			 * start anywhere, caller might need some valid data at the
+			 * beginning of the buffer because the buffer has to start at
+			 * block boundary.
+			 */
+			BufFileLoadBuffer(file);
+			/* Now we have a clean buffer for sure. */
+			file->common.dirty = false;
+		}
 	}
-	else if (newFile < file->curFile)
+	else if (newFile < file->common.curFile)
 	{
 		/*
 		 * The truncate point is prior to the current file, so need to reset
 		 * the current position accordingly.
 		 */
-		file->curFile = newFile;
-		file->curOffset = newOffset;
-		file->pos = 0;
-		file->nbytes = 0;
+		file->common.curFile = newFile;
+
+		if (!data_encrypted)
+		{
+			file->common.curOffset = newOffset;
+			file->common.pos = 0;
+			file->common.nbytes = 0;
+		}
+		else
+		{
+			/* See above. */
+			file->common.pos = newOffset % BLCKSZ;
+			file->common.curOffset = newOffset - file->common.pos;
+			BufFileLoadBuffer(file);
+			file->common.dirty = false;
+		}
 	}
 	/* Nothing to do, if the truncate point is beyond current file. */
 }
diff --git a/src/backend/storage/file/encryption.c b/src/backend/storage/file/encryption.c
new file mode 100644
index 0000000000..e3a1aae46a
--- /dev/null
+++ b/src/backend/storage/file/encryption.c
@@ -0,0 +1,747 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.c
+ *	  This code handles encryption and decryption of data.
+ *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *
+ * See src/backend/storage/file/README.encryption for explanation of the
+ * design.
+ *
+ * IDENTIFICATION
+ *	  src/backend/storage/file/encryption.c
+ *
+ * NOTES
+ *		This file is compiled as both front-end and backend code, so the
+ *		FRONTEND macro must be used to distinguish the case if we need to
+ *		report error or if server-defined variable / function seems useful.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+#include "fmgr.h"
+
+#include <sys/stat.h>
+
+#include "access/xlog.h"
+#include "access/xlogdefs.h"
+#include "common/fe_memutils.h"
+#include "common/sha2.h"
+#include "common/string.h"
+#include "catalog/pg_class.h"
+#include "catalog/pg_control.h"
+#include "storage/bufpage.h"
+#include "storage/encryption.h"
+#include "utils/fmgrprotos.h"
+
+#ifndef FRONTEND
+#include "port.h"
+#include "storage/shmem.h"
+#include "storage/fd.h"
+#include "utils/memutils.h"
+#endif							/* FRONTEND */
+
+#ifdef USE_ENCRYPTION
+#include <openssl/conf.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/opensslv.h>
+
+EVP_CIPHER_CTX *ctx_encrypt, *ctx_decrypt,
+	*ctx_encrypt_buffile, *ctx_decrypt_buffile;
+#endif							/* USE_ENCRYPTION */
+
+#ifndef FRONTEND
+ShmemEncryptionKey *encryption_key_shmem = NULL;
+#endif							/* FRONTEND */
+
+bool		data_encrypted = false;
+
+char encryption_verification[ENCRYPTION_SAMPLE_SIZE];
+
+bool	encryption_setup_done = false;
+
+PGAlignedBlock encrypt_buf;
+char	   *encrypt_buf_xlog = NULL;
+
+#ifdef USE_ENCRYPTION
+static void init_encryption_context(EVP_CIPHER_CTX **ctx_p, bool encrypt,
+									bool buffile);
+static void evp_error(void);
+#endif	/* USE_ENCRYPTION */
+
+#ifndef FRONTEND
+/*
+ * Report space needed for our shared memory area
+ */
+Size
+EncryptionShmemSize(void)
+{
+	return sizeof(ShmemEncryptionKey);
+}
+
+/*
+ * Initialize our shared memory area
+ */
+void
+EncryptionShmemInit(void)
+{
+	bool	found;
+
+	encryption_key_shmem = ShmemInitStruct("Cluster Encryption Key",
+										   EncryptionShmemSize(),
+										   &found);
+	if (!IsUnderPostmaster)
+	{
+		Assert(!found);
+
+		encryption_key_shmem->received = false;
+		encryption_key_shmem->empty = false;
+	}
+	else
+		Assert(found);
+}
+
+/*
+ * Read encryption key in hexadecimal form from stdin and store it in
+ * encryption_key variable.
+ *
+ * key_len can be used to pass the expected key length. Pass NULL if the
+ * information is not available.
+ *
+ * Returns the key length actually seen.
+ */
+int
+read_encryption_key(read_encryption_key_cb read_char, int *key_len)
+{
+#ifdef USE_ENCRYPTION
+	char	buf[ENCRYPTION_KEY_MAX_CHARS];
+	int		read_len, c;
+	int		key_chars;
+	int		actual_key_len;
+
+	if (key_len)
+		key_chars = *key_len * 2; /* 2 hexadecimal characters per byte */
+	else
+		key_chars = ENCRYPTION_KEY_MAX_CHARS;
+
+	read_len = 0;
+	while ((c = (*read_char)()) != EOF && c != '\n')
+	{
+		if (read_len >= key_chars)
+		{
+			if (key_len)
+				ereport(FATAL,
+						(errmsg("encryption key is too long, should be a %d character hex string",
+								key_chars)));
+			else
+				ereport(FATAL,
+						(errmsg("encryption key is too long")));
+		}
+
+		buf[read_len++] = c;
+	}
+
+	/*
+	 * Cannot check if the key is too short if the expected length is not
+	 * known.
+	 */
+	if (key_len && read_len < key_chars)
+		ereport(FATAL,
+				(errmsg("encryption key is too short, should be a %d character hex string",
+						key_chars)));
+
+	key_chars = read_len;
+	actual_key_len = key_chars / 2;
+
+	/* Turn the hexadecimal representation into an array of bytes. */
+	encryption_key_from_string(buf, actual_key_len);
+
+	return actual_key_len;
+
+#else  /* !USE_ENCRYPTION */
+	/*
+	 * If no encryption implementation is linked and caller requests
+	 * encryption, we should error out here and thus cause the calling process
+	 * to fail (preferably postmaster, so the child processes don't make the
+	 * same mistake).
+	 */
+	ereport(FATAL, (errmsg(ENCRYPTION_NOT_SUPPORTED_MSG)));
+#endif	/* USE_ENCRYPTION */
+}
+#endif							/* !FRONTEND */
+
+
+/*
+ * Initialize encryption subsystem for use. Must be called before any
+ * encryptable data is read from or written to data directory.
+ */
+void
+setup_encryption(void)
+{
+#ifdef USE_ENCRYPTION
+	/*
+	 * Setup OpenSSL.
+	 *
+	 * None of these functions should return a value or raise error.
+	 */
+	ERR_load_crypto_strings();
+	OpenSSL_add_all_algorithms();
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+	OPENSSL_config(NULL);
+#endif
+
+	/* Currently we only use this one cipher. */
+	Assert(DATA_CIPHER_GET_KIND(data_cipher) == PG_CIPHER_AES_CTR_CBC);
+
+	init_encryption_context(&ctx_encrypt, true, false);
+	init_encryption_context(&ctx_decrypt, false, false);
+	init_encryption_context(&ctx_encrypt_buffile, true, true);
+	init_encryption_context(&ctx_decrypt_buffile, false, true);
+
+	/*
+	 * We need multiple pages here, so allocate the memory dynamically instead
+	 * of using PGAlignedBlock. That also ensures it'll be MAXALIGNed, which
+	 * is useful because the buffer will be used for I/O.
+	 *
+	 * Use TopMemoryContext because on server side this code is run by
+	 * postmaster and postmaster context gets freed after fork().
+	 */
+#ifndef FRONTEND
+	encrypt_buf_xlog = (char *) MemoryContextAlloc(TopMemoryContext,
+												   ENCRYPT_BUF_XLOG_SIZE);
+#else
+	encrypt_buf_xlog = (char *) palloc(ENCRYPT_BUF_XLOG_SIZE);
+#endif
+
+	encryption_setup_done = true;
+#else  /* !USE_ENCRYPTION */
+#ifndef FRONTEND
+	/*
+	 * If no encryption implementation is linked and caller requests
+	 * encryption, we should error out here and thus cause the calling process
+	 * to fail (preferably postmaster, so the child processes don't make the
+	 * same mistake).
+	 */
+	ereport(FATAL, (errmsg(ENCRYPTION_NOT_SUPPORTED_MSG)));
+#else
+	/* Front-end shouldn't actually get here, but be careful. */
+	fprintf(stderr, "%s\n", ENCRYPTION_NOT_SUPPORTED_MSG);
+	exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+#endif							/* USE_ENCRYPTION */
+}
+
+/*
+ * Encrypts a fixed value into *buf to verify that encryption key is correct.
+ * Caller provided buf needs to be able to hold at least ENCRYPTION_SAMPLE_SIZE
+ * bytes.
+ */
+void
+sample_encryption(char *buf)
+{
+	char		tweak[TWEAK_SIZE];
+	int			i;
+
+	for (i = 0; i < TWEAK_SIZE; i++)
+		tweak[i] = i;
+
+	encrypt_block("postgresqlcrypt", buf, ENCRYPTION_SAMPLE_SIZE, tweak,
+				  InvalidXLogRecPtr, InvalidBlockNumber, EDK_REL_WAL);
+}
+
+/*
+ * Encrypts one block of data with a specified tweak value. May only be called
+ * when encryption_enabled is true.
+ *
+ * Input and output buffer may point to the same location.
+ *
+ * "size" must be a (non-zero) multiple of ENCRYPTION_BLOCK.
+ *
+ * "tweak" value must be an array of at least TWEAK_SIZE bytes. If NULL is
+ * passed, we suppose that the input data starts with PageHeaderData. In this
+ * case page LSN is not encrypted because we use it as an encryption
+ * initialization vector (IV), and will need that for decryption. Therefore,
+ * if tweak==NULL, valid LSN must be passed. In such a case, page checksum
+ * stays unencrypted too because it should be computed later out of the
+ * encrypted data (the encrypted data is what we actually store to disk).
+ *
+ * "block" is number of relation block to be added to the tweak if we
+ * construct it here. Ignored if a valid tweak is passed.
+ *
+ * All-zero blocks are not encrypted to correctly handle relation extension,
+ * and also to simplify handling of holes created by seek past EOF and
+ * consequent write (see buffile.c). And specifically for relation pages, the
+ * problem is that empty page does not have valid LSN.
+ */
+void
+encrypt_block(const char *input, char *output, Size size, char *tweak,
+			  XLogRecPtr lsn, BlockNumber block,
+			  EncryptedDataKind data_kind)
+{
+#ifdef USE_ENCRYPTION
+	EVP_CIPHER_CTX *ctx;
+	int			out_size;
+	char	tweak_loc[TWEAK_SIZE];
+
+	Assert(data_encrypted);
+
+	/*
+	 * If caller passed no tweak, we assume this is relation page and LSN
+	 * should be used.
+	 */
+	if (tweak == NULL)
+	{
+		size_t	unencr_size;
+		char	*c = tweak_loc;
+
+		Assert(block != InvalidBlockNumber);
+		Assert(!XLogRecPtrIsInvalid(lsn));
+
+		memset(c, 0, TWEAK_SIZE);
+
+		/*
+		 * The CTR mode counter is big endian (see crypto/modes/ctr128.c in
+		 * OpenSSL) and the lower part is used by OpenSSL internally.
+		 * Initialize the upper 12 bytes (8 for LSN + 4 for the block number)
+		 * and leave the lower eight to OpenSSL - as the counter is increased
+		 * once per 16 bytes of input, and as we hardly ever encrypt more than
+		 * BLCKSZ bytes at a time, it's not possible for the lower part to
+		 * overflow into the upper one: the maximum value of BLCKSZ is 2^15
+		 * and the encryption block takes 2^4 bytes, so the counter should not
+		 * exceed 2^11. Thus the counter needs no more than 11 bits.
+		 *
+		 * Note that we copy the lsn from the argument, not from the input
+		 * buffer. Since "input" can be a shared buffer locked only in shared
+		 * mode, MarkBufferDirtyHint() can update the LSN while we're copying
+		 * it. Thus the LSN we use in the tweak could be different from the
+		 * one we write to "output" below, and it would be impossible to
+		 * decrypt the page.
+		 */
+		PageSetLSN(c, lsn);
+		c += sizeof(PageXLogRecPtr);
+
+		/*
+		 * Add the block number, in case a single WAL record affects two (or
+		 * more?) pages. Likewise, different endian-ness of the block number
+		 * does not affect its uniqueness.
+		 */
+		memcpy(c, &block, sizeof(BlockNumber));
+
+		tweak = tweak_loc;
+
+		/*
+		 * Copy the LSN to the output. Again, use the argument, not the
+		 * input buffer.
+		 */
+		if (input != output)
+			PageSetLSN(output, lsn);
+
+		/* Do not encrypt the LSN and checksum. */
+		unencr_size = offsetof(PageHeaderData, pd_flags);
+		input += unencr_size;
+		output += unencr_size;
+		size -= unencr_size;
+	}
+	/*
+	 * Empty page is not worth encryption, and encryption of zeroes wouldn't
+	 * even be secure.
+	 */
+	else if (IsAllZero(input, size))
+	{
+		if (input != output)
+			memset(output, 0, size);
+		return;
+	}
+
+	ctx = data_kind != EDK_BUFFILE ? ctx_encrypt : ctx_encrypt_buffile;
+
+	/*
+	 * The amount of encrypted data should be a multiple of the encryption
+	 * block size.
+	 */
+#ifdef USE_ASSERT_CHECKING
+	if (EVP_CIPHER_CTX_block_size(ctx) > 1)
+		Assert(size % EVP_CIPHER_CTX_block_size(ctx) == 0);
+#endif
+
+	/* For the AES-CBC mode make sure the IV is unpredictable. */
+	if (data_kind == EDK_BUFFILE)
+	{
+		char	tweak_iv[TWEAK_SIZE];
+
+		memset(tweak_iv, 0, TWEAK_SIZE);
+
+		if (EVP_EncryptInit_ex(ctx, NULL, NULL, encryption_key,
+							   (unsigned char *) tweak_iv) != 1)
+			evp_error();
+
+		if (EVP_EncryptUpdate(ctx, (unsigned char *) tweak,
+							  &out_size, (unsigned char *) tweak,
+							  TWEAK_SIZE) != 1)
+			evp_error();
+
+		if (out_size != TWEAK_SIZE)
+		{
+#ifndef FRONTEND
+			ereport(ERROR, (errmsg("Some data left undecrypted")));
+#else
+			/* Front-end shouldn't actually get here, but be careful. */
+			fprintf(stderr, "Some data left undecrypted\n");
+			exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+		}
+
+		/* Initialize again, using the encrypted IV. */
+		if (EVP_EncryptInit_ex(ctx, NULL, NULL, encryption_key,
+							   (unsigned char *) tweak) != 1)
+			evp_error();
+	}
+	else
+		if (EVP_EncryptInit_ex(ctx, NULL, NULL, encryption_key,
+							   (unsigned char *) tweak) != 1)
+			evp_error();
+
+	/* Do the actual encryption. */
+	if (EVP_EncryptUpdate(ctx, (unsigned char *) output,
+						  &out_size, (unsigned char *) input, size) != 1)
+		evp_error();
+
+	/*
+	 * The EVP documentation seems to allow that not all data is encrypted
+	 * at the same time, but the low level code does encrypt everything.
+	 */
+	if (out_size != size)
+	{
+#ifndef FRONTEND
+		ereport(ERROR, (errmsg("Some data left unencrypted")));
+#else
+		/* Front-end shouldn't actually get here, but be careful. */
+		fprintf(stderr, "Some data left unencrypted\n");
+		exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+	}
+#else  /* !USE_ENCRYPTION */
+	/* data_encrypted should not be set */
+	Assert(false);
+#endif							/* USE_ENCRYPTION */
+}
+
+/*
+ * Decrypts one block of data with a specified tweak value. May only be called
+ * when encryption_enabled is true.
+ *
+ * Input and output buffer may point to the same location.
+ *
+ * For detailed comments see encrypt_block().
+ *
+ * Unlike encrypt_block(), we don't expect page LSN to change during
+ * decryption, so we can read it from the input buffer.
+ */
+void
+decrypt_block(const char *input, char *output, Size size, char *tweak,
+			  BlockNumber block, EncryptedDataKind data_kind)
+{
+#ifdef USE_ENCRYPTION
+	EVP_CIPHER_CTX *ctx;
+	int			out_size;
+	char	tweak_loc[TWEAK_SIZE];
+
+	Assert(data_encrypted);
+
+	if (tweak == NULL)
+	{
+		size_t	lsn_size, unencr_size;
+		char	*c = tweak_loc;
+
+		Assert(block != InvalidBlockNumber);
+
+		/*
+		 * LSN is used as encryption IV, so page with invalid LSN shouldn't
+		 * have been encrypted.
+		 */
+		if (XLogRecPtrIsInvalid(PageGetLSN(input)))
+		{
+			if (input != output)
+				memcpy(output, input, size);
+			return;
+		}
+
+		lsn_size = sizeof(PageXLogRecPtr);
+
+		memset(c, 0, TWEAK_SIZE);
+		memcpy(c, input, lsn_size);
+		c += lsn_size;
+		memcpy(c, &block, sizeof(BlockNumber));
+
+		tweak = tweak_loc;
+
+		if (input != output)
+			memcpy(output, input, lsn_size);
+
+		/* Do not encrypt the LSN and checksum. */
+		unencr_size = offsetof(PageHeaderData, pd_flags);
+		input += unencr_size;
+		output += unencr_size;
+		size -= unencr_size;
+	}
+	else if (IsAllZero(input, size))
+	{
+		if (input != output)
+			memset(output, 0, size);
+		return;
+	}
+
+	ctx = data_kind != EDK_BUFFILE ? ctx_encrypt : ctx_encrypt_buffile;
+
+	/*
+	 * The amount of decrypted data should be a multiple of the encryption
+	 * block size.
+	 */
+#ifdef USE_ASSERT_CHECKING
+	if (EVP_CIPHER_CTX_block_size(ctx) > 1)
+		Assert(size % EVP_CIPHER_CTX_block_size(ctx) == 0);
+#endif
+
+	/* The remaining initialization. */
+	if (EVP_DecryptInit_ex(ctx, NULL, NULL, encryption_key,
+						   (unsigned char *) tweak) != 1)
+		evp_error();
+
+	/* Do the actual encryption. */
+	if (EVP_DecryptUpdate(ctx, (unsigned char *) output,
+						  &out_size, (unsigned char *) input, size) != 1)
+		evp_error();
+
+	if (out_size != size)
+	{
+#ifndef FRONTEND
+		ereport(ERROR, (errmsg("Some data left undecrypted")));
+#else
+		/* Front-end shouldn't actually get here, but be careful. */
+		fprintf(stderr, "Some data left undecrypted\n");
+		exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+	}
+#else  /* !USE_ENCRYPTION */
+	/* data_encrypted should not be set */
+	Assert(false);
+#endif							/* USE_ENCRYPTION */
+}
+
+#ifdef USE_ENCRYPTION
+/*
+ * Initialize the OpenSSL context for passed cipher.
+ *
+ * On server side this happens during postmaster startup, so other processes
+ * inherit the initialized context via fork(). There's no reason to do this
+ * again and again in encrypt_block() / decrypt_block(), also because we
+ * should not handle out-of-memory conditions encountered by OpenSSL in
+ * another way than ereport(FATAL). The OOM is much less likely to happen
+ * during postmaster startup, and even if it happens, troubleshooting should
+ * be easier than if it happened during normal operation.
+ *
+ * XXX Do we need to call EVP_CIPHER_CTX_cleanup() (via on_proc_exit callback
+ * for server processes and other way for front-ends)? Not sure it's
+ * necessary, as the initialization does not involve any shared resources
+ * (e.g. files).
+ */
+static void
+init_encryption_context(EVP_CIPHER_CTX **ctx_p, bool encrypt, bool buffile)
+{
+	EVP_CIPHER_CTX *ctx;
+	const EVP_CIPHER *cipher = NULL;
+	int	key_length = DATA_CIPHER_GET_KEY_LENGTH(data_cipher);
+
+	/*
+	 * Currently we use CBC mode for buffile.c because CTR imposes much more
+	 * stringent requirements on IV (i.e. the same IV must not be used
+	 * repeatedly.)
+	 */
+	if (key_length == 16)
+		cipher = !buffile ? EVP_aes_128_ctr() : EVP_aes_128_cbc();
+	else if (key_length == 24)
+		cipher = !buffile ? EVP_aes_192_ctr() : EVP_aes_192_cbc();
+	else if (key_length == 32)
+		cipher = !buffile ? EVP_aes_256_ctr() : EVP_aes_256_cbc();
+	else
+	{
+#ifndef FRONTEND
+		ereport(ERROR, (errmsg("invalid key length %d", key_length)));
+#else
+		/* Front-end shouldn't actually get here, but be careful. */
+		fprintf(stderr, "invalid key length %d", key_length);
+		exit(EXIT_FAILURE);
+#endif	/* FRONTEND */
+	}
+
+	if ((*ctx_p = EVP_CIPHER_CTX_new()) == NULL)
+		evp_error();
+	ctx = *ctx_p;
+
+	if (encrypt)
+	{
+		if (EVP_EncryptInit_ex(ctx, cipher, NULL, NULL, NULL) != 1)
+			evp_error();
+	}
+	else
+	{
+		if (EVP_DecryptInit_ex(ctx, cipher, NULL, NULL, NULL) != 1)
+			evp_error();
+	}
+
+	/* CTR mode is effectively a stream cipher. */
+	Assert((!buffile && EVP_CIPHER_CTX_block_size(ctx) == 1) ||
+		   (buffile && EVP_CIPHER_CTX_block_size(ctx) == 16));
+
+	/*
+	 * No padding is needed. For relation pages the input block size should
+	 * already be a multiple of ENCRYPTION_BLOCK, while for WAL we want to
+	 * avoid encryption of the unused (zeroed) part of the page, see
+	 * backend/storage/file/README.encryption.
+	 *
+	 * XXX Is this setting worth when we don't call EVP_EncryptFinal_ex()
+	 * anyway? (Given the block_size==1, EVP_EncryptFinal_ex() wouldn't do
+	 * anything.)
+	 */
+	EVP_CIPHER_CTX_set_padding(ctx, 0);
+
+	Assert(EVP_CIPHER_CTX_iv_length(ctx) == TWEAK_SIZE);
+	Assert(EVP_CIPHER_CTX_key_length(ctx) == key_length);
+}
+
+#endif							/* USE_ENCRYPTION */
+
+#ifdef USE_ENCRYPTION
+/*
+ * Error callback for openssl.
+ */
+static void
+evp_error(void)
+{
+	ERR_print_errors_fp(stderr);
+#ifndef FRONTEND
+
+	/*
+	 * FATAL is the appropriate level because backend can hardly fix anything
+	 * if encryption / decryption has failed.
+	 *
+	 * XXX Do we yet need EVP_CIPHER_CTX_cleanup() here?
+	 */
+	elog(FATAL, "OpenSSL encountered error during encryption or decryption.");
+#else
+	fprintf(stderr,
+			"OpenSSL encountered error during encryption or decryption.");
+	exit(EXIT_FAILURE);
+#endif							/* FRONTEND */
+}
+#endif /* USE_ENCRYPTION */
+
+/*
+ * Xlog is encrypted page at a time. Each xlog page gets a unique tweak via
+ * timeline, segment and offset.
+ *
+ * The function is located here rather than some of the xlog*.c modules so
+ * that front-end applications can easily use it too.
+ */
+void
+XLogEncryptionTweak(char *tweak, TimeLineID timeline, XLogSegNo segment,
+					uint32 offset)
+{
+	memset(tweak, 0, TWEAK_SIZE);
+	memcpy(tweak, &timeline, sizeof(timeline));
+	tweak += sizeof(timeline);
+	memcpy(tweak, &segment, sizeof(XLogSegNo));
+	tweak += sizeof(XLogSegNo);
+	memcpy(tweak, &offset, sizeof(offset));
+}
+
+/*
+ * md files are encrypted block at a time. Tweak will alias higher numbered
+ * forks for huge tables.
+ */
+void
+mdtweak(char *tweak, RelFileNode *relnode, ForkNumber forknum, BlockNumber blocknum)
+{
+	uint32		fork_and_block = (forknum << 24) ^ blocknum;
+
+	memcpy(tweak, relnode, sizeof(RelFileNode));
+	memcpy(tweak + sizeof(RelFileNode), &fork_and_block, 4);
+}
+
+#ifndef FRONTEND
+/*
+ * Generate non-fake LSN.
+ *
+ * XLOG_NOOP is the easiest way to generate a valid LSN. Fake LSN
+ * is not suitable for permanent relation because it'd be hard to
+ * guarantee that it's not equal to any (existing or future)
+ * regular LSN.
+ *
+ * This approach introduces some overhead (no WAL would be written
+ * w/o encryption) but such a small record per page doesn't seem
+ * terrible.
+ */
+XLogRecPtr
+get_lsn_for_encryption(void)
+{
+	char	xlr_data = '\0';
+	XLogRecPtr	lsn;
+
+	XLogBeginInsert();
+	/* At least 1 byte is required. */
+	XLogRegisterData(&xlr_data, 1);
+	lsn = XLogInsert(RM_XLOG_ID, XLOG_NOOP);
+	return lsn;
+}
+
+/*
+ * Assign fake LSN to a page.
+ */
+void
+set_page_lsn_for_encryption(Page page)
+{
+	XLogRecPtr	lsn;
+
+	if (!data_encrypted)
+		return;
+
+	lsn = get_lsn_for_encryption();
+	PageSetLSN(page, lsn);
+}
+
+/*
+ * Assign the same fake LSN to two different pages.
+ */
+void
+set_page_lsn_for_encryption2(Page page1, Page page2)
+{
+	XLogRecPtr	lsn;
+
+	if (!data_encrypted)
+		return;
+
+	lsn = get_lsn_for_encryption();
+	PageSetLSN(page1, lsn);
+	PageSetLSN(page2, lsn);
+}
+
+/*
+ * Assign the same fake LSN to three different pages.
+ */
+void
+set_page_lsn_for_encryption3(Page page1, Page page2, Page page3)
+{
+	XLogRecPtr	lsn;
+
+	if (!data_encrypted)
+		return;
+
+	lsn = get_lsn_for_encryption();
+	PageSetLSN(page1, lsn);
+	PageSetLSN(page2, lsn);
+	PageSetLSN(page3, lsn);
+}
+#endif	/* !FRONTEND */
diff --git a/src/backend/storage/file/fd.c b/src/backend/storage/file/fd.c
index e76daff495..47a614e7b6 100644
--- a/src/backend/storage/file/fd.c
+++ b/src/backend/storage/file/fd.c
@@ -1516,9 +1516,16 @@ PathNameOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode)
 	 */
 	fnamecopy = strdup(fileName);
 	if (fnamecopy == NULL)
-		ereport(ERROR,
+	{
+		/*
+		 * Some callers (especially BufFileOpenTransient() in the TDE fork)
+		 * might dislike ERROR here.
+		 */
+		ereport(WARNING,
 				(errcode(ERRCODE_OUT_OF_MEMORY),
 				 errmsg("out of memory")));
+		return -1;
+	}
 
 	file = AllocateVfd();
 	vfdP = &VfdCache[file];
@@ -1968,6 +1975,15 @@ FileClose(File file)
 	FreeVfd(file);
 }
 
+/*
+ * The FileIsNotOpen macro for external callers.
+ */
+extern bool
+FileIsClosed(File file)
+{
+	return FileIsNotOpen(file);
+}
+
 /*
  * FilePrefetch - initiate asynchronous read of a given range of the file.
  *
@@ -2086,7 +2102,7 @@ retry:
 
 int
 FileWrite(File file, char *buffer, int amount, off_t offset,
-		  uint32 wait_event_info)
+		  uint32 wait_event_info, int elevel)
 {
 	int			returnCode;
 	Vfd		   *vfdP;
@@ -2122,10 +2138,15 @@ FileWrite(File file, char *buffer, int amount, off_t offset,
 
 			newTotal += past_write - vfdP->fileSize;
 			if (newTotal > (uint64) temp_file_limit * (uint64) 1024)
-				ereport(ERROR,
+			{
+				ereport(elevel,
 						(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),
 						 errmsg("temporary file size exceeds temp_file_limit (%dkB)",
 								temp_file_limit)));
+
+				/* Only reached if elevel < ERROR */
+				return -1;
+			}
 		}
 	}
 
diff --git a/src/backend/storage/freespace/freespace.c b/src/backend/storage/freespace/freespace.c
index 8c12dda238..85e3b4fba5 100644
--- a/src/backend/storage/freespace/freespace.c
+++ b/src/backend/storage/freespace/freespace.c
@@ -4,7 +4,8 @@
  *	  POSTGRES free space map for quickly finding free space in relations
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
@@ -219,6 +220,7 @@ XLogRecordPageWithFreeSpace(RelFileNode rnode, BlockNumber heapBlk,
 
 	if (fsm_set_avail(page, slot, new_cat))
 		MarkBufferDirtyHint(buf, false);
+
 	UnlockReleaseBuffer(buf);
 }
 
@@ -258,13 +260,16 @@ GetRecordedFreeSpace(Relation rel, BlockNumber heapBlk)
  * to update upper-level pages in the FSM.
  */
 BlockNumber
-FreeSpaceMapPrepareTruncateRel(Relation rel, BlockNumber nblocks)
+FreeSpaceMapPrepareTruncateRel(Relation rel, BlockNumber nblocks,
+							   XLogRecPtr recptr)
 {
 	BlockNumber new_nfsmblocks;
 	FSMAddress	first_removed_address;
 	uint16		first_removed_slot;
 	Buffer		buf;
 
+	Assert(InRecovery || XLogRecPtrIsInvalid(recptr));
+
 	RelationOpenSmgr(rel);
 
 	/*
@@ -307,6 +312,19 @@ FreeSpaceMapPrepareTruncateRel(Relation rel, BlockNumber nblocks)
 		MarkBufferDirty(buf);
 		if (!InRecovery && RelationNeedsWAL(rel) && XLogHintBitIsNeeded())
 			log_newpage_buffer(buf, false);
+		else if (data_encrypted)
+		{
+			if (XLogRecPtrIsInvalid(recptr))
+				set_page_lsn_for_encryption(BufferGetPage(buf));
+			else
+			{
+				/*
+				 * Once the page is dirty, the LSN must be set even during
+				 * recovery because it's used as the encryption IV.
+				 */
+				PageSetLSN(BufferGetPage(buf), recptr);
+			}
+		}
 
 		END_CRIT_SECTION();
 
@@ -349,9 +367,13 @@ FreeSpaceMapVacuum(Relation rel)
  * have new free-space information, so update only the upper-level slots
  * covering that block range.  end == InvalidBlockNumber is equivalent to
  * "all the rest of the relation".
+ *
+ * Valid recptr is passed when the function is called during WAL replay, see
+ * visibilitymap_set() for explanation.
  */
 void
-FreeSpaceMapVacuumRange(Relation rel, BlockNumber start, BlockNumber end)
+FreeSpaceMapVacuumRange(Relation rel, BlockNumber start, BlockNumber end,
+						XLogRecPtr recptr)
 {
 	bool		dummy;
 
@@ -637,6 +659,12 @@ fsm_extend(Relation rel, BlockNumber fsm_nblocks)
 
 	while (fsm_nblocks_now < fsm_nblocks)
 	{
+		/*
+		 * Encryption: invalid LSN means that the page should not be
+		 * encrypted. This is o.k. as the page is still empty.
+		 */
+		Assert(XLogRecPtrIsInvalid(PageGetLSN(pg.data)));
+
 		PageSetChecksumInplace((Page) pg.data, fsm_nblocks_now);
 
 		smgrextend(rel->rd_smgr, FSM_FORKNUM, fsm_nblocks_now,
diff --git a/src/backend/storage/freespace/fsmpage.c b/src/backend/storage/freespace/fsmpage.c
index 88ae51e526..eaab7df753 100644
--- a/src/backend/storage/freespace/fsmpage.c
+++ b/src/backend/storage/freespace/fsmpage.c
@@ -22,6 +22,7 @@
  */
 #include "postgres.h"
 
+#include "access/xlog.h"
 #include "storage/bufmgr.h"
 #include "storage/fsm_internals.h"
 
@@ -284,6 +285,13 @@ restart:
 				exclusive_lock_held = true;
 			}
 			fsm_rebuild_page(page);
+
+			/*
+			 * No need to care about enforcing LSN for encryption IV -
+			 * MarkBufferDirtyHint() will take care.
+			 */
+			Assert(!InRecovery);
+
 			MarkBufferDirtyHint(buf, false);
 			goto restart;
 		}
diff --git a/src/backend/storage/ipc/dsm.c b/src/backend/storage/ipc/dsm.c
index b461a5f7e9..17eee2ba24 100644
--- a/src/backend/storage/ipc/dsm.c
+++ b/src/backend/storage/ipc/dsm.c
@@ -37,6 +37,7 @@
 #include "miscadmin.h"
 #include "port/pg_bitutils.h"
 #include "storage/dsm.h"
+#include "storage/encryption.h"
 #include "storage/ipc.h"
 #include "storage/lwlock.h"
 #include "storage/pg_shmem.h"
@@ -154,6 +155,19 @@ dsm_postmaster_startup(PGShmemHeader *shim)
 
 	Assert(!IsUnderPostmaster);
 
+	/*
+	 * If the instance is encrypted, check the dynamic shared memory type
+	 * before shared memory initialization starts. The problem is that the
+	 * data in the shared memory is not encrypted, and due to the mmap type it
+	 * can end up on disk.
+	 */
+#ifdef USE_ENCRYPTION
+	if (data_encrypted &&
+		dynamic_shared_memory_type == DSM_IMPL_MMAP)
+		ereport(FATAL,
+				(errmsg("dynamic_shared_memory_type cannot be \"mmap\" when the instance is encrypted")));
+#endif /* USE_ENCRYPTION */
+
 	/*
 	 * If we're using the mmap implementations, clean up any leftovers.
 	 * Cleanup isn't needed on Windows, and happens earlier in startup for
diff --git a/src/backend/storage/ipc/ipci.c b/src/backend/storage/ipc/ipci.c
index 3e4ec53a97..c9a1e42776 100644
--- a/src/backend/storage/ipc/ipci.c
+++ b/src/backend/storage/ipc/ipci.c
@@ -3,7 +3,8 @@
  * ipci.c
  *	  POSTGRES inter-process communication initialization code.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -150,6 +151,7 @@ CreateSharedMemoryAndSemaphores(void)
 		size = add_size(size, BTreeShmemSize());
 		size = add_size(size, SyncScanShmemSize());
 		size = add_size(size, AsyncShmemSize());
+		size = add_size(size, EncryptionShmemSize());
 #ifdef EXEC_BACKEND
 		size = add_size(size, ShmemBackendArraySize());
 #endif
@@ -269,6 +271,7 @@ CreateSharedMemoryAndSemaphores(void)
 	BTreeShmemInit();
 	SyncScanShmemInit();
 	AsyncShmemInit();
+	EncryptionShmemInit();
 
 #ifdef EXEC_BACKEND
 
diff --git a/src/backend/storage/page/bufpage.c b/src/backend/storage/page/bufpage.c
index 82ca91f597..283fb64eb9 100644
--- a/src/backend/storage/page/bufpage.c
+++ b/src/backend/storage/page/bufpage.c
@@ -3,7 +3,8 @@
  * bufpage.c
  *	  POSTGRES standard buffer page code.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -17,6 +18,7 @@
 #include "access/htup_details.h"
 #include "access/itup.h"
 #include "access/xlog.h"
+#include "common/string.h"
 #include "pgstat.h"
 #include "storage/checksum.h"
 #include "utils/memdebug.h"
@@ -78,6 +80,10 @@ PageInit(Page page, Size pageSize, Size specialSize)
  * treat such a page as empty and without free space.  Eventually, VACUUM
  * will clean up such a page and make it usable.
  *
+ * If "page_encr" is passed, it points to encrypted page and "page" is its
+ * plain form. The point is that checksum needs to be verified before
+ * decryption, but other fields must be checked after that.
+ *
  * If flag PIV_LOG_WARNING is set, a WARNING is logged in the event of
  * a checksum failure.
  *
@@ -85,14 +91,11 @@ PageInit(Page page, Size pageSize, Size specialSize)
  * to pgstat.
  */
 bool
-PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags)
+PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags, Page page_encr)
 {
 	PageHeader	p = (PageHeader) page;
-	size_t	   *pagebytes;
-	int			i;
 	bool		checksum_failure = false;
 	bool		header_sane = false;
-	bool		all_zeroes = false;
 	uint16		checksum = 0;
 
 	/*
@@ -102,10 +105,25 @@ PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags)
 	{
 		if (DataChecksumsEnabled())
 		{
+			Page page_save = NULL;
+
+			if (page_encr)
+			{
+				page_save = page;
+				page = page_encr;
+				p = (PageHeader) page;
+			}
+
 			checksum = pg_checksum_page((char *) page, blkno);
 
 			if (checksum != p->pd_checksum)
 				checksum_failure = true;
+
+			if (page_save)
+			{
+				page = page_save;
+				p = (PageHeader) page;
+			}
 		}
 
 		/*
@@ -126,18 +144,7 @@ PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags)
 	}
 
 	/* Check all-zeroes case */
-	all_zeroes = true;
-	pagebytes = (size_t *) page;
-	for (i = 0; i < (BLCKSZ / sizeof(size_t)); i++)
-	{
-		if (pagebytes[i] != 0)
-		{
-			all_zeroes = false;
-			break;
-		}
-	}
-
-	if (all_zeroes)
+	if (IsAllZero((char *) page, BLCKSZ))
 		return true;
 
 	/*
@@ -1504,8 +1511,15 @@ PageSetChecksumCopy(Page page, BlockNumber blkno)
 {
 	static char *pageCopy = NULL;
 
-	/* If we don't need a checksum, just return the passed-in data */
-	if (PageIsNew(page) || !DataChecksumsEnabled())
+	/*
+	 * If we don't need a checksum, just return the passed-in data.
+	 *
+	 * Note that, if encryption is enabled, PageIsNew() does not tell reliably
+	 * whether the checksum computation should really be skipped. The problem
+	 * is that the field that the function checks can become zero just due to
+	 * the encryption.
+	 */
+	if ((!data_encrypted && PageIsNew(page)) || !DataChecksumsEnabled())
 		return (char *) page;
 
 	/*
@@ -1531,8 +1545,13 @@ PageSetChecksumCopy(Page page, BlockNumber blkno)
 void
 PageSetChecksumInplace(Page page, BlockNumber blkno)
 {
-	/* If we don't need a checksum, just return */
-	if (PageIsNew(page) || !DataChecksumsEnabled())
+	/*
+	 * If we don't need a checksum, just return.
+	 *
+	 * Note that encrypted page is checksumed even if it's empty, see
+	 * PageSetChecksumCopy() for explanation.
+	 */
+	if ((!data_encrypted && PageIsNew(page)) || !DataChecksumsEnabled())
 		return;
 
 	((PageHeader) page)->pd_checksum = pg_checksum_page((char *) page, blkno);
diff --git a/src/backend/storage/smgr/md.c b/src/backend/storage/smgr/md.c
index b4bca7eed6..08e26a7fdd 100644
--- a/src/backend/storage/smgr/md.c
+++ b/src/backend/storage/smgr/md.c
@@ -442,7 +442,8 @@ mdextend(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,
 
 	Assert(seekpos < (off_t) BLCKSZ * RELSEG_SIZE);
 
-	if ((nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_EXTEND)) != BLCKSZ)
+	if ((nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos,
+							WAIT_EVENT_DATA_FILE_EXTEND, ERROR)) != BLCKSZ)
 	{
 		if (nbytes < 0)
 			ereport(ERROR,
@@ -720,7 +721,8 @@ mdwrite(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,
 
 	Assert(seekpos < (off_t) BLCKSZ * RELSEG_SIZE);
 
-	nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_WRITE);
+	nbytes = FileWrite(v->mdfd_vfd, buffer, BLCKSZ, seekpos,
+					   WAIT_EVENT_DATA_FILE_WRITE, ERROR);
 
 	TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE(forknum, blocknum,
 										reln->smgr_rnode.node.spcNode,
diff --git a/src/backend/tcop/postgres.c b/src/backend/tcop/postgres.c
index 2278d8569e..e714953af5 100644
--- a/src/backend/tcop/postgres.c
+++ b/src/backend/tcop/postgres.c
@@ -3,7 +3,8 @@
  * postgres.c
  *	  POSTGRES C Backend Interface
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -65,6 +66,7 @@
 #include "replication/walsender.h"
 #include "rewrite/rewriteHandler.h"
 #include "storage/bufmgr.h"
+#include "storage/encryption.h"
 #include "storage/ipc.h"
 #include "storage/pmsignal.h"
 #include "storage/proc.h"
@@ -4082,6 +4084,43 @@ PostgresMain(int argc, char *argv[],
 	/* We need to allow SIGINT, etc during the initial transaction */
 	PG_SETMASK(&UnBlockSig);
 
+	/*
+	 * Standalone backend operating on an encrypted cluster needs encryption
+	 * key.
+	 *
+	 * We should not use run_encryption_key_command() here because the command
+	 * might read data (password) from stdin, and that would break cases like
+	 * postgres execution by initdb or pg_rewind. (Even if those don't pass
+	 * the command via the -K option, encryption_key_command might be
+	 * initialized via postgresql.conf, so it makes no sense to test it here.)
+	 */
+	if (!IsUnderPostmaster && data_encrypted &&
+		!encryption_setup_done)
+	{
+		char	sample[ENCRYPTION_SAMPLE_SIZE];
+		int		key_length = DATA_CIPHER_GET_KEY_LENGTH(data_cipher);
+
+		/* Display a prompt for user to enter the encryption key. */
+		printf("key> ");
+		fflush(stdout);
+
+		/*
+		 * Read the key from stdin. Pass interactive_getc() as the callback so
+		 * that the reading is interruptible.
+		 */
+		read_encryption_key(interactive_getc, &key_length);
+
+		setup_encryption();
+
+		/* Verify the key. */
+		sample_encryption(sample);
+		if (memcmp(encryption_verification, sample, ENCRYPTION_SAMPLE_SIZE))
+			ereport(FATAL,
+					(errmsg("invalid encryption key"),
+					 errdetail("The passed encryption key does not match"
+							   " database encryption key.")));
+	}
+
 	/*
 	 * General initialization.
 	 *
diff --git a/src/backend/utils/activity/wait_event.c b/src/backend/utils/activity/wait_event.c
index 1a30faf8ad..ed7346bc1e 100644
--- a/src/backend/utils/activity/wait_event.c
+++ b/src/backend/utils/activity/wait_event.c
@@ -618,12 +618,6 @@ pgstat_get_wait_io(WaitEventIO w)
 		case WAIT_EVENT_RELATION_MAP_WRITE:
 			event_name = "RelationMapWrite";
 			break;
-		case WAIT_EVENT_REORDER_BUFFER_READ:
-			event_name = "ReorderBufferRead";
-			break;
-		case WAIT_EVENT_REORDER_BUFFER_WRITE:
-			event_name = "ReorderBufferWrite";
-			break;
 		case WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ:
 			event_name = "ReorderLogicalMappingRead";
 			break;
diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c
index ef62bb8188..72d83c3b1b 100644
--- a/src/backend/utils/misc/guc.c
+++ b/src/backend/utils/misc/guc.c
@@ -6,7 +6,8 @@
  * See src/backend/utils/misc/README for more information.
  *
  *
- * Copyright (c) 2000-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Copyright (c) 2000-2022, PostgreSQL Global Development Group
  * Written by Peter Eisentraut <peter_e@gmx.net>.
  *
  * IDENTIFICATION
@@ -80,8 +81,10 @@
 #include "replication/syncrep.h"
 #include "replication/walreceiver.h"
 #include "replication/walsender.h"
+#include "storage/buffile.h"
 #include "storage/bufmgr.h"
 #include "storage/dsm_impl.h"
+#include "storage/encryption.h"
 #include "storage/fd.h"
 #include "storage/large_object.h"
 #include "storage/pg_shmem.h"
@@ -202,6 +205,7 @@ static const char *show_tcp_keepalives_idle(void);
 static const char *show_tcp_keepalives_interval(void);
 static const char *show_tcp_keepalives_count(void);
 static const char *show_tcp_user_timeout(void);
+static void assign_buffile_seg_blocks(int newval, void *extra);
 static bool check_maxconnections(int *newval, void **extra, GucSource source);
 static bool check_max_worker_processes(int *newval, void **extra, GucSource source);
 static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);
@@ -236,6 +240,10 @@ static void assign_recovery_target_lsn(const char *newval, void *extra);
 static bool check_primary_slot_name(char **newval, void **extra, GucSource source);
 static bool check_default_with_oids(bool *newval, void **extra, GucSource source);
 
+#ifdef USE_ENCRYPTION
+static const char *show_encryption_key_command(void);
+#endif
+
 /* Private functions in guc-file.l that need to be called from guc.c */
 static ConfigVariable *ProcessConfigFileInternal(GucContext context,
 												 bool applySettings, int elevel);
@@ -1996,6 +2004,17 @@ static struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 
+	{
+		{"data_encryption", PGC_INTERNAL, PRESET_OPTIONS,
+			gettext_noop("Shows whether data encryption is turned on for this cluster."),
+			NULL,
+			GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE
+		},
+		&data_encrypted,
+		false,
+		NULL, NULL, NULL
+	},
+
 	{
 		{"syslog_sequence_numbers", PGC_SIGHUP, LOGGING_WHERE,
 			gettext_noop("Add sequence number to syslog messages to avoid duplicate suppression."),
@@ -3553,6 +3572,24 @@ static struct config_int ConfigureNamesInt[] =
 		check_client_connection_check_interval, NULL, NULL
 	},
 
+	{
+		/* NOT for general use */
+		{"buffile_seg_blocks", PGC_SUSET, DEVELOPER_OPTIONS,
+			gettext_noop("Maximum size of BufFile segment."),
+			gettext_noop("This makes testing of some corner cases easier, especially crossing of segment boundary."),
+			GUC_NOT_IN_SAMPLE | GUC_UNIT_BLOCKS
+		},
+		&buffile_seg_blocks,
+		/*
+		 * The segment file size is configurable via this GUC for testing
+		 * purposes, however it should be limited so that multiplication by
+		 * BLCKSZ does not overflow. Actually we restrict the size even more,
+		 * to 1 GB, just like PG core does.
+		 */
+		BUFFILE_SEG_BLOCKS, 2, 0x40000000 / BLCKSZ,
+		NULL, assign_buffile_seg_blocks, NULL
+	},
+
 	/* End-of-list marker */
 	{
 		{NULL, 0, 0, NULL, NULL}, NULL, 0, 0, 0, NULL, NULL, NULL
@@ -4601,6 +4638,19 @@ static struct config_string ConfigureNamesString[] =
 		check_backtrace_functions, assign_backtrace_functions, NULL
 	},
 
+#ifdef USE_ENCRYPTION
+	{
+		{"encryption_key_command", PGC_POSTMASTER, 0,
+			gettext_noop("Sets the shell command that will be called to fetch database encryption key."),
+			NULL,
+			GUC_NO_SHOW_ALL | GUC_SUPERUSER_ONLY
+		},
+		&encryption_key_command,
+		NULL,
+		NULL, NULL, show_encryption_key_command
+	},
+#endif
+
 	/* End-of-list marker */
 	{
 		{NULL, 0, 0, NULL, NULL}, NULL, NULL, NULL, NULL, NULL
@@ -11985,6 +12035,12 @@ show_tcp_user_timeout(void)
 	return nbuf;
 }
 
+static void
+assign_buffile_seg_blocks(int newval, void *extra)
+{
+	BufFileAdjustConfiguration(newval);
+}
+
 static bool
 check_maxconnections(int *newval, void **extra, GucSource source)
 {
@@ -12543,4 +12599,15 @@ check_default_with_oids(bool *newval, void **extra, GucSource source)
 	return true;
 }
 
+#ifdef USE_ENCRYPTION
+static const char *
+show_encryption_key_command(void)
+{
+	if (encryption_key_command)
+		return encryption_key_command;
+	else
+		return "(disabled)";
+}
+#endif
+
 #include "guc-file.c"
diff --git a/src/backend/utils/misc/postgresql.conf.sample b/src/backend/utils/misc/postgresql.conf.sample
index 4557ba7ba8..8b0de97078 100644
--- a/src/backend/utils/misc/postgresql.conf.sample
+++ b/src/backend/utils/misc/postgresql.conf.sample
@@ -117,6 +117,9 @@
 #ssl_passphrase_command = ''
 #ssl_passphrase_command_supports_reload = off
 
+# - Encryption -
+
+#encryption_key_command = ''
 
 #------------------------------------------------------------------------------
 # RESOURCE USAGE (except WAL)
diff --git a/src/bin/Makefile b/src/bin/Makefile
index 2fe0ae6652..46f6281ecc 100644
--- a/src/bin/Makefile
+++ b/src/bin/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin (client programs)
 #
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
 # Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -23,6 +24,7 @@ SUBDIRS = \
 	pg_controldata \
 	pg_ctl \
 	pg_dump \
+	pg_keytool \
 	pg_resetwal \
 	pg_rewind \
 	pg_test_fsync \
diff --git a/src/bin/initdb/.gitignore b/src/bin/initdb/.gitignore
index b3167c46e2..51cbd65af0 100644
--- a/src/bin/initdb/.gitignore
+++ b/src/bin/initdb/.gitignore
@@ -1,4 +1,5 @@
 /localtime.c
+/encryption.c
 
 /initdb
 
diff --git a/src/bin/initdb/Makefile b/src/bin/initdb/Makefile
index a620a5bea0..fa1a122b76 100644
--- a/src/bin/initdb/Makefile
+++ b/src/bin/initdb/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/initdb
 #
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
 # Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -35,7 +36,8 @@ OBJS = \
 	$(WIN32RES) \
 	findtimezone.o \
 	initdb.o \
-	localtime.o
+	localtime.o \
+	encryption.o
 
 all: initdb
 
@@ -46,6 +48,9 @@ initdb: $(OBJS) | submake-libpq submake-libpgport submake-libpgfeutils
 localtime.c: % : $(top_srcdir)/src/timezone/%
 	rm -f $@ && $(LN_S) $< .
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) initdb$(X) '$(DESTDIR)$(bindir)/initdb$(X)'
 
@@ -56,7 +61,7 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/initdb$(X)'
 
 clean distclean maintainer-clean:
-	rm -f initdb$(X) $(OBJS) localtime.c
+	rm -f initdb$(X) $(OBJS) localtime.c encryption.c
 	rm -rf tmp_check
 
 # ensure that changes in datadir propagate into object file
diff --git a/src/bin/initdb/initdb.c b/src/bin/initdb/initdb.c
index 77e621a767..f72e9710be 100644
--- a/src/bin/initdb/initdb.c
+++ b/src/bin/initdb/initdb.c
@@ -38,7 +38,8 @@
  *
  * This code is released under the terms of the PostgreSQL License.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/bin/initdb/initdb.c
@@ -69,11 +70,13 @@
 #include "common/restricted_token.h"
 #include "common/string.h"
 #include "common/username.h"
+#include "fe_utils/encryption.h"
 #include "fe_utils/string_utils.h"
 #include "getaddrinfo.h"
 #include "getopt_long.h"
 #include "mb/pg_wchar.h"
 #include "miscadmin.h"
+#include "storage/encryption.h"
 
 
 /* Ideally this would be in a .h file, but it hardly seems worth the trouble */
@@ -1211,6 +1214,18 @@ setup_config(void)
 
 	snprintf(path, sizeof(path), "%s/postgresql.conf", pg_data);
 
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		snprintf(repltok, sizeof(repltok), "encryption_key_command = '%s'",
+				 escape_quotes(encryption_key_command));
+		conflines = replace_token(conflines, "#encryption_key_command = ''", repltok);
+	}
+#else
+		/* encryption_key_command should not be set */
+		Assert(false);
+#endif
+
 	writefile(path, conflines);
 	if (chmod(path, pg_file_create_mode) != 0)
 	{
@@ -1355,6 +1370,7 @@ bootstrap_template1(void)
 	char	  **bki_lines;
 	char		headerline[MAXPGPATH];
 	char		buf[64];
+	char *encr_opt_str = NULL;
 
 	printf(_("running bootstrap script ... "));
 	fflush(stdout);
@@ -1405,17 +1421,37 @@ bootstrap_template1(void)
 	/* Also ensure backend isn't confused by this environment var: */
 	unsetenv("PGCLIENTENCODING");
 
+	/* Prepare the -K option for the backend. */
+	if (encryption_key_command)
+	{
+		size_t		len;
+
+		len = 3;
+		encr_opt_str = (char *) pg_malloc(len);
+		snprintf(encr_opt_str, len, "-K");
+	}
+	else
+	{
+		encr_opt_str = (char *) pg_malloc(1);
+		encr_opt_str[0] = '\0';
+	}
+
 	snprintf(cmd, sizeof(cmd),
-			 "\"%s\" --boot -x1 -X %u %s %s %s %s",
+			 "\"%s\" --boot -x1 -X %u %s %s %s %s %s",
 			 backend_exec,
 			 wal_segment_size_mb * (1024 * 1024),
 			 data_checksums ? "-k" : "",
+			 encr_opt_str,
 			 boot_options, extra_options,
 			 debug ? "-d 5" : "");
 
 
 	PG_CMD_OPEN;
 
+	/* If the cluster is encrypted, first send the encryption key. */
+	if (encryption_key_command)
+		send_encryption_key(cmdfd);
+
 	for (line = bki_lines; *line != NULL; line++)
 	{
 		PG_CMD_PUTS(*line);
@@ -2252,6 +2288,11 @@ usage(const char *progname)
 	printf(_("  -E, --encoding=ENCODING   set default encoding for new databases\n"));
 	printf(_("  -g, --allow-group-access  allow group read/execute on data directory\n"));
 	printf(_("  -k, --data-checksums      use data page checksums\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command\n"
+			 "                            command that returns encryption key\n"));
+	printf(_("      --key-bits=NBITS      number of bits in the encryption key\n"));
+#endif
 	printf(_("      --locale=LOCALE       set default locale for new databases\n"));
 	printf(_("      --lc-collate=, --lc-ctype=, --lc-messages=LOCALE\n"
 			 "      --lc-monetary=, --lc-numeric=, --lc-time=LOCALE\n"
@@ -2844,6 +2885,40 @@ initialize_data_directory(void)
 	/* Top level PG_VERSION is checked by bootstrapper, so make it first */
 	write_version_file(NULL);
 
+	/*
+	 * If the cluster will be encrypted, write the KDF file so that encryption
+	 * key can be derived from password.
+	 */
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * XXX Since execution of encryption_key_command produce the key (as
+		 * opposed to password), we don't know if the command received the key
+		 * itself or a password. If DBA provided initdb with a key, he will
+		 * never use password in the future (there was no KDF so far so the
+		 * key could not be derived from password, and the password can hardly
+		 * be derived from the key), so the KDF file may be useless. We don't
+		 * have enough information to recognize this special case, so just
+		 * initialize and write the KDF unconditionally.
+		 */
+		init_kdf(encryption_key_length);
+		write_kdf_file(pg_data);
+
+		/*
+		 * The key command is allowed to use pg_keytool, which in turn needs
+		 * the KDF parameters. The KDF parameters are now available so we can
+		 * run the command.
+		 */
+		run_encryption_key_command(pg_data, &encryption_key_length);
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/* Select suitable configuration settings */
 	set_null_conf();
 	test_config_settings();
@@ -2873,6 +2948,10 @@ initialize_data_directory(void)
 
 	PG_CMD_OPEN;
 
+	/* If the cluster is encrypted, first send the encryption key. */
+	if (encryption_key_command)
+		send_encryption_key(cmdfd);
+
 	setup_auth(cmdfd);
 
 	setup_run_file(cmdfd, system_constraints_file);
@@ -2946,6 +3025,10 @@ main(int argc, char *argv[])
 		{"waldir", required_argument, NULL, 'X'},
 		{"wal-segsize", required_argument, NULL, 12},
 		{"data-checksums", no_argument, NULL, 'k'},
+#ifdef	USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+		{"key-bits", required_argument, NULL, 15},
+#endif							/* USE_ENCRYPTION */
 		{"allow-group-access", no_argument, NULL, 'g'},
 		{"discard-caches", no_argument, NULL, 14},
 		{NULL, 0, NULL, 0}
@@ -2960,6 +3043,7 @@ main(int argc, char *argv[])
 	char	   *effective_user;
 	PQExpBuffer start_db_cmd;
 	char		pg_ctl_path[MAXPGPATH];
+	char		*str_key_bits = NULL;
 
 	/*
 	 * Ensure that buffering behavior of stdout matches what it is in
@@ -2989,7 +3073,7 @@ main(int argc, char *argv[])
 
 	/* process command-line options */
 
-	while ((c = getopt_long(argc, argv, "A:dD:E:gkL:nNsST:U:WX:", long_options, &option_index)) != -1)
+	while ((c = getopt_long(argc, argv, "A:dD:E:gkK:L:nNsST:U:WX:", long_options, &option_index)) != -1)
 	{
 		switch (c)
 		{
@@ -3041,6 +3125,14 @@ main(int argc, char *argv[])
 			case 'k':
 				data_checksums = true;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+				break;
+			case 15:
+				str_key_bits = pstrdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'L':
 				share_path = pg_strdup(optarg);
 				break;
@@ -3122,6 +3214,58 @@ main(int argc, char *argv[])
 		exit(1);
 	}
 
+	/*
+	 * Try to retrieve the command from environment variable. We do this
+	 * primarily to create encrypted clusters during automated tests. XXX Not
+	 * sure the variable should be documented. If we do, then pg_ctl should
+	 * probably accept it too.
+	 */
+	if (encryption_key_command == NULL)
+	{
+		encryption_key_command = getenv("PGENCRKEYCMD");
+		if (encryption_key_command && strlen(encryption_key_command) == 0)
+			encryption_key_command = NULL;
+	}
+
+	if (encryption_key_command == NULL && str_key_bits)
+	{
+		pg_log_error("--key-bits is only allowed if --encryption-key-command is used");
+		exit(1);
+	}
+
+	/* Like above, allow setting the key length for testing. */
+	if (str_key_bits == NULL)
+	{
+		str_key_bits = getenv("PGENCRKEYBITS");
+		if (str_key_bits && strlen(str_key_bits) == 0)
+			str_key_bits = NULL;
+	}
+
+	if (str_key_bits)
+	{
+		long	key_bits;
+		char	*endptr;
+
+		key_bits = strtol(str_key_bits, &endptr, 10);
+		if (*endptr != '\0')
+		{
+			pg_log_error("--key-bits must be a valid integer");
+			exit(1);
+		}
+
+		if (key_bits != 128 && key_bits != 192 && key_bits != 256)
+		{
+			pg_log_error("the allowed values of --key-bits are 128, 192 and 256");
+			exit(1);
+		}
+
+		/* Convert the number of bits to the number of bytes. */
+		encryption_key_length = key_bits / 8;
+	}
+	else
+		/* Just set the default value. */
+		encryption_key_length = DEFAULT_ENCRYPTION_KEY_LENGTH;
+
 	atexit(cleanup_directories_atexit);
 
 	/* If we only need to fsync, just do it and exit */
@@ -3219,6 +3363,11 @@ main(int argc, char *argv[])
 	if (pwprompt || pwfilename)
 		get_su_pwd();
 
+	if (encryption_key_command)
+		printf(_("Data encryption is enabled.\n"));
+	else
+		printf(_("Data encryption is disabled.\n"));
+
 	printf("\n");
 
 	initialize_data_directory();
diff --git a/src/bin/pg_basebackup/pg_basebackup.c b/src/bin/pg_basebackup/pg_basebackup.c
index 10350c97d0..0b524ddcce 100644
--- a/src/bin/pg_basebackup/pg_basebackup.c
+++ b/src/bin/pg_basebackup/pg_basebackup.c
@@ -4,7 +4,8 @@
  *
  * Author: Magnus Hagander <magnus@hagander.net>
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *		  src/bin/pg_basebackup/pg_basebackup.c
@@ -27,6 +28,7 @@
 #endif
 
 #include "access/xlog_internal.h"
+#include "common/encryption.h"
 #include "common/file_perm.h"
 #include "common/file_utils.h"
 #include "common/logging.h"
@@ -141,6 +143,7 @@ static bool writerecoveryconf = false;
 static bool do_sync = true;
 static int	standby_message_timeout = 10 * 1000;	/* 10 sec = default */
 static pg_time_t last_progress_report = 0;
+static bool decrypt = false;
 static int32 maxrate = 0;		/* no limit by default */
 static char *replication_slot = NULL;
 static bool temp_replication_slot = true;
@@ -402,6 +405,9 @@ usage(void)
 	printf(_("      --waldir=WALDIR    location for the write-ahead log directory\n"));
 	printf(_("  -X, --wal-method=none|fetch|stream\n"
 			 "                         include required WAL files with specified method\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -y, --decrypt          receive the data decrypted\n"));
+#endif	/* USE_ENCRYPTION */
 	printf(_("  -z, --gzip             compress tar output\n"));
 	printf(_("  -Z, --compress=0-9     compress tar output with given compression level\n"));
 	printf(_("\nGeneral options:\n"));
@@ -558,6 +564,7 @@ LogStreamerMain(logstreamer_param *param)
 	stream.synchronous = false;
 	/* fsync happens at the end of pg_basebackup for all data */
 	stream.do_sync = false;
+	stream.decrypt = decrypt;
 	stream.mark_done = true;
 	stream.partial_suffix = NULL;
 	stream.replication_slot = replication_slot;
@@ -1901,8 +1908,12 @@ BaseBackup(void)
 			fprintf(stderr, "\n");
 	}
 
+	/*
+	 * If user requested decryption, we blindly pass the DECRYPT option and
+	 * let server ignore it if the cluster is not encrypted.
+	 */
 	basebkp =
-		psprintf("BASE_BACKUP LABEL '%s' %s %s %s %s %s %s %s %s %s",
+		psprintf("BASE_BACKUP LABEL '%s' %s %s %s %s %s %s %s %s %s %s",
 				 escaped_label,
 				 estimatesize ? "PROGRESS" : "",
 				 includewal == FETCH_WAL ? "WAL" : "",
@@ -1912,7 +1923,8 @@ BaseBackup(void)
 				 format == 't' ? "TABLESPACE_MAP" : "",
 				 verify_checksums ? "" : "NOVERIFY_CHECKSUMS",
 				 manifest_clause ? manifest_clause : "",
-				 manifest_checksums_clause);
+				 manifest_checksums_clause,
+				 decrypt ? "DECRYPT" : "");
 
 	if (PQsendQuery(conn, basebkp) == 0)
 	{
@@ -2247,6 +2259,9 @@ main(int argc, char **argv)
 		{"slot", required_argument, NULL, 'S'},
 		{"tablespace-mapping", required_argument, NULL, 'T'},
 		{"wal-method", required_argument, NULL, 'X'},
+#ifdef	USE_ENCRYPTION
+		{"decrypt", no_argument, NULL, 'y'},
+#endif							/* USE_ENCRYPTION */
 		{"gzip", no_argument, NULL, 'z'},
 		{"compress", required_argument, NULL, 'Z'},
 		{"label", required_argument, NULL, 'l'},
@@ -2295,7 +2310,7 @@ main(int argc, char **argv)
 
 	atexit(cleanup_directories_atexit);
 
-	while ((c = getopt_long(argc, argv, "CD:F:r:RS:T:X:l:nNzZ:d:c:h:p:U:s:wWkvP",
+	while ((c = getopt_long(argc, argv, "CD:F:r:RS:T:X:l:nNyzZ:d:c:h:p:U:s:wWkvP",
 							long_options, &option_index)) != -1)
 	{
 		switch (c)
@@ -2362,6 +2377,11 @@ main(int argc, char **argv)
 					exit(1);
 				}
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'y':
+				decrypt = true;
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 1:
 				xlog_dir = pg_strdup(optarg);
 				break;
diff --git a/src/bin/pg_basebackup/pg_receivewal.c b/src/bin/pg_basebackup/pg_receivewal.c
index c135943545..78bddb7d22 100644
--- a/src/bin/pg_basebackup/pg_receivewal.c
+++ b/src/bin/pg_basebackup/pg_receivewal.c
@@ -5,7 +5,8 @@
  *
  * Author: Magnus Hagander <magnus@hagander.net>
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *		  src/bin/pg_basebackup/pg_receivewal.c
@@ -41,6 +42,7 @@ static bool do_create_slot = false;
 static bool slot_exists_ok = false;
 static bool do_drop_slot = false;
 static bool do_sync = true;
+static bool decrypt = false;
 static bool synchronous = false;
 static char *replication_slot = NULL;
 static XLogRecPtr endpos = InvalidXLogRecPtr;
@@ -90,6 +92,9 @@ usage(void)
 	printf(_("      --synchronous      flush write-ahead log immediately after writing\n"));
 	printf(_("  -v, --verbose          output verbose messages\n"));
 	printf(_("  -V, --version          output version information, then exit\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -y, --decrypt          receive the data decrypted\n"));
+#endif	/* USE_ENCRYPTION */
 	printf(_("  -Z, --compress=0-9     compress logs with given compression level\n"));
 	printf(_("  -?, --help             show this help, then exit\n"));
 	printf(_("\nConnection options:\n"));
@@ -428,6 +433,7 @@ StreamLog(void)
 	stream.standby_message_timeout = standby_message_timeout;
 	stream.synchronous = synchronous;
 	stream.do_sync = do_sync;
+	stream.decrypt = decrypt;
 	stream.mark_done = false;
 	stream.walmethod = CreateWalDirectoryMethod(basedir, compresslevel,
 												stream.do_sync);
@@ -517,7 +523,7 @@ main(int argc, char **argv)
 		}
 	}
 
-	while ((c = getopt_long(argc, argv, "D:d:E:h:p:U:s:S:nwWvZ:",
+	while ((c = getopt_long(argc, argv, "D:d:E:h:p:U:s:S:nwWvyZ:",
 							long_options, &option_index)) != -1)
 	{
 		switch (c)
@@ -573,6 +579,11 @@ main(int argc, char **argv)
 			case 'v':
 				verbose++;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'y':
+				decrypt = true;
+				break;
+#endif	/* USE_ENCRYPTION */
 			case 'Z':
 				compresslevel = atoi(optarg);
 				if (compresslevel < 0 || compresslevel > 9)
diff --git a/src/bin/pg_basebackup/receivelog.c b/src/bin/pg_basebackup/receivelog.c
index 682081b431..41de4fd478 100644
--- a/src/bin/pg_basebackup/receivelog.c
+++ b/src/bin/pg_basebackup/receivelog.c
@@ -5,7 +5,8 @@
  *
  * Author: Magnus Hagander <magnus@hagander.net>
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *		  src/bin/pg_basebackup/receivelog.c
@@ -452,6 +453,7 @@ ReceiveXlogStream(PGconn *conn, StreamCtl *stream)
 	char		slotcmd[128];
 	PGresult   *res;
 	XLogRecPtr	stoppos;
+	char	*decrypt_cmd = "";
 
 	/*
 	 * The caller should've checked the server version already, but doesn't do
@@ -519,6 +521,13 @@ ReceiveXlogStream(PGconn *conn, StreamCtl *stream)
 		PQclear(res);
 	}
 
+	/*
+	 * If user requested decryption, we blindly pass the DECRYPT option and
+	 * let server ignore it if the cluster is not encrypted.
+	 */
+	if (stream->decrypt)
+		decrypt_cmd = "DECRYPT";
+
 	/*
 	 * initialize flush position to starting point, it's the caller's
 	 * responsibility that that's sane.
@@ -572,10 +581,11 @@ ReceiveXlogStream(PGconn *conn, StreamCtl *stream)
 			return true;
 
 		/* Initiate the replication stream at specified location */
-		snprintf(query, sizeof(query), "START_REPLICATION %s%X/%X TIMELINE %u",
+		snprintf(query, sizeof(query), "START_REPLICATION %s%X/%X TIMELINE %u %s",
 				 slotcmd,
 				 LSN_FORMAT_ARGS(stream->startpos),
-				 stream->timeline);
+				 stream->timeline,
+				 decrypt_cmd);
 		res = PQexec(conn, query);
 		if (PQresultStatus(res) != PGRES_COPY_BOTH)
 		{
diff --git a/src/bin/pg_basebackup/receivelog.h b/src/bin/pg_basebackup/receivelog.h
index e04333bf81..a21423b6a0 100644
--- a/src/bin/pg_basebackup/receivelog.h
+++ b/src/bin/pg_basebackup/receivelog.h
@@ -2,7 +2,8 @@
  *
  * receivelog.h
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *		  src/bin/pg_basebackup/receivelog.h
@@ -37,6 +38,7 @@ typedef struct StreamCtl
 	bool		mark_done;		/* Mark segment as done in generated archive */
 	bool		do_sync;		/* Flush to disk to ensure consistent state of
 								 * data */
+	bool		decrypt;		/* Decrypt the stream if it's encrypted. */
 
 	stream_stop_callback stream_stop;	/* Stop streaming when returns true */
 
diff --git a/src/bin/pg_checksums/pg_checksums.c b/src/bin/pg_checksums/pg_checksums.c
index 831cf42d3a..90d1b64a92 100644
--- a/src/bin/pg_checksums/pg_checksums.c
+++ b/src/bin/pg_checksums/pg_checksums.c
@@ -4,7 +4,8 @@
  *	  Checks, enables or disables page level checksums for an offline
  *	  cluster
  *
- * Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *	  src/bin/pg_checksums/pg_checksums.c
@@ -116,6 +117,9 @@ static const struct exclude_list_item skip[] = {
 	{"PG_VERSION", false},
 #ifdef EXEC_BACKEND
 	{"config_exec_params", true},
+#endif
+#ifdef USE_ENCRYPTION
+	{"kdf_params", false},
 #endif
 	{NULL, false}
 };
@@ -237,8 +241,12 @@ scan_file(const char *fn, BlockNumber segmentno)
 		 */
 		current_size += r;
 
-		/* New pages have no checksum yet */
-		if (PageIsNew(header))
+		/*
+		 * New pages have no checksum yet, unless it's encrypted - see
+		 * PageSetChecksumCopy() for explanation.
+		 */
+		if (DATA_CIPHER_GET_KIND(ControlFile->data_cipher) == PG_CIPHER_NONE &&
+			PageIsNew(header))
 			continue;
 
 		csum = pg_checksum_page(buf.data, blockno + segmentno * RELSEG_SIZE);
diff --git a/src/bin/pg_controldata/pg_controldata.c b/src/bin/pg_controldata/pg_controldata.c
index f911f98d94..5f4799345a 100644
--- a/src/bin/pg_controldata/pg_controldata.c
+++ b/src/bin/pg_controldata/pg_controldata.c
@@ -3,6 +3,7 @@
  *
  * reads the data from $PGDATA/global/pg_control
  *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
  * copyright (c) Oliver Elphick <olly@lfix.co.uk>, 2001;
  * license: BSD
  *
@@ -18,6 +19,7 @@
 
 #include "postgres.h"
 
+#include <arpa/inet.h>
 #include <time.h>
 
 #include "access/transam.h"
@@ -328,5 +330,18 @@ main(int argc, char *argv[])
 		   ControlFile->data_checksum_version);
 	printf(_("Mock authentication nonce:            %s\n"),
 		   mock_auth_nonce_str);
+	printf(_("Data encryption:                      %s\n"),
+		   ControlFile->data_cipher > PG_CIPHER_NONE ? _("on") : _("off"));
+	if (DATA_CIPHER_GET_KIND(ControlFile->data_cipher) != PG_CIPHER_NONE)
+	{
+		printf(_("Encryption key length:                %d\n"),
+			   DATA_CIPHER_GET_KEY_LENGTH(ControlFile->data_cipher) * 8);
+		printf(_("Data encryption fingerprint:          %08X%08X%08X%08X\n"),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[0]),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[1]),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[2]),
+			   htonl(((uint32 *) ControlFile->encryption_verification)[3])
+			);
+	}
 	return 0;
 }
diff --git a/src/bin/pg_ctl/Makefile b/src/bin/pg_ctl/Makefile
index 5d5f5372a3..8fd2becada 100644
--- a/src/bin/pg_ctl/Makefile
+++ b/src/bin/pg_ctl/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/pg_ctl
 #
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
 # Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -20,9 +21,9 @@ include $(top_builddir)/src/Makefile.global
 # but let's not pull that in on platforms where we don't need it.
 ifeq ($(PORTNAME), win32)
 override CPPFLAGS := -I$(libpq_srcdir) $(CPPFLAGS)
-LDFLAGS_INTERNAL += $(libpq_pgport)
 SUBMAKE_LIBPQ := submake-libpq
 endif
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 
 OBJS = \
 	$(WIN32RES) \
diff --git a/src/bin/pg_ctl/pg_ctl.c b/src/bin/pg_ctl/pg_ctl.c
index f21849a257..9f58e228df 100644
--- a/src/bin/pg_ctl/pg_ctl.c
+++ b/src/bin/pg_ctl/pg_ctl.c
@@ -2,7 +2,8 @@
  *
  * pg_ctl --- start/stops/restarts the PostgreSQL server
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *
  * src/bin/pg_ctl/pg_ctl.c
  *
@@ -25,9 +26,11 @@
 
 #include "catalog/pg_control.h"
 #include "common/controldata_utils.h"
+#include "common/encryption.h"
 #include "common/file_perm.h"
 #include "common/logging.h"
 #include "common/string.h"
+#include "fe_utils/encryption.h"
 #include "getopt_long.h"
 #include "utils/pidfile.h"
 
@@ -107,6 +110,21 @@ static char logrotate_file[MAXPGPATH];
 
 static volatile pgpid_t postmasterPID = -1;
 
+/*
+ * Define encryption_key locally rather that linking to storage/encryption.c
+ * only because of this one variable.
+ */
+extern unsigned char encryption_key[ENCRYPTION_KEY_MAX_LENGTH];
+#ifndef HAVE_UNIX_SOCKETS
+/*
+ * Port at which postmaster listens for encryption key message.
+ *
+ * This is only useful for pg_upgrade which starts the cluster on a port
+ * different from that in configuration file.
+ */
+static char *encr_key_port = NULL;
+#endif
+
 #ifdef WIN32
 static DWORD pgctl_start_type = SERVICE_AUTO_START;
 static SERVICE_STATUS status;
@@ -134,6 +152,11 @@ static void do_logrotate(void);
 static void do_kill(pgpid_t pid);
 static void print_msg(const char *msg);
 static void adjust_data_dir(void);
+static char *get_config_variable(const char *var_name, size_t res_size);
+#ifdef USE_ENCRYPTION
+static char *get_first_csv_item(char *csv_list);
+static void get_postmaster_address(char **host_p, char **port_str_p);
+#endif	/* USE_ENCRYPTION */
 
 #ifdef WIN32
 #include <versionhelpers.h>
@@ -165,7 +188,9 @@ static void unlimit_core_size(void);
 #endif
 
 static DBState get_control_dbstate(void);
-
+#ifdef USE_ENCRYPTION
+static int get_control_key_length(void);
+#endif	/* USE_ENCRYPTION */
 
 #ifdef WIN32
 static void
@@ -901,6 +926,23 @@ static void
 do_init(void)
 {
 	char	   *cmd;
+	char *encr_opt_str;
+
+	/* Prepare the -K option for initdb. */
+	if (encryption_key_command)
+	{
+		size_t		len;
+
+		len = strlen(encryption_key_command) + 7;
+		encr_opt_str = (char *) pg_malloc(len);
+		snprintf(encr_opt_str, len, " -K \"%s\"",
+				 encryption_key_command);
+	}
+	else
+	{
+		encr_opt_str = (char *) pg_malloc(1);
+		encr_opt_str[0] = '\0';
+	}
 
 	if (exec_path == NULL)
 		exec_path = find_other_exec_or_die(argv0, "initdb", "initdb (PostgreSQL) " PG_VERSION "\n");
@@ -912,11 +954,11 @@ do_init(void)
 		post_opts = "";
 
 	if (!silent_mode)
-		cmd = psprintf("\"%s\" %s%s",
-					   exec_path, pgdata_opt, post_opts);
+		cmd = psprintf("\"%s\" %s%s%s",
+					   exec_path, pgdata_opt, post_opts, encr_opt_str);
 	else
-		cmd = psprintf("\"%s\" %s%s > \"%s\"",
-					   exec_path, pgdata_opt, post_opts, DEVNULL);
+		cmd = psprintf("\"%s\" %s%s%s > \"%s\"",
+					   exec_path, pgdata_opt, post_opts, encr_opt_str, DEVNULL);
 
 	if (system(cmd) != 0)
 	{
@@ -930,6 +972,9 @@ do_start(void)
 {
 	pgpid_t		old_pid = 0;
 	pgpid_t		pm_pid;
+#ifdef USE_ENCRYPTION
+	SendKeyArgs	sk_args;
+#endif	/* USE_ENCRYPTION */
 
 	if (ctl_command != RESTART_COMMAND)
 	{
@@ -968,7 +1013,97 @@ do_start(void)
 	}
 #endif
 
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		int		key_len = get_control_key_length();
+
+		/*
+		 * If encryption key is needed, retrieve it before trying to start
+		 * postmaster.
+		 */
+		run_encryption_key_command(pg_data, &key_len);
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	pm_pid = start_postmaster();
+#ifdef WIN32
+	sk_args.pmProcess = postmasterProcess;
+#endif
+
+#ifdef USE_ENCRYPTION
+	sk_args.pm_pid = pm_pid;
+	sk_args.pm_exited = false;
+	if (encryption_key_command)
+	{
+		char	*keycmd_conf_file;
+
+		sk_args.encryption_key = encryption_key;
+
+		/* Is the key command also configured in postgresql.conf ? */
+		keycmd_conf_file = get_config_variable("encryption_key_command",
+											   MAXPGPATH);
+
+		if (keycmd_conf_file)
+			print_msg(_("ignoring the -K option due to presence of encryption_key_command in configuration file\n"));
+	}
+	else
+	{
+		/*
+		 * An empty key message should be sent if no key command was
+		 * passed. It's more user friendly to let startup fail immediately
+		 * than to let postmaster wait until MAX_WAIT_FOR_KEY_SECS has elapsed
+		 * and then fail.
+		 */
+		sk_args.encryption_key = NULL;
+	}
+
+	get_postmaster_address(&sk_args.host, &sk_args.port);
+#ifndef HAVE_UNIX_SOCKETS
+	if (encr_key_port)
+		sk_args.port = encr_key_port;
+#endif
+	sk_args.error_msg = NULL;
+
+	/*
+	 * Send the key to the postmaster, or an empty message if we have no
+	 * key. The latter means that postmaster should have tried to get the key
+	 * using a command that it might find in postgresql.conf, so we shouldn't
+	 * send it again.
+	 */
+	if (!send_key_to_postmaster(&sk_args))
+	{
+		/*
+		 * Skip the waiting below if we are sure that postmaster is no longer
+		 * alive. (It wouldn't work anyway if we called waitpid() for an
+		 * already exited process again.)
+		 */
+		if (sk_args.pm_exited)
+		{
+			if (do_wait)
+				print_msg(_(" stopped waiting\n"));
+			write_stderr(_("%s: could not start server\n"
+						   "Examine the log output.\n"),
+						 progname);
+			exit(1);
+		}
+
+		/*
+		 * Some other problem in the communication between pg_ctl and the
+		 * postmaster. If postmaster does not receive the key, it will fail to
+		 * start and report the missing encryption key in the server log.
+		 *
+		 * Formerly we used to report an error here, but the error message was
+		 * rather confusing. We could emit a debug message, but there's
+		 * nothing like a debug logging in pg_ctl.
+		 */
+	}
+#endif	/* USE_ENCRYPTION */
 
 	if (do_wait)
 	{
@@ -2058,10 +2193,10 @@ do_help(void)
 	printf(_("%s is a utility to initialize, start, stop, or control a PostgreSQL server.\n\n"), progname);
 	printf(_("Usage:\n"));
 	printf(_("  %s init[db]   [-D DATADIR] [-s] [-o OPTIONS]\n"), progname);
-	printf(_("  %s start      [-D DATADIR] [-l FILENAME] [-W] [-t SECS] [-s]\n"
+	printf(_("  %s start      [-D DATADIR] [-l FILENAME] [-W] [-t SECS] [-K KEY-CMD] [-s]\n"
 			 "                    [-o OPTIONS] [-p PATH] [-c]\n"), progname);
 	printf(_("  %s stop       [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]\n"), progname);
-	printf(_("  %s restart    [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]\n"
+	printf(_("  %s restart    [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-K KEY-CMD] [-s]\n"
 			 "                    [-o OPTIONS] [-c]\n"), progname);
 	printf(_("  %s reload     [-D DATADIR] [-s]\n"), progname);
 	printf(_("  %s status     [-D DATADIR]\n"), progname);
@@ -2079,6 +2214,10 @@ do_help(void)
 #ifdef WIN32
 	printf(_("  -e SOURCE              event source for logging when running as a service\n"));
 #endif
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command\n"
+			 "                         command that returns encryption key\n\n"));
+#endif	/* USE_ENCRYPTION */
 	printf(_("  -s, --silent           only print errors, no informational messages\n"));
 	printf(_("  -t, --timeout=SECS     seconds to wait when using -w option\n"));
 	printf(_("  -V, --version          output version information, then exit\n"));
@@ -2207,28 +2346,45 @@ set_starttype(char *starttypeopt)
 static void
 adjust_data_dir(void)
 {
-	char		filename[MAXPGPATH];
-	char	   *my_exec_path,
-			   *cmd;
-	FILE	   *fd;
+	char conf_path[MAXPGPATH];
+	char	*filename;
+	FILE	*fd;
 
 	/* do nothing if we're working without knowledge of data dir */
 	if (pg_config == NULL)
 		return;
 
-	/* If there is no postgresql.conf, it can't be a config-only dir */
-	snprintf(filename, sizeof(filename), "%s/postgresql.conf", pg_config);
-	if ((fd = fopen(filename, "r")) == NULL)
+	/* If PG_VERSION exists, it can't be a config-only dir */
+	snprintf(conf_path, sizeof(conf_path), "%s/PG_VERSION", pg_config);
+	if ((fd = fopen(conf_path, "r")) != NULL)
 		return;
-	fclose(fd);
 
-	/* If PG_VERSION exists, it can't be a config-only dir */
-	snprintf(filename, sizeof(filename), "%s/PG_VERSION", pg_config);
-	if ((fd = fopen(filename, "r")) != NULL)
+	filename = get_config_variable("data_directory", MAXPGPATH);
+
+	if (filename)
 	{
-		fclose(fd);
-		return;
+		free(pg_data);
+		pg_data = filename;
+		canonicalize_path(pg_data);
 	}
+}
+
+/*
+ * Retrieve value of configuration variable from configuration file.
+ */
+static char *
+get_config_variable(const char *var_name, size_t res_size)
+{
+	char	filename[MAXPGPATH],
+			   *my_exec_path;
+	char	*result, *cmd;
+	FILE	   *fd;
+
+	/* If there is no postgresql.conf, the data dir is not useful. */
+	snprintf(filename, sizeof(filename), "%s/postgresql.conf", pg_config);
+	if ((fd = fopen(filename, "r")) == NULL)
+		return NULL;
+	fclose(fd);
 
 	/* Must be a configuration directory, so find the data directory */
 
@@ -2239,28 +2395,101 @@ adjust_data_dir(void)
 		my_exec_path = pg_strdup(exec_path);
 
 	/* it's important for -C to be the first option, see main.c */
-	cmd = psprintf("\"%s\" -C data_directory %s%s",
+	cmd = psprintf("\"%s\" -C %s %s%s",
 				   my_exec_path,
+				   var_name,
 				   pgdata_opt ? pgdata_opt : "",
 				   post_opts ? post_opts : "");
 
+	result = pg_malloc(res_size);
 	fd = popen(cmd, "r");
-	if (fd == NULL || fgets(filename, sizeof(filename), fd) == NULL)
+	if (fd == NULL || fgets(result, res_size, fd) == NULL)
 	{
-		write_stderr(_("%s: could not determine the data directory using command \"%s\"\n"), progname, cmd);
+		write_stderr(_("%s: could not determine the value of \"%s\" \"%s\"\n"),
+					 progname, var_name, cmd);
+		free(result);
 		exit(1);
 	}
 	pclose(fd);
 	free(my_exec_path);
 
 	/* strip trailing newline and carriage return */
-	(void) pg_strip_crlf(filename);
+	(void) pg_strip_crlf(result);
 
 	free(pg_data);
 	pg_data = pg_strdup(filename);
 	canonicalize_path(pg_data);
+
+	if (strlen(result) == 0)
+	{
+		pg_free(result);
+		result = NULL;
+	}
+
+	return result;
+}
+
+#ifdef USE_ENCRYPTION
+/*
+ * Get the first item of comma-separated list or NULL if there's no valid
+ * item.
+ */
+static char *
+get_first_csv_item(char *csv_list)
+{
+	char	*start, *end, *result;
+
+	start = csv_list;
+	/* First, skip the leading space. */
+	while (isspace(*start))
+		start++;
+	if (*start == '\0')
+		return NULL;
+
+	end = start;
+	while (*end != '\0' && *end != ',' && !isspace(*end))
+		end++;
+	if (end == start)
+		return NULL;
+
+	result = pg_strdup(start);
+
+	/* Trim the string if needed. */
+	if (*end != '\0')
+		result[end - start] = '\0';
+
+	return result;
 }
 
+/*
+ * Retrieve host name and port to which the encryption key should be sent.
+ */
+static void
+get_postmaster_address(char **host_p, char **port_str_p)
+{
+	char	*socket_dirs;
+
+	/* First, try to connect via the unix socket. */
+	socket_dirs = get_config_variable("unix_socket_directories",
+									  MAXPGPATH);
+	if (socket_dirs)
+	{
+		/* If there are multiple sockets, use the first one. */
+		*host_p = get_first_csv_item(socket_dirs);
+	}
+	else
+	{
+		/* Let libpq use the default value.*/
+		*host_p = NULL;
+	}
+
+	/*
+	 * The maximum length of the port number is 5 characters for the port
+	 * number (65535 at maximum) + '\n' + terminating '\0'.
+	 */
+	*port_str_p = get_config_variable("port", 7);
+}
+#endif	/* USE_ENCRYPTION */
 
 static DBState
 get_control_dbstate(void)
@@ -2280,6 +2509,25 @@ get_control_dbstate(void)
 	return ret;
 }
 
+#ifdef USE_ENCRYPTION
+static int
+get_control_key_length(void)
+{
+	int			ret;
+	bool		crc_ok;
+	ControlFileData *control_file_data = get_controlfile(pg_data, &crc_ok);
+
+	if (!crc_ok)
+	{
+		write_stderr(_("%s: control file appears to be corrupt\n"), progname);
+		exit(1);
+	}
+
+	ret = DATA_CIPHER_GET_KEY_LENGTH(control_file_data->data_cipher);
+	pfree(control_file_data);
+	return ret;
+}
+#endif	/* USE_ENCRYPTION */
 
 int
 main(int argc, char **argv)
@@ -2293,6 +2541,12 @@ main(int argc, char **argv)
 		{"options", required_argument, NULL, 'o'},
 		{"silent", no_argument, NULL, 's'},
 		{"timeout", required_argument, NULL, 't'},
+#ifdef USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#ifndef HAVE_UNIX_SOCKETS
+		{"encryption-key-port", required_argument, NULL, 1},
+#endif	/* HAVE_UNIX_SOCKETS */
+#endif	/* USE_ENCRYPTION */
 		{"core-files", no_argument, NULL, 'c'},
 		{"wait", no_argument, NULL, 'w'},
 		{"no-wait", no_argument, NULL, 'W'},
@@ -2363,7 +2617,7 @@ main(int argc, char **argv)
 	/* process command-line options */
 	while (optind < argc)
 	{
-		while ((c = getopt_long(argc, argv, "cD:e:l:m:N:o:p:P:sS:t:U:wW",
+		while ((c = getopt_long(argc, argv, "cD:e:K:l:m:N:o:p:P:sS:t:U:wW",
 								long_options, &option_index)) != -1)
 		{
 			switch (c)
@@ -2388,6 +2642,11 @@ main(int argc, char **argv)
 				case 'e':
 					event_source = pg_strdup(optarg);
 					break;
+#ifdef USE_ENCRYPTION
+				case 'K':
+					encryption_key_command = pg_strdup(optarg);
+					break;
+#endif	/* USE_ENCRYPTION */
 				case 'l':
 					log_file = pg_strdup(optarg);
 					break;
@@ -2447,6 +2706,11 @@ main(int argc, char **argv)
 				case 'c':
 					allow_core_files = true;
 					break;
+#ifndef HAVE_UNIX_SOCKETS
+				case 1:
+					encr_key_port = pg_strdup(optarg);
+					break;
+#endif
 				default:
 					/* getopt_long already issued a suitable error message */
 					do_advice();
@@ -2564,6 +2828,11 @@ main(int argc, char **argv)
 			umask(pg_mode_mask);
 	}
 
+	if (encryption_key_command && ctl_command !=
+		START_COMMAND && ctl_command != RESTART_COMMAND &&
+		ctl_command != INIT_COMMAND)
+		write_stderr(_("%s: ignoring the -K option, it's only useful for start or restart commands\n"), progname);
+
 	switch (ctl_command)
 	{
 		case INIT_COMMAND:
diff --git a/src/bin/pg_keytool/.gitignore b/src/bin/pg_keytool/.gitignore
new file mode 100644
index 0000000000..249876a6ed
--- /dev/null
+++ b/src/bin/pg_keytool/.gitignore
@@ -0,0 +1 @@
+/pg_keytool
diff --git a/src/bin/pg_keytool/Makefile b/src/bin/pg_keytool/Makefile
new file mode 100644
index 0000000000..d378c6204e
--- /dev/null
+++ b/src/bin/pg_keytool/Makefile
@@ -0,0 +1,39 @@
+#-------------------------------------------------------------------------
+#
+# Makefile for src/bin/pg_keytool
+#
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
+#
+# src/bin/pg_keytool/Makefile
+#
+#-------------------------------------------------------------------------
+
+PGFILEDESC = "pg_keytool - handle cluster encryption key"
+PGAPPICON=win32
+
+subdir = src/bin/pg_keytool
+top_builddir = ../../..
+include $(top_builddir)/src/Makefile.global
+
+OBJS = pg_keytool.o $(RMGRDESCOBJS) $(WIN32RES)
+
+override CPPFLAGS := -I$(libpq_srcdir) $(CPPFLAGS)
+override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
+
+all: pg_keytool
+
+pg_keytool: $(OBJS) | submake-libpgport
+	$(CC) $(CFLAGS) $^ $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@$(X)
+
+install: all installdirs
+	$(INSTALL_PROGRAM) pg_keytool$(X) '$(DESTDIR)$(bindir)/pg_keytool$(X)'
+
+installdirs:
+	$(MKDIR_P) '$(DESTDIR)$(bindir)'
+
+uninstall:
+	rm -f '$(DESTDIR)$(bindir)/pg_keytool$(X)'
+
+clean distclean maintainer-clean:
+	rm -f pg_keytool$(X) $(OBJS) encryption.c
diff --git a/src/bin/pg_keytool/pg_keytool.c b/src/bin/pg_keytool/pg_keytool.c
new file mode 100644
index 0000000000..d9b42f3d2b
--- /dev/null
+++ b/src/bin/pg_keytool/pg_keytool.c
@@ -0,0 +1,274 @@
+/*-------------------------------------------------------------------------
+ *
+ * pg_keytool.c - Handle cluster encryption key.
+ *
+ * Copyright (c) 2013-2019, PostgreSQL Global Development Group
+ *
+ * IDENTIFICATION
+ *		  src/bin/pg_keytool/pg_keytool.c
+ *-------------------------------------------------------------------------
+ */
+/*
+ * TODO Adopt the new frontend logging API, after some things are clarified:
+ * https://www.postgresql.org/message-id/1939.1560773970%40localhost
+ */
+#define FRONTEND 1
+#include "postgres.h"
+
+#include <dirent.h>
+#include <unistd.h>
+
+#include "common/controldata_utils.h"
+#include "common/fe_memutils.h"
+#include "common/logging.h"
+#include "fe_utils/encryption.h"
+#include "libpq-fe.h"
+#include "libpq/pqcomm.h"
+#include "port/pg_crc32c.h"
+#include "getopt_long.h"
+
+#ifdef USE_ENCRYPTION
+/*
+ * TODO Tune these values.
+ */
+#define ENCRYPTION_PWD_MIN_LENGTH	8
+#define ENCRYPTION_PWD_MAX_LENGTH	16
+
+static const char *progname;
+
+extern unsigned char encryption_key[ENCRYPTION_KEY_MAX_LENGTH];
+
+static void
+usage(const char *progname)
+{
+	const char *env;
+
+	printf(_("%s is a tool to handle cluster encryption key.\n\n"),
+		   progname);
+	printf(_("Usage:\n"));
+	printf(_("  %s [OPTION]...\n"), progname);
+	printf(_("\nOptions:\n"));
+	printf(_("  -D, --pgdata=DATADIR   data directory\n"));
+	/* Display default host */
+	env = getenv("PGHOST");
+	printf(_("  -h, --host=HOSTNAME    database server host or socket directory (default: \"%s\")\n"),
+			env ? env : _("local socket"));
+	/* Display default port */
+	env = getenv("PGPORT");
+	printf(_("  -p, --port=PORT        database server port (default: \"%s\")\n"),
+			env ? env : DEF_PGPORT_STR);
+#ifdef HAVE_UNIX_SOCKETS
+	printf(_("  -s,                    send output to database server\n"));
+#endif	/* HAVE_UNIX_SOCKETS */
+	printf(_("  -w                     expect password on input, not a key\n"));
+	printf(_("  -?, --help             show this help, then exit\n\n"));
+	printf(_("Password or key is read from stdin. Key is sent to PostgreSQL server being started\n"));
+}
+#endif							/* USE_ENCRYPTION */
+
+int
+main(int argc, char **argv)
+{
+/*
+ * If no encryption library is linked, let the utility fail immediately. It'd
+ * be weird if we reported incorrect usage just to say later that no useful
+ * work can be done anyway.
+ */
+#ifdef USE_ENCRYPTION
+	int			c;
+	char		*host = NULL;
+	char		*port_str = NULL;
+	char	   *DataDir = NULL;
+	bool		to_server = false;
+	bool		expect_password = false;
+	int			i, n;
+	int			optindex;
+	char		password[ENCRYPTION_PWD_MAX_LENGTH];
+	char		key_chars[ENCRYPTION_KEY_MAX_CHARS];
+	int		key_len, key_nchars;
+
+	static struct option long_options[] =
+	{
+		{"pgdata", required_argument, NULL, 'D'},
+		{"host", required_argument, NULL, 'h'},
+		{"port", required_argument, NULL, 'p'},
+		{NULL, 0, NULL, 0}
+	};
+
+	pg_logging_init(argv[0]);
+	progname = get_progname(argv[0]);
+
+	if (argc > 1)
+	{
+		if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-?") == 0)
+		{
+			usage(progname);
+			exit(0);
+		}
+		if (strcmp(argv[1], "--version") == 0 || strcmp(argv[1], "-V") == 0)
+		{
+			puts("pg_keytool (PostgreSQL) " PG_VERSION);
+			exit(0);
+		}
+	}
+
+	while ((c = getopt_long(argc, argv, "h:D:p:sw",
+							long_options, &optindex)) != -1)
+	{
+		switch (c)
+		{
+			case 'D':
+				DataDir = optarg;
+				break;
+
+			case 'h':
+				host = pg_strdup(optarg);
+				break;
+
+			case 'p':
+				port_str = pg_strdup(optarg);
+				break;
+
+			case 's':
+				to_server = true;
+				break;
+
+			case 'w':
+				expect_password = true;
+				break;
+
+			default:
+				pg_log_error("Try \"%s --help\" for more information.", progname);
+				exit(1);
+		}
+	}
+
+	/* Complain if any arguments remain */
+	if (optind < argc)
+	{
+		fprintf(stderr, _("%s: too many command-line arguments (first is \"%s\")\n"),
+				progname, argv[optind]);
+		fprintf(stderr, _("Try \"%s --help\" for more information.\n"),
+				progname);
+		exit(1);
+	}
+
+	/* Try to initialize DataDir using environment variable. */
+	if (DataDir == NULL)
+	{
+		DataDir = getenv("PGDATA");
+		if (DataDir)
+			DataDir = pg_strdup(DataDir);
+	}
+
+	/*
+	 * The key length is stored in the KDF file. Furthermore, the KDF file is
+	 * needed if we're going to derive the key from the password.
+	 */
+	if (DataDir == NULL)
+	{
+		pg_log_error("%s: no data directory specified", progname);
+		pg_log_error("Try \"%s --help\" for more information.", progname);
+		exit(EXIT_FAILURE);
+	}
+
+	canonicalize_path(DataDir);
+
+	if ((host || port_str))
+		to_server = true;
+
+	/* Read the KDF parameters. */
+	key_len = read_kdf_file(DataDir);
+
+	/* Two (hexadecimal) chars per byte. */
+	key_nchars = key_len * 2;
+
+	/*
+	 * Read the credentials (key or password).
+	 */
+	n = 0;
+	/* Key length in characters (two characters per hexadecimal digit) */
+	while ((c = getchar()) != EOF && c != '\n')
+	{
+		if (!expect_password)
+		{
+			if (n >= key_nchars)
+			{
+				pg_log_error("The key is too long, should be a %d character hex string",
+							 key_nchars);
+				exit(EXIT_FAILURE);
+			}
+
+			key_chars[n++] = c;
+		}
+		else
+		{
+			if (n >= ENCRYPTION_PWD_MAX_LENGTH)
+			{
+				pg_log_error("The password is too long, the maximum length is %d characters",
+							 ENCRYPTION_PWD_MAX_LENGTH);
+				exit(EXIT_FAILURE);
+			}
+
+			password[n++] = c;
+		}
+	}
+
+	/* If password was received, turn it into encryption key. */
+	if (!expect_password)
+	{
+		if (n < key_nchars)
+		{
+			pg_log_error("The key is too short, should be a %d character hex string",
+						 key_nchars);
+			exit(EXIT_FAILURE);
+		}
+
+		encryption_key_from_string(key_chars, key_len);
+	}
+	else
+	{
+		if (n < ENCRYPTION_PWD_MIN_LENGTH)
+		{
+			pg_log_error("The password is too short, the minimum length is %d characters",
+						 ENCRYPTION_PWD_MIN_LENGTH);
+			exit(EXIT_FAILURE);
+		}
+
+		/* Run the KDF. */
+		derive_key_from_password(encryption_key, password, n);
+	}
+
+	/*
+	 * Send the encryption key either to stdout or to server.
+	 */
+	if (!to_server)
+	{
+		for (i = 0; i < key_len; i++)
+			printf("%.2x", encryption_key[i]);
+		printf("\n");
+	}
+	else
+	{
+		SendKeyArgs	sk_args;
+
+		sk_args.host = host;
+		sk_args.port = port_str;
+		sk_args.encryption_key = encryption_key;
+		sk_args.pm_pid = 0;
+		sk_args.error_msg = NULL;
+
+		/* XXX Try to find the postmaster PID? */
+		if (!send_key_to_postmaster(&sk_args))
+		{
+			pg_log_error("could not send encryption key to server");
+			if (sk_args.error_msg)
+				pg_log_error("%s", sk_args.error_msg);
+		}
+	}
+#else
+	pg_log_fatal(ENCRYPTION_NOT_SUPPORTED_MSG);
+	exit(EXIT_FAILURE);
+#endif							/* USE_ENCRYPTION */
+	return 0;
+}
diff --git a/src/bin/pg_resetwal/.gitignore b/src/bin/pg_resetwal/.gitignore
index 56bade5ea4..c46466c6dc 100644
--- a/src/bin/pg_resetwal/.gitignore
+++ b/src/bin/pg_resetwal/.gitignore
@@ -1,2 +1,3 @@
 /pg_resetwal
 /tmp_check/
+/encryption.c
diff --git a/src/bin/pg_resetwal/Makefile b/src/bin/pg_resetwal/Makefile
index 7dfa80c5e5..0f68d2f16e 100644
--- a/src/bin/pg_resetwal/Makefile
+++ b/src/bin/pg_resetwal/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/pg_resetwal
 #
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
 # Copyright (c) 1998-2021, PostgreSQL Global Development Group
 #
 # src/bin/pg_resetwal/Makefile
@@ -15,15 +16,22 @@ subdir = src/bin/pg_resetwal
 top_builddir = ../../..
 include $(top_builddir)/src/Makefile.global
 
+override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
+
 OBJS = \
 	$(WIN32RES) \
-	pg_resetwal.o
+	pg_resetwal.o \
+	encryption.o
 
 all: pg_resetwal
 
 pg_resetwal: $(OBJS) | submake-libpgport
 	$(CC) $(CFLAGS) $^ $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@$(X)
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) pg_resetwal$(X) '$(DESTDIR)$(bindir)/pg_resetwal$(X)'
 
@@ -34,7 +42,7 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/pg_resetwal$(X)'
 
 clean distclean maintainer-clean:
-	rm -f pg_resetwal$(X) $(OBJS)
+	rm -f pg_resetwal$(X) $(OBJS) encryption.c
 	rm -rf tmp_check
 
 check:
diff --git a/src/bin/pg_resetwal/pg_resetwal.c b/src/bin/pg_resetwal/pg_resetwal.c
index f8d5ecb6ad..b136f045f0 100644
--- a/src/bin/pg_resetwal/pg_resetwal.c
+++ b/src/bin/pg_resetwal/pg_resetwal.c
@@ -20,7 +20,8 @@
  * step 2 ...
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/bin/pg_resetwal/pg_resetwal.c
@@ -37,6 +38,7 @@
 
 #include "postgres.h"
 
+#include <arpa/inet.h>
 #include <dirent.h>
 #include <fcntl.h>
 #include <sys/stat.h>
@@ -55,6 +57,8 @@
 #include "common/logging.h"
 #include "common/restricted_token.h"
 #include "common/string.h"
+#include "fe_utils/encryption.h"
+#include "storage/encryption.h"
 #include "getopt_long.h"
 #include "pg_getopt.h"
 #include "storage/large_object.h"
@@ -137,7 +141,7 @@ main(int argc, char *argv[])
 	}
 
 
-	while ((c = getopt_long(argc, argv, "c:D:e:fl:m:no:O:u:x:", long_options, NULL)) != -1)
+	while ((c = getopt_long(argc, argv, "c:D:e:fK:l:m:no:O:u:x:", long_options, NULL)) != -1)
 	{
 		switch (c)
 		{
@@ -294,6 +298,12 @@ main(int argc, char *argv[])
 				}
 				break;
 
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = strdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
+
 			case 'l':
 				if (strspn(optarg, "01234567890ABCDEFabcdef") != XLOG_FNAME_LEN)
 				{
@@ -424,6 +434,52 @@ main(int argc, char *argv[])
 	if (log_fname != NULL)
 		XLogFromFileName(log_fname, &minXlogTli, &minXlogSegNo, WalSegSz);
 
+	/*
+	 * If the data is encrypted, we also might need to encrypt the XLOG record
+	 * below.
+	 */
+	data_cipher = ControlFile.data_cipher;
+	if (DATA_CIPHER_GET_KIND(data_cipher) != PG_CIPHER_NONE &&
+		!noupdate)
+#ifdef USE_ENCRYPTION
+	{
+		int	key_len = DATA_CIPHER_GET_KEY_LENGTH(data_cipher);
+
+		/*
+		 * Try to retrieve the command from environment variable. We do this
+		 * primarily to create encrypted clusters during automated tests. XXX
+		 * Not sure the variable should be documented. If we do, then pg_ctl
+		 * should probably accept it too.
+		 */
+		if (encryption_key_command == NULL)
+		{
+			encryption_key_command = getenv("PGENCRKEYCMD");
+			if (encryption_key_command && strlen(encryption_key_command) == 0)
+				encryption_key_command = NULL;
+		}
+
+		if (encryption_key_command)
+			run_encryption_key_command(DataDir, &key_len);
+		else
+		{
+			/*
+			 * If executed by pg_upgrade, we don't want pg_resetwal to run the
+			 * encryption key command (possibly interactive application)
+			 * because we have no access to terminal.
+			 */
+			read_encryption_key_f(stdin, NULL, &key_len);
+		}
+
+		setup_encryption();
+		data_encrypted = true;
+	}
+#else
+	{
+		pg_log_error(ENCRYPTION_NOT_SUPPORTED_MSG);
+		exit(EXIT_FAILURE);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/*
 	 * Also look at existing segment files to set up newXlogSegNo
 	 */
@@ -813,6 +869,16 @@ PrintControlValues(bool guessed)
 		   (ControlFile.float8ByVal ? _("by value") : _("by reference")));
 	printf(_("Data page checksum version:           %u\n"),
 		   ControlFile.data_checksum_version);
+	if (DATA_CIPHER_GET_KIND(ControlFile.data_cipher) != PG_CIPHER_NONE)
+	{
+		printf(_("Encryption key length:                %d\n"),
+			   DATA_CIPHER_GET_KEY_LENGTH(ControlFile.data_cipher) * 8);
+		printf(_("Data encryption fingerprint:          %08X%08X%08X%08X\n"),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[0]),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[1]),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[2]),
+			   htonl(((uint32 *) ControlFile.encryption_verification)[3]));
+	}
 }
 
 
@@ -1163,6 +1229,20 @@ WriteEmptyXLOG(void)
 	FIN_CRC32C(crc);
 	record->xl_crc = crc;
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, page->xlp_tli, newXlogSegNo, 0);
+		encrypt_block(buffer.data,
+					  buffer.data,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidXLogRecPtr,
+					  InvalidBlockNumber,
+					  EDK_REL_WAL);;
+	}
+
 	/* Write the first page */
 	XLogFilePath(path, ControlFile.checkPointCopy.ThisTimeLineID,
 				 newXlogSegNo, WalSegSz);
@@ -1223,6 +1303,9 @@ usage(void)
 	printf(_(" [-D, --pgdata=]DATADIR            data directory\n"));
 	printf(_("  -e, --epoch=XIDEPOCH             set next transaction ID epoch\n"));
 	printf(_("  -f, --force                      force update to be done\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command   command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -l, --next-wal-file=WALFILE      set minimum starting location for new WAL\n"));
 	printf(_("  -m, --multixact-ids=MXID,MXID    set next and oldest multitransaction ID\n"));
 	printf(_("  -n, --dry-run                    no update, just show what would be done\n"));
diff --git a/src/bin/pg_rewind/.gitignore b/src/bin/pg_rewind/.gitignore
index 79ddca3eec..fb6f5e2c43 100644
--- a/src/bin/pg_rewind/.gitignore
+++ b/src/bin/pg_rewind/.gitignore
@@ -1,4 +1,5 @@
 # Files generated during build
+/encryption.c
 /xlogreader.c
 /pg_rewind
 
diff --git a/src/bin/pg_rewind/Makefile b/src/bin/pg_rewind/Makefile
index 5514b95e6c..d01ecd23ad 100644
--- a/src/bin/pg_rewind/Makefile
+++ b/src/bin/pg_rewind/Makefile
@@ -2,6 +2,7 @@
 #
 # Makefile for src/bin/pg_rewind
 #
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
 # Portions Copyright (c) 2013-2021, PostgreSQL Global Development Group
 #
 # src/bin/pg_rewind/Makefile
@@ -21,6 +22,7 @@ LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 OBJS = \
 	$(WIN32RES) \
 	datapagemap.o \
+	encryption.o \
 	file_ops.o \
 	filemap.o \
 	libpq_source.o \
@@ -40,6 +42,9 @@ pg_rewind: $(OBJS) | submake-libpq submake-libpgport
 xlogreader.c: % : $(top_srcdir)/src/backend/access/transam/%
 	rm -f $@ && $(LN_S) $< .
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) pg_rewind$(X) '$(DESTDIR)$(bindir)/pg_rewind$(X)'
 
@@ -50,7 +55,7 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/pg_rewind$(X)'
 
 clean distclean maintainer-clean:
-	rm -f pg_rewind$(X) $(OBJS) xlogreader.c
+	rm -f pg_rewind$(X) $(OBJS) xlogreader.c encryption.c
 	rm -rf tmp_check
 
 check:
diff --git a/src/bin/pg_rewind/parsexlog.c b/src/bin/pg_rewind/parsexlog.c
index b9351291fe..7f8829458d 100644
--- a/src/bin/pg_rewind/parsexlog.c
+++ b/src/bin/pg_rewind/parsexlog.c
@@ -3,7 +3,8 @@
  * parsexlog.c
  *	  Functions for reading Write-Ahead-Log
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *-------------------------------------------------------------------------
@@ -353,6 +354,20 @@ SimpleXLogPageRead(XLogReaderState *xlogreader, XLogRecPtr targetPagePtr,
 		return -1;
 	}
 
+	if (data_encrypted)
+	{
+		char		tweak[TWEAK_SIZE];
+
+		XLogEncryptionTweak(tweak, targetHistory[private->tliIndex].tli,
+							xlogreadsegno, targetPageOff);
+		decrypt_block(readBuf,
+					  readBuf,
+					  XLOG_BLCKSZ,
+					  tweak,
+					  InvalidBlockNumber,
+					  EDK_REL_WAL);
+	}
+
 	Assert(targetSegNo == xlogreadsegno);
 
 	xlogreader->seg.ws_tli = targetHistory[private->tliIndex].tli;
diff --git a/src/bin/pg_rewind/pg_rewind.c b/src/bin/pg_rewind/pg_rewind.c
index 2ac4910778..a5235663c7 100644
--- a/src/bin/pg_rewind/pg_rewind.c
+++ b/src/bin/pg_rewind/pg_rewind.c
@@ -3,7 +3,8 @@
  * pg_rewind.c
  *	  Synchronizes a PostgreSQL data directory to a new timeline
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *
  *-------------------------------------------------------------------------
  */
@@ -22,6 +23,7 @@
 #include "common/file_perm.h"
 #include "common/restricted_token.h"
 #include "common/string.h"
+#include "fe_utils/encryption.h"
 #include "fe_utils/recovery_gen.h"
 #include "file_ops.h"
 #include "filemap.h"
@@ -29,6 +31,7 @@
 #include "pg_rewind.h"
 #include "rewind_source.h"
 #include "storage/bufpage.h"
+#include "storage/encryption.h"
 
 static void usage(const char *progname);
 
@@ -89,6 +92,10 @@ usage(const char *progname)
 	printf(_("  -D, --target-pgdata=DIRECTORY  existing data directory to modify\n"));
 	printf(_("      --source-pgdata=DIRECTORY  source data directory to synchronize with\n"));
 	printf(_("      --source-server=CONNSTR    source server to synchronize with\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command=COMMAND\n"
+			 "                                 command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -n, --dry-run                  stop before modifying anything\n"));
 	printf(_("  -N, --no-sync                  do not wait for changes to be written\n"
 			 "                                 safely to disk\n"));
@@ -120,6 +127,9 @@ main(int argc, char **argv)
 		{"no-sync", no_argument, NULL, 'N'},
 		{"progress", no_argument, NULL, 'P'},
 		{"debug", no_argument, NULL, 3},
+#ifdef	USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#endif							/* USE_ENCRYPTION */
 		{NULL, 0, NULL, 0}
 	};
 	int			option_index;
@@ -156,7 +166,7 @@ main(int argc, char **argv)
 		}
 	}
 
-	while ((c = getopt_long(argc, argv, "cD:nNPR", long_options, &option_index)) != -1)
+	while ((c = getopt_long(argc, argv, "cD:K:nNPR", long_options, &option_index)) != -1)
 	{
 		switch (c)
 		{
@@ -204,6 +214,12 @@ main(int argc, char **argv)
 			case 4:
 				no_ensure_shutdown = true;
 				break;
+
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = strdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
 		}
 	}
 
@@ -308,6 +324,49 @@ main(int argc, char **argv)
 	digestControlFile(&ControlFile_target, buffer, size);
 	pg_free(buffer);
 
+	/*
+	 * Setup encryption if it's obvious that we'll have to deal with encrypted
+	 * cluster.
+	 */
+	if (DATA_CIPHER_GET_KIND(ControlFile_target.data_cipher) != PG_CIPHER_NONE)
+#ifdef USE_ENCRYPTION
+	{
+		int		key_len;
+
+		/*
+		 * Try to retrieve the command from environment variable. We do this
+		 * primarily to make automated tests work for encrypted cluster w/o
+		 * changing the scripts. XXX Not sure the variable should be
+		 * documented. If we do, then pg_ctl should probably accept it too.
+		 */
+		if (encryption_key_command == NULL)
+		{
+			encryption_key_command = getenv("PGENCRKEYCMD");
+			if (encryption_key_command && strlen(encryption_key_command) == 0)
+				encryption_key_command = NULL;
+		}
+
+		if (encryption_key_command == NULL)
+		{
+			pg_log_error("-K option must be passed for encrypted cluster");
+			exit(EXIT_FAILURE);
+		}
+
+		data_cipher = ControlFile_target.data_cipher;
+		key_len = DATA_CIPHER_GET_KEY_LENGTH(data_cipher);
+		run_encryption_key_command(datadir_source, &key_len);
+		setup_encryption();
+		data_encrypted = true;
+		encryption_key_length = key_len;
+	}
+#else
+	{
+		pg_log_error(ENCRYPTION_NOT_SUPPORTED_MSG);
+		exit(EXIT_FAILURE);
+	}
+#endif	/* USE_ENCRYPTION */
+
+
 	if (!no_ensure_shutdown &&
 		ControlFile_target.state != DB_SHUTDOWNED &&
 		ControlFile_target.state != DB_SHUTDOWNED_IN_RECOVERY)
@@ -718,6 +777,27 @@ sanityChecks(void)
 		ControlFile_source.state != DB_SHUTDOWNED &&
 		ControlFile_source.state != DB_SHUTDOWNED_IN_RECOVERY)
 		pg_fatal("source data directory must be shut down cleanly");
+
+	/*
+	 * Since standby receives XLOG stream encrypted by master, handling
+	 * differently encrypted clusters is not the typical use case for
+	 * pg_rewind. Yet we should check the encryption.
+	 */
+	if (DATA_CIPHER_GET_KIND(ControlFile_source.data_cipher) != PG_CIPHER_NONE ||
+		DATA_CIPHER_GET_KIND(ControlFile_target.data_cipher) != PG_CIPHER_NONE)
+	{
+		if (DATA_CIPHER_GET_KIND(ControlFile_source.data_cipher) !=
+			DATA_CIPHER_GET_KIND(ControlFile_target.data_cipher))
+			pg_fatal("source and target server must be both unencrypted or both encrypted\n");
+
+		/* Keys should match. */
+		if (DATA_CIPHER_GET_KEY_LENGTH(ControlFile_source.data_cipher) !=
+			DATA_CIPHER_GET_KEY_LENGTH(ControlFile_target.data_cipher) ||
+			memcmp(ControlFile_source.encryption_verification,
+				   ControlFile_target.encryption_verification,
+				   ENCRYPTION_SAMPLE_SIZE))
+			pg_fatal("both source and target server must use the same encryption key");
+	}
 }
 
 /*
@@ -1124,13 +1204,54 @@ ensureCleanShutdown(const char *argv0)
 	 * fsync here.  This makes the recovery faster, and the target data folder
 	 * is synced at the end anyway.
 	 */
-	snprintf(cmd, MAXCMDLEN, "\"%s\" --single -F -D \"%s\" template1 < \"%s\"",
-			 exec_path, datadir_target, DEVNULL);
+	if (!data_encrypted)
+	{
+		snprintf(cmd, MAXCMDLEN, "\"%s\" --single -F -D \"%s\" template1 < \"%s\"",
+				 exec_path, datadir_target, DEVNULL);
 
-	if (system(cmd) != 0)
+		if (system(cmd) != 0)
+		{
+			pg_log_error("postgres single-user mode in target cluster failed");
+			pg_fatal("Command was: %s", cmd);
+		}
+	}
+	else
 	{
-		pg_log_error("postgres single-user mode in target cluster failed");
-		pg_fatal("Command was: %s", cmd);
+		FILE	   *cmdfd;
+		int			exitstatus;
+
+		/*
+		 * If the cluster is encrypted, we need to send encryption key to the
+		 * backend.
+		 */
+		snprintf(cmd, MAXCMDLEN, "\"%s\" --single -F -D \"%s\" template1",
+				 exec_path, datadir_target);
+
+		errno = 0;
+		cmdfd = popen(cmd, "w");
+		if (cmdfd == NULL)
+		{
+			pg_log_error("postgres single-user mode in target cluster failed");
+			pg_fatal("Command was: %s", cmd);
+		}
+
+		send_encryption_key(cmdfd);
+
+		exitstatus = pclose(cmdfd);
+
+		if (exitstatus == -1)
+		{
+			/* pclose() itself failed, and hopefully set errno */
+			pg_fatal("pclose() failed: %m");
+		}
+		else if (exitstatus != 0)
+		{
+			char	*reason;
+
+			reason = wait_result_to_str(exitstatus);
+			pg_fatal("%s", reason);
+			pfree(reason);
+		}
 	}
 }
 
diff --git a/src/bin/pg_upgrade/controldata.c b/src/bin/pg_upgrade/controldata.c
index 279174f441..c810c92c1a 100644
--- a/src/bin/pg_upgrade/controldata.c
+++ b/src/bin/pg_upgrade/controldata.c
@@ -3,6 +3,7 @@
  *
  *	controldata functions
  *
+ *	Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
  *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/controldata.c
  */
@@ -203,6 +204,14 @@ get_control_data(ClusterInfo *cluster, bool live_check)
 		got_data_checksum_version = true;
 	}
 
+	/*
+	 * The cluster is not necessarily encrypted. In case it is, set the
+	 * default key length because this is the only possible length for TDE 1.0
+	 * and because TDE 1.0 does not report the key length explicitly.
+	 */
+	DATA_CIPHER_SET(cluster->controldata.data_cipher, PG_CIPHER_NONE,
+					DEFAULT_ENCRYPTION_KEY_LENGTH);
+
 	/* we have the result of cmd in "output". so parse it line by line now */
 	while (fgets(bufin, sizeof(bufin), output))
 	{
@@ -496,6 +505,65 @@ get_control_data(ClusterInfo *cluster, bool live_check)
 			cluster->controldata.data_checksum_version = str2uint(p);
 			got_data_checksum_version = true;
 		}
+		else if ((p = strstr(bufin, "Encryption key length")) != NULL)
+		{
+			uint	key_bits;
+
+			p = strchr(p, ':');
+
+			if (p == NULL || strlen(p) <= 1)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+
+			p++;				/* remove ':' char */
+			key_bits = str2uint(p);
+			/* Currently we only support this one cipher. */
+			DATA_CIPHER_SET(cluster->controldata.data_cipher,
+							PG_CIPHER_AES_CTR_CBC, key_bits / 8);
+		}
+		else if ((p = strstr(bufin, "encryption fingerprint")) != NULL)
+		{
+			int			key_len, i;
+			int	sample_int[ENCRYPTION_SAMPLE_SIZE];
+
+			/*
+			 * If the cluster supports configurable key length, we should
+			 * already have processed the information. If we haven't seen the
+			 * key length info so far, it probably means that the cluster is
+			 * TDE 1.0 (key length not configurable) - the default key length
+			 * was set earlier for this purpose.
+			 */
+			key_len = DATA_CIPHER_GET_KEY_LENGTH(cluster->controldata.data_cipher);
+
+			/*
+			 * Whether the key length was seen or not, we're now sure that the
+			 * cluster is encrypted. Currently we only support this one
+			 * cipher.
+			 */
+			DATA_CIPHER_SET(cluster->controldata.data_cipher,
+							PG_CIPHER_AES_CTR_CBC, key_len);
+
+			/* Skip the colon and any whitespace after it */
+			p = strchr(p, ':');
+			if (p == NULL || strlen(p) <= 1)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+			p = strpbrk(p, "01234567890ABCDEF");
+			if (p == NULL || strlen(p) <= 1)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+
+			/* Make sure it looks like a valid finerprint */
+			if (strspn(p, "0123456789ABCDEF") != 32)
+				pg_fatal("%d: controldata retrieval problem\n", __LINE__);
+
+			/*
+			 * See encryption_key_from_string() for explanation why %2hhx
+			 * conversion cannot be used here.
+			 */
+			for (i = 0; i < ENCRYPTION_SAMPLE_SIZE; i++)
+				sscanf(p + 2 * i, "%2x", sample_int + i);
+			for (i = 0; i < ENCRYPTION_SAMPLE_SIZE; i++)
+				cluster->controldata.encryption_verification[i] =
+					(char) sample_int[i];
+		}
 	}
 
 	pclose(output);
@@ -697,6 +765,32 @@ check_control_data(ControlData *oldctrl,
 		pg_fatal("old cluster uses data checksums but the new one does not\n");
 	else if (oldctrl->data_checksum_version != newctrl->data_checksum_version)
 		pg_fatal("old and new cluster pg_controldata checksum versions do not match\n");
+
+	if (DATA_CIPHER_GET_KIND(oldctrl->data_cipher) != PG_CIPHER_NONE &&
+		DATA_CIPHER_GET_KIND(newctrl->data_cipher) == PG_CIPHER_NONE)
+		pg_fatal("old cluster is encrypted, upgrade to a non-encrypted cluster is not supported\n");
+	else if (DATA_CIPHER_GET_KIND(oldctrl->data_cipher) == PG_CIPHER_NONE &&
+			 DATA_CIPHER_GET_KIND(newctrl->data_cipher) != PG_CIPHER_NONE)
+		pg_fatal("old cluster is not encrypted, upgrade to an encrypted cluster is not supported\n");
+	else if (DATA_CIPHER_GET_KIND(oldctrl->data_cipher) != PG_CIPHER_NONE)
+	{
+		/* Both clusters are encrypted. */
+
+		/* Currently we only support one cipher. */
+		Assert(DATA_CIPHER_GET_KIND(oldctrl->data_cipher) ==
+			   DATA_CIPHER_GET_KIND(newctrl->data_cipher));
+
+		/* Key lengths should match. */
+		if (DATA_CIPHER_GET_KEY_LENGTH(oldctrl->data_cipher) !=
+			DATA_CIPHER_GET_KEY_LENGTH(newctrl->data_cipher))
+			pg_fatal("keys of different length were used to encrypt the old and the new cluster\n");
+
+		/* Have the same keys been used to encrypt the clusters? */
+		if (memcmp(oldctrl->encryption_verification,
+				   newctrl->encryption_verification,
+				   ENCRYPTION_SAMPLE_SIZE) != 0)
+			pg_fatal("encryption of the new cluster is not compatible with encryption of the old one\n");
+	}
 }
 
 
diff --git a/src/bin/pg_upgrade/dump.c b/src/bin/pg_upgrade/dump.c
index 90060d0f8e..f6ba95b900 100644
--- a/src/bin/pg_upgrade/dump.c
+++ b/src/bin/pg_upgrade/dump.c
@@ -3,7 +3,8 @@
  *
  *	dump functions
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/dump.c
  */
 
@@ -20,7 +21,7 @@ generate_old_dump(void)
 	prep_status("Creating dump of global objects");
 
 	/* run new pg_dumpall binary for globals */
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/pg_dumpall\" %s --globals-only --quote-all-identifiers "
 			  "--binary-upgrade %s -f %s",
 			  new_cluster.bindir, cluster_conn_opts(&old_cluster),
diff --git a/src/bin/pg_upgrade/exec.c b/src/bin/pg_upgrade/exec.c
index 19cc06e0c3..36b5de9b8b 100644
--- a/src/bin/pg_upgrade/exec.c
+++ b/src/bin/pg_upgrade/exec.c
@@ -3,7 +3,8 @@
  *
  *	execution functions
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/exec.c
  */
 
@@ -75,11 +76,16 @@ get_bin_version(ClusterInfo *cluster)
  * If the command fails, an error message is optionally written to the specified
  * log_file, and the program optionally exits.
  *
+ * If encryption_key is passed, popen() is used and the key is sent to stdin
+ * of the command.
+ *
  * The code requires it be called first from the primary thread on Windows.
  */
 bool
 exec_prog(const char *log_file, const char *opt_log_file,
-		  bool report_error, bool exit_on_error, const char *fmt,...)
+		  bool report_error, bool exit_on_error,
+		  EncryptionKey *encryption_key,
+		  const char *fmt,...)
 {
 	int			result = 0;
 	int			written;
@@ -171,7 +177,27 @@ exec_prog(const char *log_file, const char *opt_log_file,
 	/* see comment above */
 	if (mainThreadId == GetCurrentThreadId())
 #endif
-		result = system(cmd);
+	{
+		if (!encryption_key)
+			result = system(cmd);
+		else
+		{
+			FILE	*fp;
+			int	i;
+
+			fp = popen(cmd, "w");
+			if (fp == NULL)
+				pg_fatal("Failed to execute \"%s\"\n", cmd);
+
+			/* Send the key. */
+			for (i = 0; i < encryption_key->length; i++)
+				fprintf(fp, "%.2x", encryption_key->data[i]);
+			fputc('\n', fp);
+
+			if (pclose(fp))
+				pg_fatal("\"%s\" returned non-zero code\n", cmd);
+		}
+	}
 
 	if (result != 0 && report_error)
 	{
diff --git a/src/bin/pg_upgrade/option.c b/src/bin/pg_upgrade/option.c
index 64bbda5650..33bacf3a65 100644
--- a/src/bin/pg_upgrade/option.c
+++ b/src/bin/pg_upgrade/option.c
@@ -3,7 +3,8 @@
  *
  *	options functions
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/option.c
  */
 
@@ -56,6 +57,9 @@ parseCommandLine(int argc, char *argv[])
 		{"socketdir", required_argument, NULL, 's'},
 		{"verbose", no_argument, NULL, 'v'},
 		{"clone", no_argument, NULL, 1},
+#ifdef USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#endif	/* USE_ENCRYPTION */
 
 		{NULL, 0, NULL, 0}
 	};
@@ -101,7 +105,7 @@ parseCommandLine(int argc, char *argv[])
 	if (os_user_effective_id == 0)
 		pg_fatal("%s: cannot be run as root\n", os_info.progname);
 
-	while ((option = getopt_long(argc, argv, "d:D:b:B:cj:ko:O:p:P:rs:U:v",
+	while ((option = getopt_long(argc, argv, "d:D:b:B:cj:K:ko:O:p:P:rs:U:v",
 								 long_options, &optindex)) != -1)
 	{
 		switch (option)
@@ -203,6 +207,21 @@ parseCommandLine(int argc, char *argv[])
 				user_opts.transfer_mode = TRANSFER_MODE_CLONE;
 				break;
 
+#ifdef USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+
+				/*
+				 * If the command is a command line option, it probably means
+				 * that the clusters do not have it in postgresql.conf, and
+				 * therefore we must pass it to pg_ctl when starting them.
+				 */
+				snprintf(encryption_key_command_opt,
+						 strlen(encryption_key_command) + 7,
+						 " -K \"%s\"", encryption_key_command);
+				break;
+#endif	/* USE_ENCRYPTION */
+
 			default:
 				fprintf(stderr, _("Try \"%s --help\" for more information.\n"),
 						os_info.progname);
@@ -307,6 +326,9 @@ usage(void)
 	printf(_("  -v, --verbose                 enable verbose internal logging\n"));
 	printf(_("  -V, --version                 display version information, then exit\n"));
 	printf(_("  --clone                       clone instead of copying files to new cluster\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command  command that returns encryption key\n\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -?, --help                    show this help, then exit\n"));
 	printf(_("\n"
 			 "Before running pg_upgrade you must:\n"
diff --git a/src/bin/pg_upgrade/parallel.c b/src/bin/pg_upgrade/parallel.c
index ee7364da3b..b3b1b383bc 100644
--- a/src/bin/pg_upgrade/parallel.c
+++ b/src/bin/pg_upgrade/parallel.c
@@ -3,7 +3,8 @@
  *
  *	multi-process support
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/parallel.c
  */
 
@@ -78,7 +79,7 @@ parallel_exec_prog(const char *log_file, const char *opt_log_file,
 
 	if (user_opts.jobs <= 1)
 		/* exit_on_error must be true to allow jobs */
-		exec_prog(log_file, opt_log_file, true, true, "%s", cmd);
+		exec_prog(log_file, opt_log_file, true, true, NULL, "%s", cmd);
 	else
 	{
 		/* parallel */
@@ -121,7 +122,8 @@ parallel_exec_prog(const char *log_file, const char *opt_log_file,
 		child = fork();
 		if (child == 0)
 			/* use _exit to skip atexit() functions */
-			_exit(!exec_prog(log_file, opt_log_file, true, true, "%s", cmd));
+			_exit(!exec_prog(log_file, opt_log_file, true, true, NULL, "%s",
+							 cmd));
 		else if (child < 0)
 			/* fork failed */
 			pg_fatal("could not create worker process: %s\n", strerror(errno));
@@ -157,7 +159,7 @@ win32_exec_prog(exec_thread_arg *args)
 {
 	int			ret;
 
-	ret = !exec_prog(args->log_file, args->opt_log_file, true, true, "%s", args->cmd);
+	ret = !exec_prog(args->log_file, args->opt_log_file, true, true, NULL, "%s", args->cmd);
 
 	/* terminates thread */
 	return ret;
diff --git a/src/bin/pg_upgrade/pg_upgrade.c b/src/bin/pg_upgrade/pg_upgrade.c
index 3628bd74a7..d688154c25 100644
--- a/src/bin/pg_upgrade/pg_upgrade.c
+++ b/src/bin/pg_upgrade/pg_upgrade.c
@@ -3,7 +3,8 @@
  *
  *	main source file
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/pg_upgrade.c
  */
 
@@ -42,16 +43,21 @@
 #endif
 
 #include "catalog/pg_class_d.h"
+#include "common/encryption.h"
 #include "common/file_perm.h"
 #include "common/logging.h"
 #include "common/restricted_token.h"
 #include "fe_utils/string_utils.h"
 #include "pg_upgrade.h"
 
+#ifdef USE_ENCRYPTION
+static char *get_encryption_key_command(char *bindir, char *pgconfig);
+#endif	/* USE_ENCRYPTION */
+
 static void prepare_new_cluster(void);
 static void prepare_new_globals(void);
 static void create_new_objects(void);
-static void copy_xact_xlog_xid(void);
+static void copy_xact_xlog_xid(EncryptionKey *encryption_key);
 static void set_frozenxids(bool minmxid_only);
 static void setup(char *argv0, bool *live_check);
 static void cleanup(void);
@@ -71,12 +77,24 @@ char	   *output_files[] = {
 	NULL
 };
 
+char encryption_key_command_opt[MAXPGPATH];
+
+/*
+ * Declare these locally so we don't have to link storage/file/encryption.c
+ * here.
+ */
+bool		encryption_setup_done = false;
+extern unsigned char encryption_key[ENCRYPTION_KEY_MAX_LENGTH];
 
 int
 main(int argc, char **argv)
 {
 	char	   *deletion_script_file_name = NULL;
 	bool		live_check = false;
+#ifdef USE_ENCRYPTION
+	char	*key_cmd_pgconf;
+	EncryptionKey	encr_key_arg;
+#endif
 
 	pg_logging_init(argv[0]);
 	set_pglocale_pgservice(argv[0], PG_TEXTDOMAIN("pg_upgrade"));
@@ -84,6 +102,7 @@ main(int argc, char **argv)
 	/* Set default restrictive mask until new cluster permissions are read */
 	umask(PG_MODE_MASK_OWNER);
 
+	encryption_key_command_opt[0] = '\0';
 	parseCommandLine(argc, argv);
 
 	get_restricted_token();
@@ -111,6 +130,70 @@ main(int argc, char **argv)
 
 	check_and_dump_old_cluster(live_check);
 
+#ifdef USE_ENCRYPTION
+	/* Try to get the encryption key command from postgresql.conf. */
+	key_cmd_pgconf = get_encryption_key_command(old_cluster.bindir,
+												old_cluster.pgconfig);
+	old_cluster.has_encr_key_cmd = key_cmd_pgconf != NULL;
+#endif
+
+	/*
+	 * Is the key passed as command line option?
+	 */
+	if (encryption_key_command)
+#ifdef USE_ENCRYPTION
+	{
+		/* The command in postgresql.conf takes precedence. */
+		if (key_cmd_pgconf)
+		{
+			pg_log(PG_WARNING,
+				   "ignoring the -K option due to presence of encryption_key_command in configuration file\n");
+			encryption_key_command = key_cmd_pgconf;
+		}
+	}
+	else
+	{
+		/* Only specified in postgresql.conf, so use that value. */
+		encryption_key_command = key_cmd_pgconf;
+	}
+
+	/*
+	 * Setup the encryption if we have the command.
+	 *
+	 * Ideally we'd use get_control_data() to find out whether the encryption
+	 * is enabled, but that function assumes that postmaster lock file has
+	 * already been cleaned up.
+	 */
+	if (encryption_key_command)
+	{
+		int	key_len;
+
+		/*
+		 * We've already checked that both clusters use encryption key of the
+		 * same length.
+		 */
+		key_len = DATA_CIPHER_GET_KEY_LENGTH(old_cluster.controldata.data_cipher);
+
+		/*
+		 * Both clusters should eventually have KDF parameters of the old one,
+		 * so pass the old cluster's pgdata here.
+		 */
+		run_encryption_key_command(old_cluster.pgdata, &key_len);
+		encr_key_arg.data = encryption_key;
+		encr_key_arg.length = key_len;
+		encryption_setup_done = true;
+	}
+
+	/* Check if the new cluster has the key command in postgresql.conf. */
+	key_cmd_pgconf = get_encryption_key_command(new_cluster.bindir,
+												new_cluster.pgconfig);
+	new_cluster.has_encr_key_cmd = key_cmd_pgconf != NULL;
+#else
+	{
+		/* User should not be able to pass the -K option. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
 
 	/* -- NEW -- */
 	start_postmaster(&new_cluster, true);
@@ -131,7 +214,28 @@ main(int argc, char **argv)
 	 * Destructive Changes to New Cluster
 	 */
 
-	copy_xact_xlog_xid();
+#ifdef USE_ENCRYPTION
+	copy_xact_xlog_xid(encryption_setup_done ? &encr_key_arg : NULL);
+#else
+	copy_xact_xlog_xid(NULL);
+#endif	/* USE_ENCRYPTION */
+
+	if (encryption_setup_done)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * Copy KDF file so that the old cluster encryption password works for
+		 * the new cluster.
+		 */
+		read_kdf_file(old_cluster.pgdata);
+		write_kdf_file(new_cluster.pgdata);
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
 
 	/* New now using xids of the old system */
 
@@ -164,13 +268,19 @@ main(int argc, char **argv)
 	 */
 	prep_status("Setting next OID for new cluster");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+#ifdef USE_ENCRYPTION
+			  encryption_setup_done ? &encr_key_arg : NULL,
+#else
+			  NULL,
+#endif	/* USE_ENCRYPTION */
 			  "\"%s/pg_resetwal\" -o %u \"%s\"",
-			  new_cluster.bindir, old_cluster.controldata.chkpnt_nxtoid,
+			  new_cluster.bindir,
+			  old_cluster.controldata.chkpnt_nxtoid,
 			  new_cluster.pgdata);
 	check_ok();
 
 	prep_status("Sync data directory to disk");
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/initdb\" --sync-only \"%s\"", new_cluster.bindir,
 			  new_cluster.pgdata);
 	check_ok();
@@ -193,6 +303,44 @@ main(int argc, char **argv)
 	return 0;
 }
 
+#ifdef USE_ENCRYPTION
+/*
+ * Retrieve the value of encryption_key_command parameter from postgresql.conf
+ * and return it. Return NULL if the parameter is not set.
+ */
+static char *
+get_encryption_key_command(char	*bindir, char *pgconfig)
+{
+	char		cmd[MAXPGPATH],
+		cmd_output[MAX_STRING];
+	FILE *output = NULL;
+	char	*result = NULL;
+
+	/*
+	 * Retrieve the command from the old cluster: the command can reference
+	 * data directory because of the KDF file, but KDF files haven't yet been
+	 * synchronized.
+	 */
+	snprintf(cmd, sizeof(cmd), "\"%s/postgres\" -D \"%s\" -C encryption_key_command",
+			 bindir, pgconfig);
+
+	if ((output = popen(cmd, "r")) != NULL &&
+		fgets(cmd_output, sizeof(cmd_output), output) != NULL)
+	{
+		/* Remove trailing newline */
+		if (strchr(cmd_output, '\n') != NULL)
+			*strchr(cmd_output, '\n') = '\0';
+
+		if (strlen(cmd_output) > 0)
+			result = pg_strdup(cmd_output);
+	}
+
+	if (output && pclose(output) != 0)
+		pg_fatal("could not close pipe to \"%s\"", cmd);
+
+	return result;
+}
+#endif	/* USE_ENCRYPTION */
 
 static void
 setup(char *argv0, bool *live_check)
@@ -267,7 +415,7 @@ prepare_new_cluster(void)
 	 * --analyze so autovacuum doesn't update statistics later
 	 */
 	prep_status("Analyzing all rows in the new cluster");
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/vacuumdb\" %s --all --analyze %s",
 			  new_cluster.bindir, cluster_conn_opts(&new_cluster),
 			  log_opts.verbose ? "--verbose" : "");
@@ -280,7 +428,7 @@ prepare_new_cluster(void)
 	 * counter later.
 	 */
 	prep_status("Freezing all rows in the new cluster");
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/vacuumdb\" %s --all --freeze %s",
 			  new_cluster.bindir, cluster_conn_opts(&new_cluster),
 			  log_opts.verbose ? "--verbose" : "");
@@ -301,7 +449,7 @@ prepare_new_globals(void)
 	 */
 	prep_status("Restoring global objects in the new cluster");
 
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 			  "\"%s/psql\" " EXEC_PSQL_ARGS " %s -f \"%s\"",
 			  new_cluster.bindir, cluster_conn_opts(&new_cluster),
 			  GLOBALS_DUMP_FILE);
@@ -347,6 +495,7 @@ create_new_objects(void)
 				  NULL,
 				  true,
 				  true,
+				  NULL,
 				  "\"%s/pg_restore\" %s %s --exit-on-error --verbose "
 				  "--dbname postgres \"%s\"",
 				  new_cluster.bindir,
@@ -443,7 +592,7 @@ copy_subdir_files(const char *old_subdir, const char *new_subdir)
 
 	prep_status("Copying old %s to new server", old_subdir);
 
-	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+	exec_prog(UTILITY_LOG_FILE, NULL, true, true, NULL,
 #ifndef WIN32
 			  "cp -Rf \"%s\" \"%s\"",
 #else
@@ -456,7 +605,7 @@ copy_subdir_files(const char *old_subdir, const char *new_subdir)
 }
 
 static void
-copy_xact_xlog_xid(void)
+copy_xact_xlog_xid(EncryptionKey *encryption_key)
 {
 	/*
 	 * Copy old commit logs to new data dir. pg_clog has been renamed to
@@ -469,6 +618,7 @@ copy_xact_xlog_xid(void)
 
 	prep_status("Setting oldest XID for new cluster");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_key,
 			  "\"%s/pg_resetwal\" -f -u %u \"%s\"",
 			  new_cluster.bindir, old_cluster.controldata.chkpnt_oldstxid,
 			  new_cluster.pgdata);
@@ -477,15 +627,20 @@ copy_xact_xlog_xid(void)
 	/* set the next transaction id and epoch of the new cluster */
 	prep_status("Setting next transaction ID and epoch for new cluster");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_key,
 			  "\"%s/pg_resetwal\" -f -x %u \"%s\"",
-			  new_cluster.bindir, old_cluster.controldata.chkpnt_nxtxid,
+			  new_cluster.bindir,
+			  old_cluster.controldata.chkpnt_nxtxid,
 			  new_cluster.pgdata);
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_key,
 			  "\"%s/pg_resetwal\" -f -e %u \"%s\"",
-			  new_cluster.bindir, old_cluster.controldata.chkpnt_nxtepoch,
+			  new_cluster.bindir,
+			  old_cluster.controldata.chkpnt_nxtepoch,
 			  new_cluster.pgdata);
 	/* must reset commit timestamp limits also */
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_key,
 			  "\"%s/pg_resetwal\" -f -c %u,%u \"%s\"",
 			  new_cluster.bindir,
 			  old_cluster.controldata.chkpnt_nxtxid,
@@ -512,6 +667,7 @@ copy_xact_xlog_xid(void)
 		 * counters here and the oldest multi present on system.
 		 */
 		exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+				  encryption_key,
 				  "\"%s/pg_resetwal\" -O %u -m %u,%u \"%s\"",
 				  new_cluster.bindir,
 				  old_cluster.controldata.chkpnt_nxtmxoff,
@@ -540,6 +696,7 @@ copy_xact_xlog_xid(void)
 		 * next=MaxMultiXactId, but multixact.c can cope with that just fine.
 		 */
 		exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+				  encryption_key,
 				  "\"%s/pg_resetwal\" -m %u,%u \"%s\"",
 				  new_cluster.bindir,
 				  old_cluster.controldata.chkpnt_nxtmulti + 1,
@@ -551,6 +708,7 @@ copy_xact_xlog_xid(void)
 	/* now reset the wal archives in the new cluster */
 	prep_status("Resetting WAL archives");
 	exec_prog(UTILITY_LOG_FILE, NULL, true, true,
+			  encryption_key,
 	/* use timeline 1 to match controldata and no WAL history file */
 			  "\"%s/pg_resetwal\" -l 00000001%s \"%s\"", new_cluster.bindir,
 			  old_cluster.controldata.nextxlogfile + 8,
diff --git a/src/bin/pg_upgrade/pg_upgrade.h b/src/bin/pg_upgrade/pg_upgrade.h
index e647e71eca..5d166fdd05 100644
--- a/src/bin/pg_upgrade/pg_upgrade.h
+++ b/src/bin/pg_upgrade/pg_upgrade.h
@@ -1,7 +1,8 @@
 /*
  *	pg_upgrade.h
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/pg_upgrade.h
  */
 
@@ -10,7 +11,9 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 
+#include "fe_utils/encryption.h"
 #include "libpq-fe.h"
+#include "storage/encryption.h"
 
 /* Use port in the private/dynamic port number range */
 #define DEF_PGUPORT			50432
@@ -220,6 +223,8 @@ typedef struct
 	bool		date_is_int;
 	bool		float8_pass_by_value;
 	uint32		data_checksum_version;
+	uint8		data_cipher;
+	uint8		encryption_verification[ENCRYPTION_SAMPLE_SIZE];
 } ControlData;
 
 /*
@@ -269,6 +274,8 @@ typedef struct
 	char		major_version_str[64];	/* string PG_VERSION of cluster */
 	uint32		bin_version;	/* version returned from pg_ctl */
 	const char *tablespace_suffix;	/* directory specification */
+	bool	has_encr_key_cmd;		/* is encryption key command in the config
+									 * file? */
 } ClusterInfo;
 
 
@@ -325,7 +332,7 @@ extern UserOpts user_opts;
 extern ClusterInfo old_cluster,
 			new_cluster;
 extern OSInfo os_info;
-
+extern char encryption_key_command_opt[];
 
 /* check.c */
 
@@ -356,8 +363,16 @@ void		generate_old_dump(void);
 
 #define EXEC_PSQL_ARGS "--echo-queries --set ON_ERROR_STOP=on --no-psqlrc --dbname=template1"
 
+typedef struct EncryptionKey
+{
+	unsigned char	*data;
+	int		length;
+} EncryptionKey;
+
 bool		exec_prog(const char *log_file, const char *opt_log_file,
-					  bool report_error, bool exit_on_error, const char *fmt,...) pg_attribute_printf(5, 6);
+					  bool report_error, bool exit_on_error,
+					  EncryptionKey *encryption_key, const char *fmt,...)
+	pg_attribute_printf(6, 7);
 void		verify_directories(void);
 bool		pid_lock_file_exists(const char *datadir);
 
diff --git a/src/bin/pg_upgrade/server.c b/src/bin/pg_upgrade/server.c
index 7fed0ae108..287c72825e 100644
--- a/src/bin/pg_upgrade/server.c
+++ b/src/bin/pg_upgrade/server.c
@@ -3,7 +3,8 @@
  *
  *	database server functions
  *
- *	Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *	src/bin/pg_upgrade/server.c
  */
 
@@ -200,9 +201,12 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 	PGconn	   *conn;
 	bool		pg_ctl_return = false;
 	char		socket_string[MAXPGPATH + 200];
+	char		encryption_key_port_opt[64];
 
 	static bool exit_hook_registered = false;
 
+	encryption_key_port_opt[0] = '\0';
+
 	if (!exit_hook_registered)
 	{
 		atexit(stop_postmaster_atexit);
@@ -244,9 +248,17 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 	 * Force vacuum_defer_cleanup_age to 0 on the new cluster, so that
 	 * vacuumdb --freeze actually freezes the tuples.
 	 */
+#ifndef HAVE_UNIX_SOCKETS
+	/* Make sure pg_ctl sends the encryption key to the correct port. */
+	sprintf(encryption_key_port_opt, " --encryption-key-port \"%d\"",
+			cluster->port);
+#endif
 	snprintf(cmd, sizeof(cmd),
-			 "\"%s/pg_ctl\" -w -l \"%s\" -D \"%s\" -o \"-p %d%s%s %s%s\" start",
-			 cluster->bindir, SERVER_LOG_FILE, cluster->pgconfig, cluster->port,
+			 "\"%s/pg_ctl\"%s%s -w -l \"%s\" -D \"%s\" -o \"-p %d%s%s %s%s\" start",
+			 cluster->bindir,
+			 encryption_key_command_opt,
+			 encryption_key_port_opt,
+			 SERVER_LOG_FILE, cluster->pgconfig, cluster->port,
 			 (cluster->controldata.cat_ver >=
 			  BINARY_UPGRADE_SERVER_FLAG_CAT_VER) ? " -b" :
 			 " -c autovacuum=off -c autovacuum_freeze_max_age=2000000000",
@@ -254,6 +266,61 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 			 " -c synchronous_commit=off -c fsync=off -c full_page_writes=off -c vacuum_defer_cleanup_age=0" : "",
 			 cluster->pgopts ? cluster->pgopts : "", socket_string);
 
+	/*
+	 * If encryption key needs to be sent, run a separate process now and let
+	 * it send the key to the postmaster.  We cannot send the key later in the
+	 * current process because the exec_prog call below blocks until the
+	 * postmaster succeeds or fails to start (and it will definitely fail if
+	 * it receives no key).
+	 */
+	if (encryption_setup_done && !cluster->has_encr_key_cmd)
+#ifdef USE_ENCRYPTION
+	{
+		SendKeyArgs	sk_args;
+		char	port_str[6];
+#ifndef WIN32
+		pid_t sender;
+#else
+		HANDLE sender;
+#endif
+
+		snprintf(port_str, sizeof(port_str), "%d", cluster->port);
+
+		/* in child process */
+		sk_args.host = cluster->sockdir; /* If NULL, then libpq will use
+										  * its default. */
+		sk_args.port = port_str;
+		sk_args.encryption_key = encryption_key;
+		/* XXX Find out the postmaster PID ? */
+		sk_args.pm_pid = 0;
+		sk_args.error_msg = NULL;
+
+#ifndef WIN32
+		pg_log(PG_VERBOSE, "sending encryption key to postmaster\n");
+		sender = fork();
+		if (sender == 0)
+		{
+			send_key_to_postmaster(&sk_args);
+			if (sk_args.error_msg)
+				pg_fatal("%s", sk_args.error_msg);
+			exit(EXIT_SUCCESS);
+		}
+		else if (sender < 0)
+			pg_fatal("could not create key sender process");
+#else	/* WIN32 */
+		pg_log(PG_VERBOSE, "sending encryption key to postmaster\n");
+		sender = _beginthreadex(NULL, 0, (void *) send_key_to_postmaster, &sk_args, 0, NULL);
+		if (sender == 0)
+			pg_fatal("could not create background thread: %m");
+#endif	/* WIN32 */
+	}
+#else	/* USE_ENCRYPTION */
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/*
 	 * Don't throw an error right away, let connecting throw the error because
 	 * it might supply a reason for the failure.
@@ -263,7 +330,7 @@ start_postmaster(ClusterInfo *cluster, bool report_and_exit_on_error)
 							  (strcmp(SERVER_LOG_FILE,
 									  SERVER_START_LOG_FILE) != 0) ?
 							  SERVER_LOG_FILE : NULL,
-							  report_and_exit_on_error, false,
+							  report_and_exit_on_error, false, NULL,
 							  "%s", cmd);
 
 	/* Did it fail and we are just testing if the server could be started? */
@@ -338,7 +405,7 @@ stop_postmaster(bool in_atexit)
 	else
 		return;					/* no cluster running */
 
-	exec_prog(SERVER_STOP_LOG_FILE, NULL, !in_atexit, !in_atexit,
+	exec_prog(SERVER_STOP_LOG_FILE, NULL, !in_atexit, !in_atexit, NULL,
 			  "\"%s/pg_ctl\" -w -D \"%s\" -o \"%s\" %s stop",
 			  cluster->bindir, cluster->pgconfig,
 			  cluster->pgopts ? cluster->pgopts : "",
diff --git a/src/bin/pg_verifybackup/Makefile b/src/bin/pg_verifybackup/Makefile
index c07643b129..264d88f3ff 100644
--- a/src/bin/pg_verifybackup/Makefile
+++ b/src/bin/pg_verifybackup/Makefile
@@ -7,6 +7,8 @@ subdir = src/bin/pg_verifybackup
 top_builddir = ../../..
 include $(top_builddir)/src/Makefile.global
 
+override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+
 # We need libpq only because fe_utils does.
 LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 
diff --git a/src/bin/pg_verifybackup/pg_verifybackup.c b/src/bin/pg_verifybackup/pg_verifybackup.c
index bb93b43093..7bc2800e4b 100644
--- a/src/bin/pg_verifybackup/pg_verifybackup.c
+++ b/src/bin/pg_verifybackup/pg_verifybackup.c
@@ -22,6 +22,7 @@
 #include "fe_utils/simple_list.h"
 #include "getopt_long.h"
 #include "parse_manifest.h"
+#include "storage/encryption.h"
 
 /*
  * For efficiency, we'd like our hash table containing information about the
@@ -160,6 +161,9 @@ main(int argc, char **argv)
 	static struct option long_options[] = {
 		{"exit-on-error", no_argument, NULL, 'e'},
 		{"ignore", required_argument, NULL, 'i'},
+#ifdef	USE_ENCRYPTION
+		{"encryption-key-command", required_argument, NULL, 'K'},
+#endif
 		{"manifest-path", required_argument, NULL, 'm'},
 		{"no-parse-wal", no_argument, NULL, 'n'},
 		{"quiet", no_argument, NULL, 'q'},
@@ -219,7 +223,11 @@ main(int argc, char **argv)
 	simple_string_list_append(&context.ignore_list, "recovery.signal");
 	simple_string_list_append(&context.ignore_list, "standby.signal");
 
+#ifdef	USE_ENCRYPTION
+	while ((c = getopt_long(argc, argv, "ei:m:K:nqsw:", long_options, NULL)) != -1)
+#else
 	while ((c = getopt_long(argc, argv, "ei:m:nqsw:", long_options, NULL)) != -1)
+#endif
 	{
 		switch (c)
 		{
@@ -241,6 +249,11 @@ main(int argc, char **argv)
 			case 'n':
 				no_parse_wal = true;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'q':
 				quiet = true;
 				break;
@@ -810,15 +823,46 @@ parse_required_wal(verifier_context *context, char *pg_waldump_path,
 				   char *wal_directory, manifest_wal_range *first_wal_range)
 {
 	manifest_wal_range *this_wal_range = first_wal_range;
+	char *encr_opt_str = NULL;
+
+	/*
+	 * Try to retrieve the command from environment variable. We do this
+	 * primarily to use encrypted clusters during automated tests. XXX Not
+	 * sure the variable should be documented. If we do, then pg_ctl should
+	 * probably accept it too.
+	 */
+	if (encryption_key_command == NULL)
+	{
+		encryption_key_command = getenv("PGENCRKEYCMD");
+		if (encryption_key_command && strlen(encryption_key_command) == 0)
+			encryption_key_command = NULL;
+	}
+
+	/* Prepare the -K option for the backend. */
+	if (encryption_key_command)
+	{
+		size_t		len;
+
+		len = strlen(encryption_key_command) + 6;
+		encr_opt_str = (char *) pg_malloc(len);
+		snprintf(encr_opt_str, len, "-K \"%s\"",
+				 encryption_key_command);
+	}
+	else
+	{
+		encr_opt_str = (char *) pg_malloc(1);
+		encr_opt_str[0] = '\0';
+	}
 
 	while (this_wal_range != NULL)
 	{
 		char	   *pg_waldump_cmd;
 
-		pg_waldump_cmd = psprintf("\"%s\" --quiet --path=\"%s\" --timeline=%u --start=%X/%X --end=%X/%X\n",
+		pg_waldump_cmd = psprintf("\"%s\" --quiet --path=\"%s\" --timeline=%u --start=%X/%X --end=%X/%X %s\n",
 								  pg_waldump_path, wal_directory, this_wal_range->tli,
 								  LSN_FORMAT_ARGS(this_wal_range->start_lsn),
-								  LSN_FORMAT_ARGS(this_wal_range->end_lsn));
+								  LSN_FORMAT_ARGS(this_wal_range->end_lsn),
+								  encr_opt_str);
 		if (system(pg_waldump_cmd) != 0)
 			report_backup_error(context,
 								"WAL parsing failed for timeline %u",
@@ -826,6 +870,9 @@ parse_required_wal(verifier_context *context, char *pg_waldump_path,
 
 		this_wal_range = this_wal_range->next;
 	}
+
+	if (encr_opt_str)
+		pg_free(encr_opt_str);
 }
 
 /*
@@ -914,6 +961,10 @@ usage(void)
 	printf(_("  -i, --ignore=RELATIVE_PATH  ignore indicated path\n"));
 	printf(_("  -m, --manifest-path=PATH    use specified path for manifest\n"));
 	printf(_("  -n, --no-parse-wal          do not try to parse WAL files\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command=COMMAND\n"
+			 "                              command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -q, --quiet                 do not print any output, except for errors\n"));
 	printf(_("  -s, --skip-checksums        skip checksum verification\n"));
 	printf(_("  -w, --wal-directory=PATH    use specified path for WAL files\n"));
diff --git a/src/bin/pg_waldump/.gitignore b/src/bin/pg_waldump/.gitignore
index 3be00a8b61..d04ac3ab9d 100644
--- a/src/bin/pg_waldump/.gitignore
+++ b/src/bin/pg_waldump/.gitignore
@@ -5,6 +5,7 @@
 /clogdesc.c
 /committsdesc.c
 /dbasedesc.c
+/encryption.c
 /genericdesc.c
 /gindesc.c
 /gistdesc.c
diff --git a/src/bin/pg_waldump/Makefile b/src/bin/pg_waldump/Makefile
index 9f333d0c8a..c73096cf6e 100644
--- a/src/bin/pg_waldump/Makefile
+++ b/src/bin/pg_waldump/Makefile
@@ -11,11 +11,13 @@ OBJS = \
 	$(RMGRDESCOBJS) \
 	$(WIN32RES) \
 	compat.o \
+	encryption.o \
 	pg_waldump.o \
 	rmgrdesc.o \
 	xlogreader.o
 
 override CPPFLAGS := -DFRONTEND $(CPPFLAGS)
+LDFLAGS_INTERNAL += -L$(top_builddir)/src/fe_utils -lpgfeutils $(libpq_pgport)
 
 RMGRDESCSOURCES = $(sort $(notdir $(wildcard $(top_srcdir)/src/backend/access/rmgrdesc/*desc.c)))
 RMGRDESCOBJS = $(patsubst %.c,%.o,$(RMGRDESCSOURCES))
@@ -32,6 +34,9 @@ xlogreader.c: % : $(top_srcdir)/src/backend/access/transam/%
 $(RMGRDESCSOURCES): % : $(top_srcdir)/src/backend/access/rmgrdesc/%
 	rm -f $@ && $(LN_S) $< .
 
+encryption.c: % : $(top_srcdir)/src/backend/storage/file/%
+	rm -f $@ && $(LN_S) $< .
+
 install: all installdirs
 	$(INSTALL_PROGRAM) pg_waldump$(X) '$(DESTDIR)$(bindir)/pg_waldump$(X)'
 
@@ -42,7 +47,8 @@ uninstall:
 	rm -f '$(DESTDIR)$(bindir)/pg_waldump$(X)'
 
 clean distclean maintainer-clean:
-	rm -f pg_waldump$(X) $(OBJS) $(RMGRDESCSOURCES) xlogreader.c
+	rm -f pg_waldump$(X) $(OBJS) $(RMGRDESCSOURCES) xlogreader.c \
+encryption.c
 	rm -rf tmp_check
 
 check:
diff --git a/src/bin/pg_waldump/pg_waldump.c b/src/bin/pg_waldump/pg_waldump.c
index 2daed328e7..f3424e7384 100644
--- a/src/bin/pg_waldump/pg_waldump.c
+++ b/src/bin/pg_waldump/pg_waldump.c
@@ -2,7 +2,8 @@
  *
  * pg_waldump.c - decode and display WAL
  *
- * Copyright (c) 2013-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Copyright (c) 2013-2022, PostgreSQL Global Development Group
  *
  * IDENTIFICATION
  *		  src/bin/pg_waldump/pg_waldump.c
@@ -22,8 +23,10 @@
 #include "access/xlogrecord.h"
 #include "common/fe_memutils.h"
 #include "common/logging.h"
+#include "fe_utils/encryption.h"
 #include "getopt_long.h"
 #include "rmgrdesc.h"
+#include "storage/encryption.h"
 
 static const char *progname;
 
@@ -191,25 +194,57 @@ search_directory(const char *directory, const char *fname)
 		PGAlignedXLogBlock buf;
 		int			r;
 
-		r = read(fd, buf.data, XLOG_BLCKSZ);
-		if (r == XLOG_BLCKSZ)
+		if (data_encrypted)
 		{
-			XLogLongPageHeader longhdr = (XLogLongPageHeader) buf.data;
-
-			WalSegSz = longhdr->xlp_seg_size;
-
+			/*
+			 * Segment size affects calculation of segNo and thus also the
+			 * encryption tweak, so we cannot get the size from the header
+			 * until the page is decrypted. Here we need to take more
+			 * expensive approach and really check the file size.
+			 */
+			WalSegSz = (int) lseek(fd, 0, SEEK_END);
+			if (WalSegSz <= 0)
+				fatal_error("Could not determine size of WAL segment \"%s\"", fname);
+
+			/*
+			 * Verification of the file size is the only useful thing we can
+			 * do. If anything else is wrong, the XLOG reader should find out
+			 * after decryption.
+			 */
 			if (!IsValidWalSegSize(WalSegSz))
-				fatal_error(ngettext("WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d byte",
-									 "WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d bytes",
+				fatal_error(ngettext("WAL segment size must be a power of two between 1 MB and 1 GB, but size of the WAL file \"%s\" is %d byte",
+									 "WAL segment size must be a power of two between 1 MB and 1 GB, but size of the WAL file \"%s\" is %d bytes",
 									 WalSegSz),
 							fname, WalSegSz);
 		}
-		else if (r < 0)
-			fatal_error("could not read file \"%s\": %m",
-						fname);
 		else
-			fatal_error("could not read file \"%s\": read %d of %zu",
-						fname, r, (Size) XLOG_BLCKSZ);
+		{
+			r = read(fd, buf.data, XLOG_BLCKSZ);
+			if (r == XLOG_BLCKSZ)
+			{
+				XLogLongPageHeader longhdr;
+
+				longhdr = (XLogLongPageHeader) buf.data;
+
+				if (longhdr->std.xlp_magic != XLOG_PAGE_MAGIC)
+					fatal_error(gettext("WAL segment \"%s\" has an incorrect magic number. If it's encrypted, use the -K option to pass encryption credentials"),
+								fname);
+
+				WalSegSz = longhdr->xlp_seg_size;
+
+				if (!IsValidWalSegSize(WalSegSz))
+					fatal_error(ngettext("WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d byte",
+										 "WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d bytes",
+										 WalSegSz),
+								fname, WalSegSz);
+			}
+			else if (r < 0)
+				fatal_error("could not read file \"%s\": %m",
+							fname);
+			else
+				fatal_error("could not read file \"%s\": read %d of %zu",
+							fname, r, (Size) XLOG_BLCKSZ);
+		}
 		close(fd);
 		return true;
 	}
@@ -350,7 +385,7 @@ WALDumpReadPage(XLogReaderState *state, XLogRecPtr targetPagePtr, int reqLen,
 	}
 
 	if (!WALRead(state, readBuff, targetPagePtr, count, private->timeline,
-				 &errinfo))
+				 &errinfo, data_encrypted))
 	{
 		WALOpenSegment *seg = &errinfo.wre_seg;
 		char		fname[MAXPGPATH];
@@ -726,6 +761,10 @@ usage(void)
 	printf(_("  -b, --bkp-details      output detailed information about backup blocks\n"));
 	printf(_("  -e, --end=RECPTR       stop reading at WAL location RECPTR\n"));
 	printf(_("  -f, --follow           keep retrying after reaching end of WAL\n"));
+#ifdef	USE_ENCRYPTION
+	printf(_("  -K, --encryption-key-command=COMMAND\n"
+			 "                         command that returns encryption key\n"));
+#endif							/* USE_ENCRYPTION */
 	printf(_("  -n, --limit=N          number of records to display\n"));
 	printf(_("  -p, --path=PATH        directory in which to find log segment files or a\n"
 			 "                         directory with a ./pg_wal that contains such files\n"
@@ -764,6 +803,7 @@ main(int argc, char **argv)
 		{"end", required_argument, NULL, 'e'},
 		{"follow", no_argument, NULL, 'f'},
 		{"help", no_argument, NULL, '?'},
+		{"encryption-key-command", required_argument, NULL, 'K'},
 		{"limit", required_argument, NULL, 'n'},
 		{"path", required_argument, NULL, 'p'},
 		{"quiet", no_argument, NULL, 'q'},
@@ -823,7 +863,7 @@ main(int argc, char **argv)
 		goto bad_argument;
 	}
 
-	while ((option = getopt_long(argc, argv, "be:fn:p:qr:s:t:x:z",
+	while ((option = getopt_long(argc, argv, "be:fK:n:p:qr:s:t:x:z",
 								 long_options, &optindex)) != -1)
 	{
 		switch (option)
@@ -843,6 +883,12 @@ main(int argc, char **argv)
 			case 'f':
 				config.follow = true;
 				break;
+#ifdef	USE_ENCRYPTION
+			case 'K':
+				encryption_key_command = pg_strdup(optarg);
+				data_encrypted = true;
+				break;
+#endif							/* USE_ENCRYPTION */
 			case 'n':
 				if (sscanf(optarg, "%d", &config.stop_after_records) != 1)
 				{
@@ -1037,6 +1083,27 @@ main(int argc, char **argv)
 
 	/* done with argument parsing, do the actual work */
 
+	if (data_encrypted)
+#ifdef USE_ENCRYPTION
+	{
+		/*
+		 * There's no easy way to get the key length, so don't let us issue
+		 * error messages about incorrect key length. A key of incorrect
+		 * length will simply cause a failure to decrypt the data.
+		 */
+		int	key_len = 0;
+
+		run_encryption_key_command(NULL, &key_len);
+		DATA_CIPHER_SET(data_cipher, PG_CIPHER_AES_CTR_CBC, key_len);
+		setup_encryption();
+	}
+#else
+	{
+		/* User should not be able to enable encryption. */
+		Assert(false);
+	}
+#endif	/* USE_ENCRYPTION */
+
 	/* we have everything we need, start reading */
 	xlogreader_state =
 		XLogReaderAllocate(WalSegSz, waldir,
diff --git a/src/common/Makefile b/src/common/Makefile
index 880722fcf5..4c8f70d626 100644
--- a/src/common/Makefile
+++ b/src/common/Makefile
@@ -53,6 +53,7 @@ OBJS_COMMON = \
 	controldata_utils.o \
 	d2s.o \
 	encnames.o \
+	encryption.o \
 	exec.o \
 	f2s.o \
 	file_perm.o \
diff --git a/src/common/encryption.c b/src/common/encryption.c
new file mode 100644
index 0000000000..28fb46c8eb
--- /dev/null
+++ b/src/common/encryption.c
@@ -0,0 +1,282 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.c
+ *	  Transparent Data Encryption specific code usable by both frontend and
+ *	  backend.
+ *
+ * Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
+ *
+ * IDENTIFICATION
+ *	  src/common/encryption.c
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef FRONTEND
+#include "postgres.h"
+#else
+#include "postgres_fe.h"
+#endif
+
+#include "common/encryption.h"
+#include "common/logging.h"
+
+#ifdef USE_ENCRYPTION
+#include <openssl/evp.h>
+#endif	/* USE_ENCRYPTION */
+
+unsigned char encryption_key[ENCRYPTION_KEY_MAX_LENGTH];
+int	encryption_key_length = 0;
+
+/* Copy of the corresponding field of ControlFileData */
+uint8 data_cipher = 0;
+
+char	   *encryption_key_command = NULL;
+
+/*
+ * Run the command that is supposed to generate encryption key and store it
+ * where encryption_key points to. If valid string is passed for data_dir,
+ * it's used to replace '%D' pattern in the command.
+ *
+ * If *key_len_p is greater than zero, it specifies the expected key
+ * length. If it's zero, caller expects the actual length to be reported via
+ * this argument.
+ */
+void
+run_encryption_key_command(char *data_dir, int *key_len_p)
+{
+	FILE	   *fp;
+	int		dlen;
+	char	*cmd, *sp, *dp, *endp;
+
+	Assert(encryption_key_command != NULL &&
+		   strlen(encryption_key_command) > 0);
+
+	dlen = strlen(encryption_key_command);
+	if (data_dir)
+		dlen += strlen(data_dir);
+	/*
+	 * The terminating '\0'. XXX Is it worth subtracting 2 for the "%D"
+	 * part?
+	 */
+	dlen += 1;
+	cmd = palloc(dlen);
+
+	/*
+	 * Replace %D pattern in the command with the actual data directory path.
+	 */
+	dp = cmd;
+	endp = cmd + dlen - 1;
+	*endp = '\0';
+	for (sp = encryption_key_command; *sp; sp++)
+	{
+		if (*sp == '%')
+		{
+			if (sp[1] == 'D')
+			{
+				if (data_dir == NULL)
+				{
+#ifdef FRONTEND
+					pg_log_fatal("data directory is not known, %%D pattern cannot be replaced");
+					exit(EXIT_FAILURE);
+#else
+					ereport(FATAL,
+							(errmsg("data directory is not known, %%D pattern cannot be replaced")));
+#endif	/* FRONTEND */
+				}
+
+				sp++;
+				strlcpy(dp, data_dir, endp - dp);
+				make_native_path(dp);
+				dp += strlen(dp);
+			}
+			else if (dp < endp)
+				*dp++ = *sp;
+			else
+				break;
+		}
+		else
+		{
+			if (dp < endp)
+				*dp++ = *sp;
+			else
+				break;
+		}
+	}
+	*dp = '\0';
+
+	/* Do not print the command itself, in case it's just "echo <the key>" */
+#ifdef FRONTEND
+	pg_log_debug("executing encryption key command");
+#else
+	ereport(DEBUG1,
+			(errmsg("executing encryption key command")));
+#endif	/* FRONTEND */
+
+	fp = popen(cmd, "r");
+	if (fp == NULL)
+	{
+#ifdef FRONTEND
+		pg_log_fatal("could not execute \"%s\"", cmd);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("could not execute \"%s\"", cmd)));
+#endif	/* FRONTEND */
+	}
+
+	/* Read the key. */
+	read_encryption_key_f(fp, cmd, key_len_p);
+
+	if (pclose(fp) != 0)
+	{
+#ifdef FRONTEND
+		pg_log_fatal("could not close pipe to \"%s\"", cmd);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("could not close pipe to \"%s\"", cmd)));
+#endif	/* FRONTEND */
+	}
+	pfree(cmd);
+}
+
+/*
+ * Send encryption key in hexadecimal format to the file stream passed.
+ *
+ * The backend processes could actually receive binary data but that would
+ * make startup of postgres in single-user mode less convenient.
+ */
+void
+send_encryption_key(FILE *f)
+{
+	int	i;
+
+	for (i = 0; i < encryption_key_length; i++)
+		fprintf(f, "%.2x", encryption_key[i]);
+	fputc('\n', f);
+}
+
+
+
+/*
+ * Read the encryption key from a file stream.
+ *
+ * The header comment of run_encryption_key_command() explains the key_len_p
+ * argument.
+ */
+void
+read_encryption_key_f(FILE *f, char *command, int *key_len_p)
+{
+	char	   buf[ENCRYPTION_KEY_MAX_CHARS];
+	int		key_len = *key_len_p;
+	int		read_len, c;
+	int		key_chars = key_len * 2;
+
+	Assert(key_len == 0 || key_len == 16 || key_len == 24 || key_len == 32);
+
+	read_len = 0;
+	while ((c = fgetc(f)) != EOF && c != '\n')
+	{
+		if (read_len >= ENCRYPTION_KEY_MAX_CHARS)
+		{
+#ifdef FRONTEND
+			pg_log_fatal("encryption key is too long, should contain no more than %d hexadecimal characters",
+						 ENCRYPTION_KEY_MAX_CHARS);
+			exit(EXIT_FAILURE);
+#else
+			ereport(FATAL,
+					(errmsg("encryption key is too long, should contain no more than %d hexadecimal characters",
+							ENCRYPTION_KEY_MAX_CHARS)));
+#endif	/* FRONTEND */
+		}
+
+		if (key_len > 0 && read_len >= key_chars)
+		{
+#ifdef FRONTEND
+			pg_log_fatal("encryption key is too long, should be a %d character hex string",
+						 key_len * 2);
+			exit(EXIT_FAILURE);
+#else
+			ereport(FATAL,
+					(errmsg("encryption key is too long, should be a %d character hex string",
+						key_len * 2)));
+#endif	/* FRONTEND */
+		}
+
+		buf[read_len++] = c;
+	}
+
+	if (c == EOF && read_len == 0)
+	{
+		char	src[MAXPGPATH];
+
+		if (command)
+			snprintf(src, MAXPGPATH, "command \"%s\"", command);
+		else
+			snprintf(src, MAXPGPATH, "stdin");
+
+#ifdef FRONTEND
+		pg_log_fatal("could not read encryption key from %s", src);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("could not read encryption key from %s",
+						src)));
+#endif	/* FRONTEND */
+	}
+
+	if (key_chars > 0 && read_len < key_chars)
+	{
+#ifdef FRONTEND
+		pg_log_fatal("encryption key is too short, should be a %d character hex string",
+					 key_len * 2);
+		exit(EXIT_FAILURE);
+#else
+		ereport(FATAL,
+				(errmsg("encryption key is too short, should be a %d character hex string",
+					key_len * 2)));
+#endif	/* FRONTEND */
+	}
+
+	Assert(read_len % 2 == 0);
+	if (key_len == 0)
+	{
+		key_len = read_len / 2;
+		*key_len_p = key_len;
+	}
+
+	/* Turn the hexadecimal representation into an array of bytes. */
+	encryption_key_from_string(buf, key_len);
+}
+
+/*
+ * Use the input hexadecimal string to initialize the encryption_key variable.
+ */
+void
+encryption_key_from_string(char key_str[ENCRYPTION_KEY_MAX_CHARS], int key_len)
+{
+	int	encr_key_int[ENCRYPTION_KEY_MAX_LENGTH];
+	int	i;
+
+	for (i = 0; i < key_len; i++)
+	{
+		/*
+		 * The code would be simpler with %2hhx conversion, but it does not
+		 * seem to be well portable. At least mingw build on Windows
+		 * complains about it.
+		 */
+		if (sscanf(key_str + 2 * i, "%2x", encr_key_int + i) == 0)
+		{
+#ifdef FRONTEND
+			pg_log_fatal("the encryption key may only contain hexadecimal digits");
+			exit(EXIT_FAILURE);
+#else
+			ereport(FATAL,
+					(errmsg("the encryption key may only contain hexadecimal digits")));
+#endif	/* FRONTEND */
+		}
+	}
+	memset(encryption_key, 0, ENCRYPTION_KEY_MAX_LENGTH);
+	for (i = 0; i < key_len; i++)
+		encryption_key[i] = (char) encr_key_int[i];
+}
diff --git a/src/common/string.c b/src/common/string.c
index 3aa378c051..efb3de29e3 100644
--- a/src/common/string.c
+++ b/src/common/string.c
@@ -4,7 +4,8 @@
  *		string handling helpers
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -42,6 +43,45 @@ pg_str_endswith(const char *str, const char *end)
 	return strcmp(str, end) == 0;
 }
 
+/*
+ * Helper function to check if a page is completely empty.
+ *
+ * TODO Invent name that is more consistent with that of the other function(s)
+ * in this module.
+ */
+bool
+IsAllZero(const char *input, Size size)
+{
+	const char *pos = input;
+	const char *aligned_start = (char *) MAXALIGN64(input);
+	const char *end = input + size;
+
+	/* Check 1 byte at a time until pos is 8 byte aligned */
+	while (pos < aligned_start)
+		if (*pos++ != 0)
+			return false;
+
+	/*
+	 * Run 8 parallel 8 byte checks in one iteration. On 2016 hardware
+	 * slightly faster than 4 parallel checks.
+	 */
+	while (pos + 8 * sizeof(uint64) <= end)
+	{
+		uint64	   *p = (uint64 *) pos;
+
+		if ((p[0] | p[1] | p[2] | p[3] | p[4] | p[5] | p[6] | p[7]) != 0)
+			return false;
+		pos += 8 * sizeof(uint64);
+	}
+
+	/* Handle unaligned tail. */
+	while (pos < end)
+		if (*pos++ != 0)
+			return false;
+
+	return true;
+}
+
 
 /*
  * strtoint --- just like strtol, but returns int not long
diff --git a/src/fe_utils/Makefile b/src/fe_utils/Makefile
index 456c441a33..a9beaab24a 100644
--- a/src/fe_utils/Makefile
+++ b/src/fe_utils/Makefile
@@ -5,6 +5,7 @@
 # This makefile generates a static library, libpgfeutils.a,
 # for use by client applications
 #
+# Portions Copyright (c) 2019-2021, CYBERTEC PostgreSQL International GmbH
 # Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 # Portions Copyright (c) 1994, Regents of the University of California
 #
@@ -23,6 +24,7 @@ OBJS = \
 	archive.o \
 	cancel.o \
 	conditional.o \
+	encryption.o \
 	connect_utils.o \
 	mbprint.o \
 	option_utils.o \
diff --git a/src/fe_utils/encryption.c b/src/fe_utils/encryption.c
new file mode 100644
index 0000000000..0a079579dd
--- /dev/null
+++ b/src/fe_utils/encryption.c
@@ -0,0 +1,499 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.c
+ *	  Front-end code to handle keys for full cluster encryption. The actual
+ *	  encryption is not performed here.
+ *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * IDENTIFICATION
+ *	  src/fe_utils/encryption.c
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+
+#include "postgres_fe.h"
+
+#include "common/fe_memutils.h"
+#include "common/file_perm.h"
+#include "common/logging.h"
+#include "fe_utils/encryption.h"
+#include "libpq-fe.h"
+#include "libpq/pqcomm.h"
+
+#ifdef USE_ENCRYPTION
+#include <openssl/evp.h>
+
+/*
+ * Key derivation function.
+ */
+typedef enum KDFKind
+{
+	KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA = 0
+} KFDKind;
+
+typedef struct KDFParamsPBKDF2
+{
+	unsigned long int niter;
+	unsigned char salt[ENCRYPTION_KDF_SALT_LEN];
+} KDFParamsPBKDF2;
+
+
+typedef struct KDFParamsData_v0
+{
+	KFDKind		function;
+
+	/*
+	 * Function-specific parameters.
+	 */
+	union
+	{
+		KDFParamsPBKDF2 pbkdf2;
+	}			data;
+
+	/* CRC of all above ... MUST BE LAST! */
+	pg_crc32c	crc;
+} KDFParamsData_v0;
+
+#define	SizeOfKDFParamsData_v0	(offsetof(KDFParamsData_v0, crc) + sizeof(pg_crc32c))
+
+/*
+ * Parameters of the key derivation function.
+ *
+ * The parameters are generated by initdb and stored into a file, which is
+ * then read during PG startup. This is similar to storing various settings in
+ * pg_control. However an existing KDF file is read only, so it does not have
+ * to be stored in shared memory.
+ */
+typedef struct KDFParamsData
+{
+	/*
+	 * The key derivation function number is actually stored in the lowest
+	 * byte. The 2nd lowest byte determines the KDF file version, the other
+	 * bytes are unused. XXX The KDFKind type is used for historical reasons
+	 * (there was no version number in TDE 1.0) - is it worth changing to
+	 * another type of the same size?
+	 */
+#define KDF_FUNCTION_MASK	0x000f
+#define KDF_VERSION_MASK	0x00f0
+#define	KDF_CURRENT_VERSION		0x01
+#define KDF_VERSION_SHIFT		4 /* Shift KDF_CURRENT_VERSION to match
+								   * KDF_VERSION_MASK */
+	KFDKind		func_version;
+
+	/*
+	 * Function-specific parameters.
+	 */
+	union
+	{
+		KDFParamsPBKDF2 pbkdf2;
+	}			data;
+
+	/*
+	 * Encryption key length in bytes.
+	 *
+	 * This information is also stored in the control file, but pg_keytool
+	 * might need it to derive the key for initdb at the time the control file
+	 * does not exist yet.
+	 */
+	uint8		key_len;
+
+	/* CRC of all above ... MUST BE LAST! */
+	pg_crc32c	crc;
+} KDFParamsData;
+
+#define	SizeOfKDFParamsData	(offsetof(KDFParamsData, crc) + sizeof(pg_crc32c))
+
+/*
+ * Pointer to the KDF parameters.
+ */
+static KDFParamsData KDFParams;
+
+/* Initialize KDF file. */
+void
+init_kdf(int key_len)
+{
+	KDFParamsPBKDF2 *params;
+	struct timeval tv;
+	uint64	salt;
+
+	memset(&KDFParams, 0, SizeOfKDFParamsData);
+	KDFParams.func_version = (KDF_CURRENT_VERSION << KDF_VERSION_SHIFT) |
+		KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA;
+	params = &KDFParams.data.pbkdf2;
+
+	/*
+	 * Currently we derive the salt in the same way as system identifier,
+	 * however these two values are not supposed to match. XXX Is it worth the
+	 * effort if initdb derives the system identifier, passes it to this
+	 * function and also sends it to the bootstrap process? Not sure.
+	 */
+	gettimeofday(&tv, NULL);
+	salt = ((uint64) tv.tv_sec) << 32;
+	salt |= ((uint64) tv.tv_usec) << 12;
+	salt |= getpid() & 0xFFF;
+
+	memcpy(params->salt, &salt, sizeof(uint64));
+	params->niter = ENCRYPTION_KDF_NITER;
+
+	KDFParams.key_len = key_len;
+}
+
+/*
+ * Write KDFParamsData to file.
+ */
+void
+write_kdf_file(char *dir)
+{
+	char		path[MAXPGPATH];
+	int			fd;
+
+	/* Account for both file separator and terminating NULL character. */
+	if ((strlen(dir) + 1 + strlen(KDF_PARAMS_FILE) + 1) > MAXPGPATH)
+	{
+		pg_log_fatal("KDF directory is too long");
+		exit(EXIT_FAILURE);
+	}
+
+	snprintf(path, MAXPGPATH, "%s/%s", dir, KDF_PARAMS_FILE);
+
+	/* Contents are protected with a CRC */
+	INIT_CRC32C(KDFParams.crc);
+	COMP_CRC32C(KDFParams.crc,
+				(char *) &KDFParams,
+				offsetof(KDFParamsData, crc));
+	FIN_CRC32C(KDFParams.crc);
+
+	fd = open(path, O_WRONLY | O_CREAT | PG_BINARY,
+			  pg_file_create_mode);
+	if (fd < 0)
+	{
+		pg_log_fatal("could not create key derivation file \"%s\": %m", path);
+		exit(EXIT_FAILURE);
+	}
+
+	if (write(fd, &KDFParams, KDF_PARAMS_FILE_SIZE) != KDF_PARAMS_FILE_SIZE)
+	{
+		/* if write didn't set errno, assume problem is no disk space */
+		if (errno == 0)
+			errno = ENOSPC;
+		pg_log_fatal("could not write to key derivation file \"%s\": %m",
+					 path);
+		exit(EXIT_FAILURE);
+	}
+
+	if (close(fd))
+	{
+		pg_log_fatal("could not close key setup file: %m");
+		exit(EXIT_FAILURE);
+	}
+}
+
+/*
+ * Read KDFParamsData from file and store it in local memory.
+ *
+ * If dir is NULL, assume we're in the data directory.
+ *
+ * Returns key length in bytes.
+ */
+int
+read_kdf_file(char *dir)
+{
+	pg_crc32c	crc;
+	char		path[MAXPGPATH];
+	int			fd;
+	KFDKind		func_version;
+	int		version;
+	char	*c, *end;
+	int		remains;
+
+	/* Account for both file separator and terminating NULL character. */
+	if ((strlen(dir) + 1 + strlen(KDF_PARAMS_FILE) + 1) > MAXPGPATH)
+	{
+		pg_log_fatal("KDF directory is too long");
+		exit(EXIT_FAILURE);
+	}
+
+	snprintf(path, MAXPGPATH, "%s/%s", dir, KDF_PARAMS_FILE);
+
+	fd = open(path, O_RDONLY | PG_BINARY, S_IRUSR);
+	if (fd < 0)
+	{
+		pg_log_fatal("could not open key setup file \"%s\": %m", path);
+		exit(EXIT_FAILURE);
+	}
+
+	/* First, check which version we're reading. */
+	if (read(fd, &func_version, sizeof(func_version)) != sizeof(func_version))
+	{
+		pg_log_fatal("could not read from key setup file \"%s\": %m", path);
+		exit(EXIT_FAILURE);
+	}
+	version = (func_version & KDF_VERSION_MASK) >> KDF_VERSION_SHIFT;
+	if (version == 0)
+	{
+		KDFParamsData_v0	params_v0;
+
+		/* Finish reading of the old version. */
+		c = (char *) &params_v0.function + sizeof(params_v0.function);
+		end = (char *) &params_v0 + SizeOfKDFParamsData_v0;
+		remains = end - c;
+		if (read(fd, c, remains) != remains)
+		{
+			pg_log_fatal("could not read from key setup file \"%s\": %m", path);
+			exit(EXIT_FAILURE);
+		}
+		close(fd);
+
+		/* Assign the value we read earlier so that CRC can be computed. */
+		params_v0.function = func_version;
+
+		/* Now check the CRC. */
+		INIT_CRC32C(crc);
+		COMP_CRC32C(crc,
+					(char *) &params_v0,
+					offsetof(KDFParamsData_v0, crc));
+		FIN_CRC32C(crc);
+
+		if (!EQ_CRC32C(crc, params_v0.crc))
+		{
+			pg_log_fatal("incorrect checksum in key setup file \"%s\"", path);
+			exit(EXIT_FAILURE);
+		}
+
+		/* If the version is 0, func_version should match the function. */
+		if (func_version != KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA)
+		{
+			pg_log_fatal("unsupported KDF function");
+			exit(EXIT_FAILURE);
+		}
+
+		/* Initialize the current version. */
+		KDFParams.func_version = func_version |
+			(KDF_CURRENT_VERSION << KDF_VERSION_SHIFT);
+		KDFParams.data.pbkdf2 = params_v0.data.pbkdf2;
+		/* KDF v0 belongs to TDE 1.0, so no choice of the key length. */
+		KDFParams.key_len = DEFAULT_ENCRYPTION_KEY_LENGTH;
+	}
+	else
+	{
+		Assert(version == KDF_CURRENT_VERSION);
+
+		/* Finish reading of the current version. */
+		c = (char *) &KDFParams.func_version + sizeof(KDFParams.func_version);
+		end = (char *) &KDFParams + SizeOfKDFParamsData;
+		remains = end - c;
+		if (read(fd, c, remains) != remains)
+		{
+			pg_log_fatal("could not read from key setup file \"%s\": %m", path);
+			exit(EXIT_FAILURE);
+		}
+		close(fd);
+
+		/* Assign the value we read earlier so that CRC can be computed. */
+		KDFParams.func_version = func_version;
+
+		/* Now check the CRC. */
+		INIT_CRC32C(crc);
+		COMP_CRC32C(crc,
+					(char *) &KDFParams,
+					offsetof(KDFParamsData, crc));
+		FIN_CRC32C(crc);
+
+		if (!EQ_CRC32C(crc, KDFParams.crc))
+		{
+			pg_log_fatal("incorrect checksum in key setup file \"%s\"", path);
+			exit(EXIT_FAILURE);
+		}
+
+		/* Check the function number. */
+		if ((func_version & KDF_FUNCTION_MASK) !=
+			KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA)
+		{
+			pg_log_fatal("unsupported KDF function");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	return KDFParams.key_len;
+}
+
+/*
+ * Run the key derivation function and initialize encryption_key variable.
+ */
+void
+derive_key_from_password(unsigned char *encryption_key, const char *password,
+						 int len)
+{
+	KDFParamsPBKDF2 *params;
+	int			rc;
+
+	params = &KDFParams.data.pbkdf2;
+	rc = PKCS5_PBKDF2_HMAC(password,
+						   len,
+						   params->salt,
+						   ENCRYPTION_KDF_SALT_LEN,
+						   params->niter,
+						   EVP_sha1(),
+						   KDFParams.key_len,
+						   encryption_key);
+
+	if (rc != 1)
+	{
+		pg_log_fatal("failed to derive key from password");
+		exit(EXIT_FAILURE);
+	}
+}
+
+/*
+ * Send the contents of encryption_key in the form of special startup packet
+ * to a server that is being started.
+ *
+ * Returns true if we could send the message and false if not, however even
+ * success does not guarantee that server started up - caller should
+ * eventually test server connection himself. On failure, save pointer to
+ * error message into args->error_msg.
+ */
+bool
+send_key_to_postmaster(SendKeyArgs *args)
+{
+	const char **keywords = pg_malloc0(3 * sizeof(*keywords));
+	const char **values = pg_malloc0(3 * sizeof(*values));
+	int	i;
+	PGconn *conn = NULL;
+	EncryptionKeyMsg	message;
+	int	msg_size;
+
+/* How many seconds we can wait for the postmaster to receive the key. */
+#define SEND_ENCRYPT_KEY_TIMEOUT	60
+
+	if (args->host)
+	{
+		keywords[0] = "host";
+		values[0] = args->host;
+	}
+	if (args->port)
+	{
+		keywords[1] = "port";
+		values[1] = args->port;
+	}
+
+	/* Compose the message. */
+	message.encryptionKeyCode = pg_hton32(ENCRYPTION_KEY_MSG_CODE);
+	message.version = 1;
+	if (args->encryption_key)
+	{
+		memcpy(message.data, args->encryption_key, ENCRYPTION_KEY_MAX_LENGTH);
+		message.empty = false;
+	}
+	else
+		message.empty = true;
+	msg_size = offsetof(EncryptionKeyMsg, data) + ENCRYPTION_KEY_MAX_LENGTH;
+
+	for (i = 0; i < SEND_ENCRYPT_KEY_TIMEOUT + 1; i++)
+	{
+		char	sslmode;
+
+		if (i > 0)
+			/* Sleep for 1 second. */
+			pg_usleep(1000000L);
+
+		/* Has the postmaster crashed? */
+		if (args->pm_pid != 0)
+		{
+#ifndef WIN32
+			int			exitstatus;
+
+			if (waitpid((pid_t) args->pm_pid, &exitstatus, WNOHANG) ==
+				(pid_t) args->pm_pid)
+			{
+				args->pm_exited = true;
+				return false;
+			}
+#else
+			if (WaitForSingleObject(args->pmProcess, 0) == WAIT_OBJECT_0)
+			{
+				args->pm_exited = true;
+				return false;
+			}
+#endif
+		}
+
+		if (conn)
+		{
+			PQfinish(conn);
+			conn = NULL;
+		}
+
+		/*
+		 * Although we don't expect the server to accept regular libpq
+		 * messages at the moment, try to get at least a valid socket.
+		 */
+		conn = PQconnectStartParams(keywords, values, false);
+		if (conn == NULL)
+			continue;
+
+		if (PQstatus(conn) != CONNECTION_STARTED &&
+			PQstatus(conn) != CONNECTION_MADE)
+		{
+			char	*msg = PQerrorMessage(conn);
+
+			if (msg && strlen(msg) > 0)
+				args->error_msg = pstrdup(msg);
+
+			continue;
+		}
+
+		/*
+		 * Unless we're sending the key via unix socket, take SSL mode into
+		 * account ('d' ~ "disable", 'a' ~ "allow", 'p' ~ "prefer"). "allow"
+		 * and "prefer" modes are not useful in terms of security, and
+		 * especially "allow" would be much trickier for
+		 * PQconnectSSLHandshake() to handle.
+		 */
+		sslmode = PQconnectionSSLMode(conn);
+		if (sslmode != 'd' && sslmode != 'a' && sslmode != 'p' &&
+			!PQconnectedToSocket(conn))
+		{
+			if (!PQconnectSSLHandshake(conn))
+			{
+				char	*msg = PQerrorMessage(conn);
+
+				if (msg && strlen(msg) > 0)
+					args->error_msg = pstrdup(msg);
+
+				/*
+				 * If the socket could be opened but SSL is not available, the
+				 * next try probably won't help.
+				 */
+				PQfinish(conn);
+				return false;
+			}
+		}
+
+		/* Send the packet. */
+		if (!PQpacketSend(conn, (char *) &message, msg_size))
+		{
+			args->error_msg = pstrdup(PQerrorMessage(conn));
+			return false;
+		}
+
+		/* Success */
+		break;
+	}
+
+	pg_free(keywords);
+	pg_free(values);
+	if (conn)
+		PQfinish(conn);
+
+	return true;
+}
+#endif	/* USE_ENCRYPTION */
diff --git a/src/include/access/visibilitymap.h b/src/include/access/visibilitymap.h
index 0981b218ea..a8b20d1631 100644
--- a/src/include/access/visibilitymap.h
+++ b/src/include/access/visibilitymap.h
@@ -37,6 +37,7 @@ extern void visibilitymap_set(Relation rel, BlockNumber heapBlk, Buffer heapBuf,
 extern uint8 visibilitymap_get_status(Relation rel, BlockNumber heapBlk, Buffer *vmbuf);
 extern void visibilitymap_count(Relation rel, BlockNumber *all_visible, BlockNumber *all_frozen);
 extern BlockNumber visibilitymap_prepare_truncate(Relation rel,
-												  BlockNumber nheapblocks);
+												  BlockNumber nheapblocks,
+												  XLogRecPtr recptr);
 
 #endif							/* VISIBILITYMAP_H */
diff --git a/src/include/access/xlog.h b/src/include/access/xlog.h
index ee3e369b79..f184825683 100644
--- a/src/include/access/xlog.h
+++ b/src/include/access/xlog.h
@@ -3,7 +3,8 @@
  *
  * PostgreSQL write-ahead log manager
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/access/xlog.h
@@ -19,6 +20,7 @@
 #include "lib/stringinfo.h"
 #include "nodes/pg_list.h"
 #include "storage/fd.h"
+#include "storage/encryption.h"
 
 
 /* Sync methods */
@@ -205,8 +207,9 @@ extern PGDLLIMPORT int wal_level;
  * Normally, we don't WAL-log hint bit updates, but if checksums are enabled,
  * we have to protect them against torn page writes.  When you only set
  * individual bits on a page, it's still consistent no matter what combination
- * of the bits make it to disk, but the checksum wouldn't match.  Also WAL-log
- * them if forced by wal_log_hints=on.
+ * of the bits make it to disk, but the checksum wouldn't match.
+ *
+ * Also WAL-log the hint bits if forced by wal_log_hints=on.
  */
 #define XLogHintBitIsNeeded() (DataChecksumsEnabled() || wal_log_hints)
 
diff --git a/src/include/access/xloginsert.h b/src/include/access/xloginsert.h
index f1d8c39edf..1053546f6f 100644
--- a/src/include/access/xloginsert.h
+++ b/src/include/access/xloginsert.h
@@ -59,6 +59,8 @@ extern void log_newpages(RelFileNode *rnode, ForkNumber forkNum, int num_pages,
 extern XLogRecPtr log_newpage_buffer(Buffer buffer, bool page_std);
 extern void log_newpage_range(Relation rel, ForkNumber forkNum,
 							  BlockNumber startblk, BlockNumber endblk, bool page_std);
+extern void newpage_range_set_lsn(Relation rel, BlockNumber startblk,
+								  BlockNumber endblk);
 extern XLogRecPtr XLogSaveBufferForHint(Buffer buffer, bool buffer_std);
 
 extern void InitXLogInsert(void);
diff --git a/src/include/access/xlogreader.h b/src/include/access/xlogreader.h
index 10458c23ed..7eb4af4c99 100644
--- a/src/include/access/xlogreader.h
+++ b/src/include/access/xlogreader.h
@@ -303,7 +303,7 @@ typedef struct WALReadError
 
 extern bool WALRead(XLogReaderState *state,
 					char *buf, XLogRecPtr startptr, Size count,
-					TimeLineID tli, WALReadError *errinfo);
+					TimeLineID tli, WALReadError *errinfo, bool decrypt);
 
 /* Functions for decoding an XLogRecord */
 
diff --git a/src/include/catalog/pg_control.h b/src/include/catalog/pg_control.h
index 749bce0cc6..22bc993871 100644
--- a/src/include/catalog/pg_control.h
+++ b/src/include/catalog/pg_control.h
@@ -5,7 +5,8 @@
  *	  However, we define it here so that the format is documented.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/catalog/pg_control.h
@@ -19,6 +20,7 @@
 #include "access/xlogdefs.h"
 #include "pgtime.h"				/* for pg_time_t */
 #include "port/pg_crc32c.h"
+#include "storage/encryption.h"
 
 
 /* Version identifier for this pg_control format */
@@ -228,6 +230,14 @@ typedef struct ControlFileData
 	 */
 	char		mock_authentication_nonce[MOCK_AUTH_NONCE_LEN];
 
+	/*
+	 * Cipher used to encrypt data - see the DATA_CIPHER_SET macro for
+	 * details.
+	 */
+	uint8		data_cipher;
+	/* Sample value for encryption key verification */
+	uint8		encryption_verification[ENCRYPTION_SAMPLE_SIZE];
+
 	/* CRC of all above ... MUST BE LAST! */
 	pg_crc32c	crc;
 } ControlFileData;
diff --git a/src/include/common/encryption.h b/src/include/common/encryption.h
new file mode 100644
index 0000000000..f1f636dd3f
--- /dev/null
+++ b/src/include/common/encryption.h
@@ -0,0 +1,111 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.h
+ *	  Transparent Data Encryption specific code usable by both frontend and
+ *	  backend.
+ *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *
+ * IDENTIFICATION
+ *	  src/include/common/encryption.c
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef COMMON_ENCRYPTION_H
+#define COMMON_ENCRYPTION_H
+
+#include "port/pg_crc32c.h"
+
+/*
+ * Full database encryption key.
+ *
+ * The maximum key length is 256 bits.
+ */
+#define	ENCRYPTION_KEY_MAX_LENGTH	32
+
+/* Maximum key length in characters (two characters per hexadecimal digit) */
+#define ENCRYPTION_KEY_MAX_CHARS	(ENCRYPTION_KEY_MAX_LENGTH * 2)
+
+#define KDF_PARAMS_FILE			"global/kdf_params"
+#define KDF_PARAMS_FILE_SIZE	512
+
+#define ENCRYPTION_KDF_NITER		1048576
+#define	ENCRYPTION_KDF_SALT_LEN		sizeof(uint64)
+
+/*
+ * Common error message issued when particular code path cannot be executed
+ * due to absence of the OpenSSL library.
+ */
+#define ENCRYPTION_NOT_SUPPORTED_MSG \
+	"compile postgres with --with-openssl to use encryption."
+
+/*
+ * Cipher used to encrypt data. This value is stored in the control file.
+ *
+ * Due to very specific requirements, the ciphers are not likely to change,
+ * but we should be somewhat flexible.
+ */
+typedef enum CipherKind
+{
+	/* The cluster is not encrypted. */
+	PG_CIPHER_NONE = 0,
+
+	/*
+	 * AES (Rijndael) in CTR mode of operation for relations and WAL, and CBC
+	 * mode for temporary and transient (see the use of
+	 * BufFileOpenTransient()) files.
+	 *
+	 * Neither temporary nor transient files need to be processed by
+	 * pg_upgrade, so we might not want to mention the CBC mode here. However,
+	 * if we add other modes in the future, this information might be useful
+	 * to troubleshoot crashed server.
+	 */
+	PG_CIPHER_AES_CTR_CBC
+}			CipherKind;
+
+/* 128 bits is the key length if no value was specified by the user. */
+#define	DEFAULT_ENCRYPTION_KEY_LENGTH	16
+
+/*
+ * Encode the cipher kind and key length into the data_cipher field of
+ * ControlFileData.
+ *
+ * The bits 0 through 3 determine the cipher kind, bits 4 and 5 the key
+ * length. Bits 6 and 7 are unused.
+ *
+ * Note: This layout was introduced in TDE 1.1. Since TDE 1.0 only stored the
+ * value of CipherKind, and since its maximum value was PG_CIPHER_AES_CTR, the
+ * format should be compatible across TDE versions. (Not sure though if this
+ * compatibility is important right now, but it costs nothing to introduce it
+ * - we needed to change the format for TDE 1.1 anyway.)
+ *
+ * key_len is in bytes. CAUTION: The minimum value of key_len is 16!
+ */
+#define DATA_CIPHER_SET(cipher, kind, key_len) \
+	((cipher) = ((kind) && 0x0f) | (((key_len) - 16) << 1))
+
+/* Mark the cluster unencrypted. */
+#define DATA_CIPHER_CLEAR(cipher) ((cipher) = PG_CIPHER_NONE)
+
+/* Decode the cipher kind and key length respectively. */
+#define DATA_CIPHER_GET_KIND(cipher) ((cipher) & 0x0f)
+#define DATA_CIPHER_GET_KEY_LENGTH(cipher) ((((cipher) & 0x30) >> 1) + 16)
+
+/* Copy of the corresponding field of ControlFileData */
+extern uint8 data_cipher;
+
+/* Executable to retrieve the encryption key. */
+extern char *encryption_key_command;
+
+/* Key to encrypt / decrypt permanent data. */
+extern unsigned char encryption_key[];
+
+/* Key length in bytes. */
+extern int encryption_key_length;
+
+extern void run_encryption_key_command(char *data_dir, int *key_len_p);
+extern void send_encryption_key(FILE *f);
+extern void read_encryption_key_f(FILE *f, char *command, int *key_len_p);
+extern void encryption_key_from_string(char key_str[ENCRYPTION_KEY_MAX_CHARS],
+									   int key_len);
+#endif /* COMMON_ENCRYPTION_H */
diff --git a/src/include/common/string.h b/src/include/common/string.h
index 686c158efe..ba3b28a701 100644
--- a/src/include/common/string.h
+++ b/src/include/common/string.h
@@ -2,7 +2,8 @@
  *	string.h
  *		string handling helpers
  *
- *	Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  *	Portions Copyright (c) 1994, Regents of the University of California
  *
  *	src/include/common/string.h
@@ -18,6 +19,7 @@ extern int	strtoint(const char *pg_restrict str, char **pg_restrict endptr,
 					 int base);
 extern void pg_clean_ascii(char *str);
 extern int	pg_strip_crlf(char *str);
+extern bool IsAllZero(const char *input, Size size);
 extern bool pg_is_ascii(const char *str);
 
 /* functions in src/common/pg_get_line.c */
diff --git a/src/include/fe_utils/encryption.h b/src/include/fe_utils/encryption.h
new file mode 100644
index 0000000000..7f1e9a7816
--- /dev/null
+++ b/src/include/fe_utils/encryption.h
@@ -0,0 +1,54 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.h
+ *	  Client code to support full cluster encryption.
+ *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * IDENTIFICATION
+ *	  src/include/fe_utils/encryption.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#include "common/encryption.h"
+
+extern void init_kdf(int key_len);
+extern void update_kdf_key_length(uint8 key_len);
+extern void write_kdf_file(char *dir);
+extern int read_kdf_file(char *dir);
+extern void derive_key_from_password(unsigned char *encryption_key,
+									 const char *password, int len);
+
+/*
+ * Arguments for send_key_to_postmaster().
+ *
+ * If host or port are NULL, we expect libpq to use its defaults.
+ *
+ * If encryption_key is NULL, send an "empty message". This tells postmaster
+ * that the client (typically pg_ctl) has no key, so postmaster should stop
+ * waiting for it and try to get the key elsewhere.
+ *
+ * If error occurs, the appropriate message is stored in error_msg.
+ */
+typedef struct SendKeyArgs
+{
+	char	*host;
+	char	*port;
+	const unsigned char *encryption_key;
+
+	long pm_pid;
+	bool	pm_exited;
+#ifdef WIN32
+	/*
+	 * Set this *in addition to* pm_pid, otherwise it's hard to tell whether
+	 * the handle is valid.
+	 */
+	HANDLE	pmProcess;
+#endif
+
+	char *error_msg;
+} SendKeyArgs;
+
+extern bool send_key_to_postmaster(SendKeyArgs *args);
diff --git a/src/include/libpq/pqcomm.h b/src/include/libpq/pqcomm.h
index be9d970574..b5c446d0aa 100644
--- a/src/include/libpq/pqcomm.h
+++ b/src/include/libpq/pqcomm.h
@@ -6,7 +6,8 @@
  * NOTE: for historical reasons, this does not correspond to pqcomm.c.
  * pqcomm.c's routines are declared in libpq.h.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/libpq/pqcomm.h
@@ -23,6 +24,8 @@
 #endif
 #include <netinet/in.h>
 
+#include "common/encryption.h"
+
 #ifdef HAVE_STRUCT_SOCKADDR_STORAGE
 
 #ifndef HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
@@ -191,4 +194,27 @@ typedef struct CancelRequestPacket
 #define NEGOTIATE_SSL_CODE PG_PROTOCOL(1234,5679)
 #define NEGOTIATE_GSS_CODE PG_PROTOCOL(1234,5680)
 
+/* Client can also send cluster encryption key to the postmaster. */
+#define ENCRYPTION_KEY_MSG_CODE PG_PROTOCOL(1234,5681)
+
+/*
+ * Message containing the encryption key, received by postmaster during
+ * startup.
+ *
+ * TODO Consider adding extension identifier and key_length field so that
+ * postmaster can also receive extension-specific keys. Extension that needs a
+ * key would call a function from _PG_init() that tells postmaster where to
+ * store the key and how long the key is. (Should also postgres in standalone
+ * mode accept keys for extensions?)
+ */
+typedef struct EncryptionKeyMsg
+{
+	/* Note this integer field is stored in network byte order! */
+	MsgType		encryptionKeyCode;	/* code to identify a key message */
+
+	bool	empty;	 /* doesn't this message contain any key? */
+	unsigned char	version;	/* message format version. */
+	char	data[ENCRYPTION_KEY_MAX_LENGTH];	/* the key itself. */
+} EncryptionKeyMsg;
+
 #endif							/* PQCOMM_H */
diff --git a/src/include/nodes/replnodes.h b/src/include/nodes/replnodes.h
index faa3a251f2..8ffa8c6766 100644
--- a/src/include/nodes/replnodes.h
+++ b/src/include/nodes/replnodes.h
@@ -4,7 +4,8 @@
  *	  definitions for replication grammar parse nodes
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/nodes/replnodes.h
@@ -84,6 +85,7 @@ typedef struct StartReplicationCmd
 	TimeLineID	timeline;
 	XLogRecPtr	startpoint;
 	List	   *options;
+	bool	decrypt;
 } StartReplicationCmd;
 
 
diff --git a/src/include/pg_config_manual.h b/src/include/pg_config_manual.h
index 614035e215..f0a6b5300d 100644
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -6,7 +6,8 @@
  * for developers.  If you edit any of these, be sure to do a *full*
  * rebuild (and an initdb if noted).
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/pg_config_manual.h
@@ -189,6 +190,13 @@
 #define USE_SSL
 #endif
 
+/*
+ * OpenSSL is currently the only implementation of encryption we use.
+ */
+#ifdef USE_OPENSSL
+#define USE_ENCRYPTION
+#endif
+
 /*
  * This is the default directory in which AF_UNIX socket files are
  * placed.  Caution: changing this risks breaking your existing client
diff --git a/src/include/pgstat.h b/src/include/pgstat.h
index 9a90bd8113..04c40aebb7 100644
--- a/src/include/pgstat.h
+++ b/src/include/pgstat.h
@@ -3,7 +3,8 @@
  *
  *	Definitions for the PostgreSQL statistics collector daemon.
  *
- *	Copyright (c) 2001-2021, PostgreSQL Global Development Group
+ *	Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ *	Copyright (c) 2001-2022, PostgreSQL Global Development Group
  *
  *	src/include/pgstat.h
  * ----------
diff --git a/src/include/replication/reorderbuffer.h b/src/include/replication/reorderbuffer.h
index ba257d81b5..8b663213b2 100644
--- a/src/include/replication/reorderbuffer.h
+++ b/src/include/replication/reorderbuffer.h
@@ -2,7 +2,8 @@
  * reorderbuffer.h
  *	  PostgreSQL logical replay/reorder buffer management.
  *
- * Copyright (c) 2012-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Copyright (c) 2012-2022, PostgreSQL Global Development Group
  *
  * src/include/replication/reorderbuffer.h
  */
@@ -582,9 +583,6 @@ struct ReorderBuffer
 
 	XLogRecPtr	current_restart_decoding_lsn;
 
-	/* buffer for disk<->memory conversions */
-	char	   *outbuf;
-	Size		outbufsize;
 
 	/* memory accounting */
 	Size		size;
diff --git a/src/include/replication/walreceiver.h b/src/include/replication/walreceiver.h
index 4fd7c25ea7..a28bd5ad23 100644
--- a/src/include/replication/walreceiver.h
+++ b/src/include/replication/walreceiver.h
@@ -3,7 +3,8 @@
  * walreceiver.h
  *	  Exports from replication/walreceiverfuncs.c.
  *
- * Portions Copyright (c) 2010-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 2010-2022, PostgreSQL Global Development Group
  *
  * src/include/replication/walreceiver.h
  *
@@ -174,6 +175,7 @@ typedef struct
 		struct
 		{
 			TimeLineID	startpointTLI;	/* Starting timeline */
+			bool	decrypt;			/* Decrypt the stream? */
 		}			physical;
 		struct
 		{
diff --git a/src/include/storage/buf_internals.h b/src/include/storage/buf_internals.h
index 33fcaf5c9a..7259061b60 100644
--- a/src/include/storage/buf_internals.h
+++ b/src/include/storage/buf_internals.h
@@ -336,7 +336,7 @@ extern PrefetchBufferResult PrefetchLocalBuffer(SMgrRelation smgr,
 												BlockNumber blockNum);
 extern BufferDesc *LocalBufferAlloc(SMgrRelation smgr, ForkNumber forkNum,
 									BlockNumber blockNum, bool *foundPtr);
-extern void MarkLocalBufferDirty(Buffer buffer);
+extern void MarkLocalBufferDirty(Buffer buffer, bool set_lsn);
 extern void DropRelFileNodeLocalBuffers(RelFileNode rnode, ForkNumber forkNum,
 										BlockNumber firstDelBlock);
 extern void DropRelFileNodeAllLocalBuffers(RelFileNode rnode);
diff --git a/src/include/storage/buffile.h b/src/include/storage/buffile.h
index 566523de1f..ad86591f45 100644
--- a/src/include/storage/buffile.h
+++ b/src/include/storage/buffile.h
@@ -15,7 +15,8 @@
  * but currently we have no need for oversize temp files without buffered
  * access.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/storage/buffile.h
@@ -26,20 +27,139 @@
 #ifndef BUFFILE_H
 #define BUFFILE_H
 
+#include "storage/encryption.h"
 #include "storage/sharedfileset.h"
 
-/* BufFile is an opaque type whose details are not known outside buffile.c. */
+/*
+ * BufFile and TransientBufFile are opaque types whose details are not known
+ * outside buffile.c.
+ */
 
 typedef struct BufFile BufFile;
+typedef struct TransientBufFile TransientBufFile;
 
 /*
- * prototypes for functions in buffile.c
+ * If the file is encrypted, some metadata is needed for each buffer. Thus we
+ * can only start load/dump at an offset that is a whole multiple of BLCKSZ.
+ */
+typedef struct BufFilePageHeader
+{
+	/* The encryption IV. */
+	char		tweak[TWEAK_SIZE];
+
+	/*
+	 * The number of useful bytes in the buffer, the rest is only padding up
+	 * to BLCKSZ. Note that this field is included in the encrypted region.
+	 */
+	int16	nbytes;
+} BufFilePageHeader;
+
+#define	SizeOfBufFilePageHeader	(offsetof(BufFilePageHeader, nbytes) + sizeof(int16))
+
+/*
+ * Express segment size in the number of blocks.
+ *
+ * We break BufFiles into gigabyte-sized segments, regardless of RELSEG_SIZE.
+ * The reason is that we'd like large BufFiles to be spread across multiple
+ * tablespaces when available.
+ */
+#define BUFFILE_SEG_BLOCKS	0x20000
+
+#define MAX_PHYSICAL_FILESIZE(blocks)	((blocks) * BLCKSZ)
+
+/* GUC to control size of the file segment. */
+extern int buffile_seg_blocks;
+
+/* Segment size in bytes, derived from the above. */
+extern int buffile_max_filesize;
+
+/* Number of BLCKSZ chunks that user can write into a single segment file. */
+extern int buffile_seg_blocks_logical;
+
+/* The amount of data a full segment file occupies on disk. */
+#define	BYTES_PER_SEGMENT	(buffile_seg_blocks * BLCKSZ)
+
+/*
+ * The amount of data user can write into a single segment file. If the
+ * instance is encrypted, this is lower than BYTES_PER_SEGMENT because the
+ * file blocks contain metadata (headers).
+ */
+#define	BYTES_PER_SEGMENT_LOGICAL	(buffile_seg_blocks_logical * BLCKSZ)
+
+/*
+ * User of buffile.c should only be interested in the logical position. The
+ * physical position is the same for unencrypted file, however it's different
+ * for encrypted file due to the presence of BufFilePageHeader.
  */
+static inline off_t
+BufFileLogicalToPhysicalPos(off_t pos)
+{
+	off_t	last_seg_bytes, result,	full_segs;
+
+	if (!data_encrypted)
+		return pos;
+
+	full_segs = pos / BYTES_PER_SEGMENT_LOGICAL;
+	result = full_segs * BYTES_PER_SEGMENT;
+
+	last_seg_bytes = pos % BYTES_PER_SEGMENT_LOGICAL;
+	if (last_seg_bytes > 0)
+	{
+		off_t	full_blocks, last_block_usage;
+		off_t	useful_per_block = BLCKSZ - SizeOfBufFilePageHeader;
+
+		full_blocks = last_seg_bytes / useful_per_block;
+		result += full_blocks * BLCKSZ;
+
+		last_block_usage = last_seg_bytes % useful_per_block;
+		if (last_block_usage > 0)
+			result += last_block_usage;
+	}
+
+	/*
+	 * Even if we're at block boundary, add the header size so that we end
+	 * up at usable position.
+	 */
+	result += SizeOfBufFilePageHeader;
+
+	return result;
+}
+
+static inline off_t
+BufFilePhysicalToLogicalPos(off_t pos)
+{
+	off_t	full_segs, last_seg_bytes, result;
+
+	if (!data_encrypted)
+		return pos;
 
+	full_segs = pos / BYTES_PER_SEGMENT;
+	result = full_segs * BYTES_PER_SEGMENT_LOGICAL;
+
+	last_seg_bytes = pos % BYTES_PER_SEGMENT;
+	if (last_seg_bytes > 0)
+	{
+		off_t	full_blocks, last_block_usage;
+
+		full_blocks = last_seg_bytes / BLCKSZ;
+		last_block_usage = last_seg_bytes % BLCKSZ;
+
+		result += full_blocks * (BLCKSZ - SizeOfBufFilePageHeader);
+		if (last_block_usage > 0)
+			result += last_block_usage - SizeOfBufFilePageHeader;
+	}
+
+	return result;
+}
+
+/*
+ * prototypes for functions in buffile.c
+ */
+extern void BufFileAdjustConfiguration(int buffile_seg_blocks);
 extern BufFile *BufFileCreateTemp(bool interXact);
 extern void BufFileClose(BufFile *file);
 extern size_t BufFileRead(BufFile *file, void *ptr, size_t size);
-extern void BufFileWrite(BufFile *file, void *ptr, size_t size);
+extern size_t BufFileWrite(BufFile *file, void *ptr, size_t size);
 extern int	BufFileSeek(BufFile *file, int fileno, off_t offset, int whence);
 extern void BufFileTell(BufFile *file, int *fileno, off_t *offset);
 extern int	BufFileSeekBlock(BufFile *file, long blknum);
@@ -53,4 +173,13 @@ extern BufFile *BufFileOpenShared(SharedFileSet *fileset, const char *name,
 extern void BufFileDeleteShared(SharedFileSet *fileset, const char *name);
 extern void BufFileTruncateShared(BufFile *file, int fileno, off_t offset);
 
+extern TransientBufFile *BufFileOpenTransient(const char *path, int fileFlags,
+											  int elevel);
+extern void BufFileCloseTransient(TransientBufFile *file);
+extern File BufFileTransientGetVfd(TransientBufFile *file);
+extern size_t BufFileReadTransient(TransientBufFile *file, void *ptr,
+					 size_t size);
+extern size_t BufFileWriteTransient(TransientBufFile *file, void *ptr,
+					  size_t size);
+
 #endif							/* BUFFILE_H */
diff --git a/src/include/storage/bufpage.h b/src/include/storage/bufpage.h
index c86ccdaf60..055454b066 100644
--- a/src/include/storage/bufpage.h
+++ b/src/include/storage/bufpage.h
@@ -4,7 +4,8 @@
  *	  Standard POSTGRES buffer page definitions.
  *
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/include/storage/bufpage.h
@@ -433,7 +434,8 @@ StaticAssertDecl(BLCKSZ == ((BLCKSZ / sizeof(size_t)) * sizeof(size_t)),
 				 "BLCKSZ has to be a multiple of sizeof(size_t)");
 
 extern void PageInit(Page page, Size pageSize, Size specialSize);
-extern bool PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags);
+extern bool PageIsVerifiedExtended(Page page, BlockNumber blkno, int flags,
+								   Page page_encr);
 extern OffsetNumber PageAddItemExtended(Page page, Item item, Size size,
 										OffsetNumber offsetNumber, int flags);
 extern Page PageGetTempPage(Page page);
diff --git a/src/include/storage/checksum_impl.h b/src/include/storage/checksum_impl.h
index ef30268330..a925eb1094 100644
--- a/src/include/storage/checksum_impl.h
+++ b/src/include/storage/checksum_impl.h
@@ -190,9 +190,6 @@ pg_checksum_page(char *page, BlockNumber blkno)
 	uint16		save_checksum;
 	uint32		checksum;
 
-	/* We only calculate the checksum for properly-initialized pages */
-	Assert(!PageIsNew(&cpage->phdr));
-
 	/*
 	 * Save pd_checksum and temporarily set it to zero, so that the checksum
 	 * calculation isn't affected by the old checksum stored on the page.
diff --git a/src/include/storage/encryption.h b/src/include/storage/encryption.h
new file mode 100644
index 0000000000..5c308eb74a
--- /dev/null
+++ b/src/include/storage/encryption.h
@@ -0,0 +1,161 @@
+/*-------------------------------------------------------------------------
+ *
+ * encryption.h
+ *	  Full database encryption support
+ *
+ *
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * src/include/storage/encryption.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef ENCRYPTION_H
+#define ENCRYPTION_H
+
+#include "access/xlogdefs.h"
+#include "common/encryption.h"
+#include "miscadmin.h"
+#include "storage/block.h"
+#include "storage/bufpage.h"
+#include "storage/relfilenode.h"
+#include "port/pg_crc32c.h"
+
+/* Is the cluster encrypted? */
+extern bool data_encrypted;
+
+/*
+ * Number of bytes reserved to store encryption sample in ControlFileData.
+ */
+#define ENCRYPTION_SAMPLE_SIZE 16
+
+typedef int (*read_encryption_key_cb) (void);
+/*
+ * This function raises ERROR if the cluster is encrypted but the binary does
+ * not support encryption, so it's compiled regardless the value of
+ * USE_ENCRYPTION. It's less invasive than if we had to ifdef each call.
+ */
+extern int read_encryption_key(read_encryption_key_cb read_char, int *key_len);
+
+/*
+ * Likewise, compile regardless USE_ENCRYPTION.
+ */
+extern void setup_encryption(void);
+
+#ifndef FRONTEND
+/* Copy of the same field of ControlFileData. */
+extern char encryption_verification[];
+
+extern XLogRecPtr get_lsn_for_encryption(void);
+extern void set_page_lsn_for_encryption(Page page);
+extern void set_page_lsn_for_encryption2(Page page1, Page page2);
+extern void set_page_lsn_for_encryption3(Page page1, Page page2, Page page3);
+#endif	/* FRONTEND */
+
+#define TWEAK_SIZE 16
+
+/*
+ * In some cases we need a separate copy of the data because encryption
+ * in-place (typically in the shared buffers) would make the data unusable for
+ * backends.
+ */
+extern PGAlignedBlock encrypt_buf;
+
+/*
+ * The same for XLOG. This buffer spans multiple pages, in order to reduce the
+ * number of syscalls when doing I/O.
+ *
+ * XXX Fine tune the buffer size.
+ */
+#define ENCRYPT_BUF_XLOG_SIZE	(XLOG_ENCRYPT_BUF_PAGES * XLOG_BLCKSZ)
+extern char *encrypt_buf_xlog;
+
+#define	XLOG_ENCRYPT_BUF_PAGES	8
+
+#ifndef FRONTEND
+/*
+ * Space for the encryption key in shared memory. Backend that receives the
+ * key during startup stores it here so postmaster can eventually take a local
+ * copy.
+ *
+ * Although postmaster should not do anything else with shared memory beyond
+ * its setup, mere reading of this structure should not be a problem. The
+ * worst thing that shared memory corruption can cause is wrong or missing
+ * key, both of which will be detected later during the startup. (Failed
+ * startup is not a real crash.) However we don't dare to use spinlock here
+ * because that way shared memory corruption could cause postmaster to end up
+ * in an infinite loop. See processEncryptionKey() for more comments on
+ * synchronization.
+ */
+typedef struct ShmemEncryptionKey
+{
+	char	data[ENCRYPTION_KEY_MAX_LENGTH]; /* the key */
+	bool	received;				/* received the key message? */
+	bool	empty;					/* was the key message empty? */
+} ShmemEncryptionKey;
+
+/*
+ * Encryption key in the shared memory.
+ */
+extern ShmemEncryptionKey *encryption_key_shmem;
+#endif							/* FRONTEND */
+
+/* Do we have encryption_key and the encryption library initialized? */
+extern bool	encryption_setup_done;
+
+#ifndef FRONTEND
+extern Size EncryptionShmemSize(void);
+extern void EncryptionShmemInit(void);
+#endif							/* FRONTEND */
+
+#ifdef USE_ENCRYPTION
+
+extern void encryption_error(bool fatal, char *message);
+#endif	/* USE_ENCRYPTION */
+
+/*
+ * Different kinds of data require different ciphers and keys.
+ */
+typedef enum EncryptedDataKind
+{
+	EDK_REL_WAL,				/* Relations and WAL. */
+	EDK_BUFFILE					/* Temporary and transient files
+								 * (buffile.c) */
+} EncryptedDataKind;
+
+/*
+ * These functions do interact with OpenSSL, but we only enclose the relevant
+ * parts in "#ifdef USE_ENCRYPTION". Thus caller does not have to use #ifdef
+ * and the encryption code is less invasive.
+ */
+extern void encrypt_block(const char *input, char *output, Size size,
+						  char *tweak, XLogRecPtr lsn, BlockNumber block,
+						  EncryptedDataKind data_kind);
+extern void decrypt_block(const char *input, char *output, Size size,
+						  char *tweak, BlockNumber block,
+						  EncryptedDataKind data_kind);
+
+/*
+ * Convenience macros to encrypt / decrypt relation page.
+ */
+#define encrypt_page(input, output, lsn, block)			\
+	encrypt_block((input), (output), BLCKSZ, NULL, (lsn), (block),		\
+				  EDK_REL_WAL);
+#define decrypt_page(input, output, block)	\
+	decrypt_block((input), (output), BLCKSZ, NULL, (block), \
+				  EDK_REL_WAL);
+
+/*
+ * The following functions do not interact with OpenSSL directly so they are
+ * not ifdef'd using USE_ENCRYPTION. If we ifdef'd them, caller would have to
+ * do the same.
+ */
+extern void sample_encryption(char *buf);
+extern void XLogEncryptionTweak(char *tweak, TimeLineID timeline,
+					XLogSegNo segment, uint32 offset);
+extern void mdtweak(char *tweak, RelFileNode *relnode, ForkNumber forknum,
+		BlockNumber blocknum);
+
+#endif							/* ENCRYPTION_H */
diff --git a/src/include/storage/fd.h b/src/include/storage/fd.h
index 5b3c280dd7..6b59f74044 100644
--- a/src/include/storage/fd.h
+++ b/src/include/storage/fd.h
@@ -88,9 +88,11 @@ extern File PathNameOpenFile(const char *fileName, int fileFlags);
 extern File PathNameOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode);
 extern File OpenTemporaryFile(bool interXact);
 extern void FileClose(File file);
+extern bool FileIsClosed(File file);
 extern int	FilePrefetch(File file, off_t offset, int amount, uint32 wait_event_info);
 extern int	FileRead(File file, char *buffer, int amount, off_t offset, uint32 wait_event_info);
-extern int	FileWrite(File file, char *buffer, int amount, off_t offset, uint32 wait_event_info);
+extern int	FileWrite(File file, char *buffer, int amount, off_t offset,
+					  uint32 wait_event_info, int elevel);
 extern int	FileSync(File file, uint32 wait_event_info);
 extern off_t FileSize(File file);
 extern int	FileTruncate(File file, off_t offset, uint32 wait_event_info);
diff --git a/src/include/storage/freespace.h b/src/include/storage/freespace.h
index 600826ca4b..cdf47a7e07 100644
--- a/src/include/storage/freespace.h
+++ b/src/include/storage/freespace.h
@@ -14,6 +14,7 @@
 #ifndef FREESPACE_H_
 #define FREESPACE_H_
 
+#include "access/xlogdefs.h"
 #include "storage/block.h"
 #include "storage/relfilenode.h"
 #include "utils/relcache.h"
@@ -31,9 +32,10 @@ extern void XLogRecordPageWithFreeSpace(RelFileNode rnode, BlockNumber heapBlk,
 										Size spaceAvail);
 
 extern BlockNumber FreeSpaceMapPrepareTruncateRel(Relation rel,
-												  BlockNumber nblocks);
+												  BlockNumber nblocks,
+												  XLogRecPtr recptr);
 extern void FreeSpaceMapVacuum(Relation rel);
 extern void FreeSpaceMapVacuumRange(Relation rel, BlockNumber start,
-									BlockNumber end);
+									BlockNumber end, XLogRecPtr recptr);
 
 #endif							/* FREESPACE_H_ */
diff --git a/src/include/utils/wait_event.h b/src/include/utils/wait_event.h
index 4b1cea6593..8995421bf6 100644
--- a/src/include/utils/wait_event.h
+++ b/src/include/utils/wait_event.h
@@ -189,8 +189,6 @@ typedef enum
 	WAIT_EVENT_RELATION_MAP_READ,
 	WAIT_EVENT_RELATION_MAP_SYNC,
 	WAIT_EVENT_RELATION_MAP_WRITE,
-	WAIT_EVENT_REORDER_BUFFER_READ,
-	WAIT_EVENT_REORDER_BUFFER_WRITE,
 	WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ,
 	WAIT_EVENT_REPLICATION_SLOT_READ,
 	WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC,
diff --git a/src/interfaces/libpq/exports.txt b/src/interfaces/libpq/exports.txt
index e8bcc88370..a72a79cf3b 100644
--- a/src/interfaces/libpq/exports.txt
+++ b/src/interfaces/libpq/exports.txt
@@ -176,6 +176,10 @@ PQresultMemorySize        173
 PQhostaddr                174
 PQgssEncInUse             175
 PQgetgssctx               176
+PQconnectSSLHandshake     177
+PQpacketSend              178
+PQconnectionSSLMode       179
+PQconnectedToSocket       180
 PQsetSSLKeyPassHook_OpenSSL         177
 PQgetSSLKeyPassHook_OpenSSL         178
 PQdefaultSSLKeyPassHook_OpenSSL     179
diff --git a/src/interfaces/libpq/fe-connect.c b/src/interfaces/libpq/fe-connect.c
index 709ba15220..befb21e7a0 100644
--- a/src/interfaces/libpq/fe-connect.c
+++ b/src/interfaces/libpq/fe-connect.c
@@ -3,7 +3,8 @@
  * fe-connect.c
  *	  functions related to setting up a connection to the backend
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -374,7 +375,7 @@ static const char short_uri_designator[] = "postgres://";
 static bool connectOptions1(PGconn *conn, const char *conninfo);
 static bool connectOptions2(PGconn *conn);
 static int	connectDBStart(PGconn *conn);
-static int	connectDBComplete(PGconn *conn);
+static int	connectDBComplete(PGconn *conn, bool ssl_handshake_only);
 static PGPing internal_ping(PGconn *conn);
 static PGconn *makeEmptyPGconn(void);
 static bool fillPGconn(PGconn *conn, PQconninfoOption *connOptions);
@@ -665,7 +666,7 @@ PQconnectdbParams(const char *const *keywords,
 	PGconn	   *conn = PQconnectStartParams(keywords, values, expand_dbname);
 
 	if (conn && conn->status != CONNECTION_BAD)
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	return conn;
 
@@ -719,7 +720,7 @@ PQconnectdb(const char *conninfo)
 	PGconn	   *conn = PQconnectStart(conninfo);
 
 	if (conn && conn->status != CONNECTION_BAD)
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	return conn;
 }
@@ -879,6 +880,76 @@ PQconnectStart(const char *conninfo)
 	return conn;
 }
 
+
+/*
+ * Bring a connection created earlier by PQconnectStart / PQconnectStartParams
+ * into CONNECTION_MADE state with SSL handshake complete.
+ *
+ * Returns 1 on success, 0 on failure.
+ */
+int
+PQconnectSSLHandshake(PGconn *conn)
+{
+	if (!connectDBComplete(conn, true))
+		return 0;
+
+	if (conn->status != CONNECTION_MADE || !conn->ssl_in_use)
+		return 0;
+
+	return 1;
+}
+
+/*
+ * Return the first letter of conn->sslmode.
+ */
+char
+PQconnectionSSLMode(PGconn *conn)
+{
+	return conn->sslmode[0];
+}
+
+/*
+ * Return 1 if connected to unix domain socket, 0 otherwise.
+ */
+int
+PQconnectedToSocket(PGconn *conn)
+{
+	return (conn->connhost[0].type == CHT_UNIX_SOCKET) ? 1 : 0;
+}
+
+/*
+ * This function only exposes pqPacketSend() to libpq users.
+ *
+ * XXX Currently it's only used to send the encryption key to postmaster, so
+ * we might want to rename the function (PQsendEncryptionKey) and let it
+ * construct the packet. However that would introduce dependency on the
+ * encryption specific code.
+ *
+ * Returns 1 on success, 0 on failure.
+ */
+int
+PQpacketSend(PGconn *conn, char *data, size_t len)
+{
+	/*
+	 * All connection states we expect here should have ended up at
+	 * PGRES_POLLING_WRITING, so poll for write.
+	 */
+	if (pqWaitTimed(0, 1, conn, -1) == -1)
+		return 0;
+
+	if (pqPacketSend(conn, 0, data, len) != STATUS_OK ||
+		conn->write_failed)
+	{
+		char		sebuf[PG_STRERROR_R_BUFLEN];
+
+		appendPQExpBuffer(&conn->errorMessage, "%s\n",
+						  SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));
+		return 0;
+	}
+
+	return 1;
+}
+
 /*
  * Move option values into conn structure
  *
@@ -1619,7 +1690,7 @@ PQsetdbLogin(const char *pghost, const char *pgport, const char *pgoptions,
 	 * Connect to the database
 	 */
 	if (connectDBStart(conn))
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	return conn;
 
@@ -2113,10 +2184,15 @@ connect_errReturn:
  *
  * Block and complete a connection.
  *
+ * If ssl_handshake_only is set, caller is only interested in the
+ * CONNECTION_MADE status preceded by CONNECTION_SSL_STARTUP. In such a case
+ * caller is not interested in PostgresPollingStatusType - typically because
+ * he'll use the socket in blocking mode.
+ *
  * Returns 1 on success, 0 on failure.
  */
 static int
-connectDBComplete(PGconn *conn)
+connectDBComplete(PGconn *conn, bool ssl_handshake_only)
 {
 	PostgresPollingStatusType flag = PGRES_POLLING_WRITING;
 	time_t		finish_time = ((time_t) -1);
@@ -2173,6 +2249,25 @@ connectDBComplete(PGconn *conn)
 			last_addr_cur = conn->addr_cur;
 		}
 
+#ifdef USE_ENCRYPTION
+		if (ssl_handshake_only)
+		{
+			if (conn->status == CONNECTION_MADE)
+			{
+				if (conn->ssl_in_use)
+					return 1;
+
+				/*
+				 * If we got that far and SSL is not allowed, it will never be
+				 * enabled. (XXX Actually it can be if sslmode is "allow", but
+				 * we don't consider this mode useful for key transfer.)
+				 */
+				if (!conn->allow_ssl_try)
+					return 0;
+			}
+		}
+#endif	/* USE_ENCRYPTION */
+
 		/*
 		 * Wait, if necessary.  Note that the initial state (just after
 		 * PQconnectStart) is to wait for the socket to select for writing.
@@ -3892,7 +3987,7 @@ internal_ping(PGconn *conn)
 
 	/* Attempt to complete the connection */
 	if (conn->status != CONNECTION_BAD)
-		(void) connectDBComplete(conn);
+		(void) connectDBComplete(conn, false);
 
 	/* Definitely OK if we succeeded */
 	if (conn->status != CONNECTION_BAD)
@@ -4283,7 +4378,7 @@ PQreset(PGconn *conn)
 	{
 		closePGconn(conn);
 
-		if (connectDBStart(conn) && connectDBComplete(conn))
+		if (connectDBStart(conn) && connectDBComplete(conn, false))
 		{
 			/*
 			 * Notify event procs of successful reset.  We treat an event proc
diff --git a/src/interfaces/libpq/libpq-fe.h b/src/interfaces/libpq/libpq-fe.h
index a6fd69aceb..799e0fe06f 100644
--- a/src/interfaces/libpq/libpq-fe.h
+++ b/src/interfaces/libpq/libpq-fe.h
@@ -4,7 +4,8 @@
  *	  This file contains definitions for structures and
  *	  externs for functions used by frontend postgres applications.
  *
- * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
+ * Portions Copyright (c) 2019-2022, CYBERTEC PostgreSQL International GmbH
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * src/interfaces/libpq/libpq-fe.h
@@ -280,6 +281,10 @@ extern PGconn *PQconnectStart(const char *conninfo);
 extern PGconn *PQconnectStartParams(const char *const *keywords,
 									const char *const *values, int expand_dbname);
 extern PostgresPollingStatusType PQconnectPoll(PGconn *conn);
+extern int PQconnectSSLHandshake(PGconn *conn);
+extern char PQconnectionSSLMode(PGconn *conn);
+extern int PQconnectedToSocket(PGconn *conn);
+extern int PQpacketSend(PGconn *conn, char *data, size_t len);
 
 /* Synchronous (blocking) */
 extern PGconn *PQconnectdb(const char *conninfo);
